{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyfuzzy-toolbox Documentation","text":"<p>Welcome to pyfuzzy-toolbox, a comprehensive Python library for Fuzzy Systems with focus on education and professional applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udde9 Core: Membership functions, fuzzy sets, linguistic variables, operators</li> <li>\ud83c\udf9b\ufe0f Inference: Mamdani and Sugeno/TSK systems</li> <li>\ud83e\udde0 Learning: ANFIS, Wang-Mendel, metaheuristic optimization (PSO, DE, GA)</li> <li>\ud83c\udf0a Dynamics: Fuzzy ODEs and p-fuzzy systems</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p> Getting Started</p> <p>Install pyfuzzy-toolbox and create your first fuzzy system in 5 minutes</p> <p> Installation  Quickstart</p> </li> <li> <p> User Guide</p> <p>Learn how to use fuzzy systems to solve real-world problems</p> <p> Fundamentals  Inference Systems</p> </li> <li> <p> Quick Start Guides</p> <p>Step-by-step practical guides for all modules with complete examples</p> <p> All Quick Starts  ANFIS  Mamdani System</p> </li> <li> <p> API Reference</p> <p>Complete reference for all classes and methods</p> <p> Core API  Inference API</p> </li> <li> <p> Examples</p> <p>Gallery of Colab notebooks with practical examples</p> <p> Examples Gallery</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyfuzzy-toolbox\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import fuzzy_systems as fs\n\n# Create Mamdani system\nsystem = fs.MamdaniSystem()\nsystem.add_input('temperature', (0, 40))\nsystem.add_output('fan_speed', (0, 100))\n\n# Add terms\nsystem.add_term('temperature', 'cold', 'triangular', (0, 0, 20))\nsystem.add_term('temperature', 'hot', 'triangular', (20, 40, 40))\nsystem.add_term('fan_speed', 'slow', 'triangular', (0, 0, 50))\nsystem.add_term('fan_speed', 'fast', 'triangular', (50, 100, 100))\n\n# Add rules\nsystem.add_rules([('cold', 'slow'), ('hot', 'fast')])\n\n# Evaluate\nresult = system.evaluate(temperature=25)\nprint(f\"Fan speed: {result['fan_speed']:.1f}%\")\n</code></pre>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>PyPI: pypi.org/project/pyfuzzy-toolbox</li> <li>GitHub: github.com/1moi6/pyfuzzy-toolbox</li> <li>Issues: Report bugs or request features</li> </ul>"},{"location":"#citation","title":"Citation","text":"<pre><code>@software{pyfuzzy_toolbox,\n  title = {pyfuzzy-toolbox: A Comprehensive Python Library for Fuzzy Systems},\n  author = {Cecconello, Moiseis},\n  year = {2025},\n  url = {https://github.com/1moi6/pyfuzzy-toolbox}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"api_reference/core/","title":"Core API Reference","text":"<p>The <code>fuzzy_systems.core</code> module provides fundamental components for fuzzy logic:</p> <ul> <li>Membership functions: Define fuzzy set shapes</li> <li>Fuzzy sets: <code>FuzzySet</code> and <code>LinguisticVariable</code> classes</li> <li>Operators: AND, OR, NOT operations</li> <li>Defuzzification: Convert fuzzy to crisp values</li> </ul>"},{"location":"api_reference/core/#membership-functions","title":"Membership Functions","text":""},{"location":"api_reference/core/#triangularx-params","title":"<code>triangular(x, params)</code>","text":"<p>Triangular membership function.</p> <p>Parameters:</p> <ul> <li><code>x</code> (float | ndarray): Input value(s)</li> <li><code>params</code> (tuple): <code>(a, b, c)</code> where:<ul> <li><code>a</code>: Left foot</li> <li><code>b</code>: Peak (\u03bc = 1)</li> <li><code>c</code>: Right foot</li> </ul> </li> </ul> <p>Returns: <code>float | ndarray</code> - Membership degree(s) in [0, 1]</p> <p>Example: <pre><code>import numpy as np\nfrom fuzzy_systems.core import triangular\n\nx = np.linspace(0, 10, 100)\nmu = triangular(x, (2, 5, 8))\n</code></pre></p>"},{"location":"api_reference/core/#trapezoidalx-params","title":"<code>trapezoidal(x, params)</code>","text":"<p>Trapezoidal membership function.</p> <p>Parameters:</p> <ul> <li><code>x</code> (float | ndarray): Input value(s)</li> <li><code>params</code> (tuple): <code>(a, b, c, d)</code> where:<ul> <li><code>a</code>: Left foot</li> <li><code>b</code>: Left shoulder (\u03bc = 1 starts)</li> <li><code>c</code>: Right shoulder (\u03bc = 1 ends)</li> <li><code>d</code>: Right foot</li> </ul> </li> </ul> <p>Returns: <code>float | ndarray</code> - Membership degree(s) in [0, 1]</p> <p>Example: <pre><code>from fuzzy_systems.core import trapezoidal\n\nmu = trapezoidal(x, (1, 3, 7, 9))\n</code></pre></p>"},{"location":"api_reference/core/#gaussianx-params","title":"<code>gaussian(x, params)</code>","text":"<p>Gaussian (bell-shaped) membership function.</p> <p>Parameters:</p> <ul> <li><code>x</code> (float | ndarray): Input value(s)</li> <li><code>params</code> (tuple): <code>(mean, sigma)</code> where:<ul> <li><code>mean</code>: Center of the curve</li> <li><code>sigma</code>: Standard deviation (controls width)</li> </ul> </li> </ul> <p>Returns: <code>float | ndarray</code> - Membership degree(s) in [0, 1]</p> <p>Example: <pre><code>from fuzzy_systems.core import gaussian\n\nmu = gaussian(x, (5, 1.5))\n</code></pre></p>"},{"location":"api_reference/core/#sigmoidx-params","title":"<code>sigmoid(x, params)</code>","text":"<p>Sigmoid membership function.</p> <p>Parameters:</p> <ul> <li><code>x</code> (float | ndarray): Input value(s)</li> <li><code>params</code> (tuple): <code>(a, c)</code> where:<ul> <li><code>a</code>: Slope parameter</li> <li><code>c</code>: Inflection point (where \u03bc = 0.5)</li> </ul> </li> </ul> <p>Returns: <code>float | ndarray</code> - Membership degree(s) in [0, 1]</p> <p>Example: <pre><code>from fuzzy_systems.core import sigmoid\n\nmu = sigmoid(x, (1, 5))\n</code></pre></p>"},{"location":"api_reference/core/#generalized_bellx-params","title":"<code>generalized_bell(x, params)</code>","text":"<p>Generalized bell-shaped membership function.</p> <p>Parameters:</p> <ul> <li><code>x</code> (float | ndarray): Input value(s)</li> <li><code>params</code> (tuple): <code>(a, b, c)</code> where:<ul> <li><code>a</code>: Width parameter</li> <li><code>b</code>: Slope parameter</li> <li><code>c</code>: Center</li> </ul> </li> </ul> <p>Returns: <code>float | ndarray</code> - Membership degree(s) in [0, 1]</p>"},{"location":"api_reference/core/#classes","title":"Classes","text":""},{"location":"api_reference/core/#fuzzyset","title":"<code>FuzzySet</code>","text":"<p>Represents a fuzzy set with its membership function.</p>"},{"location":"api_reference/core/#constructor","title":"Constructor","text":"<pre><code>FuzzySet(name, mf_type, params, mf_func=None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> (str): Name of the fuzzy set (e.g., \"low\", \"medium\", \"high\")</li> <li><code>mf_type</code> (str): Membership function type (<code>\"triangular\"</code>, <code>\"trapezoidal\"</code>, <code>\"gaussian\"</code>, etc.)</li> <li><code>params</code> (tuple): Parameters for the membership function</li> <li><code>mf_func</code> (callable, optional): Custom membership function</li> </ul> <p>Example: <pre><code>from fuzzy_systems.core import FuzzySet\n\nfs = FuzzySet(\n    name=\"warm\",\n    mf_type=\"triangular\",\n    params=(15, 22.5, 30)\n)\n</code></pre></p>"},{"location":"api_reference/core/#methods","title":"Methods","text":""},{"location":"api_reference/core/#membershipx","title":"<code>.membership(x)</code>","text":"<p>Calculate membership degree of value(s) in this fuzzy set.</p> <p>Parameters: - <code>x</code> (float | ndarray): Input value(s)</p> <p>Returns: <code>float | ndarray</code> - Membership degree(s)</p> <p>Example: <pre><code>mu = fs.membership(20)  # Returns: 0.727...\n</code></pre></p>"},{"location":"api_reference/core/#linguisticvariable","title":"<code>LinguisticVariable</code>","text":"<p>Represents a linguistic variable with multiple fuzzy terms.</p>"},{"location":"api_reference/core/#constructor_1","title":"Constructor","text":"<pre><code>LinguisticVariable(name, universe)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> (str): Variable name (e.g., \"temperature\", \"speed\")</li> <li><code>universe</code> (tuple): Range <code>(min, max)</code> of the variable</li> </ul> <p>Example: <pre><code>from fuzzy_systems.core import LinguisticVariable\n\ntemperature = LinguisticVariable(\n    name=\"temperature\",\n    universe=(0, 50)\n)\n</code></pre></p>"},{"location":"api_reference/core/#methods_1","title":"Methods","text":""},{"location":"api_reference/core/#add_termname-mf_type-params-mf_funcnone","title":"<code>.add_term(name, mf_type, params, mf_func=None)</code>","text":"<p>Add a fuzzy term to the variable.</p> <p>Parameters: - <code>name</code> (str): Term name (e.g., \"cold\", \"warm\", \"hot\") - <code>mf_type</code> (str): Membership function type - <code>params</code> (tuple): Function parameters - <code>mf_func</code> (callable, optional): Custom function</p> <p>Example: <pre><code>temperature.add_term(\"cold\", \"trapezoidal\", (0, 0, 10, 20))\ntemperature.add_term(\"warm\", \"triangular\", (15, 25, 35))\ntemperature.add_term(\"hot\", \"trapezoidal\", (30, 40, 50, 50))\n</code></pre></p> <p>Alternative (pass FuzzySet): <pre><code>from fuzzy_systems.core import FuzzySet\n\ncold_set = FuzzySet(\"cold\", \"triangular\", (0, 0, 20))\ntemperature.add_term(cold_set)\n</code></pre></p>"},{"location":"api_reference/core/#fuzzifyvalue","title":"<code>.fuzzify(value)</code>","text":"<p>Convert a crisp value to fuzzy membership degrees.</p> <p>Parameters: - <code>value</code> (float): Crisp input value</p> <p>Returns: <code>dict</code> - Membership degrees for all terms: <code>{term_name: degree}</code></p> <p>Example: <pre><code>degrees = temperature.fuzzify(28)\n# Returns: {'cold': 0.0, 'warm': 0.143, 'hot': 0.333}\n</code></pre></p>"},{"location":"api_reference/core/#plotaxnone-showtrue-figsize10-6-kwargs","title":"<code>.plot(ax=None, show=True, figsize=(10, 6), **kwargs)</code>","text":"<p>Plot all fuzzy terms of the variable.</p> <p>Parameters: - <code>ax</code> (matplotlib.axes.Axes, optional): Axes to plot on - <code>show</code> (bool): Whether to call <code>plt.show()</code> - <code>figsize</code> (tuple): Figure size if creating new figure - <code>**kwargs</code>: Additional matplotlib styling options</p> <p>Returns: <code>tuple</code> - <code>(fig, ax)</code> matplotlib objects</p> <p>Example: <pre><code>temperature.plot()\n</code></pre></p>"},{"location":"api_reference/core/#fuzzy-operators","title":"Fuzzy Operators","text":""},{"location":"api_reference/core/#and-operators-t-norms","title":"AND Operators (T-norms)","text":""},{"location":"api_reference/core/#fuzzy_and_mina-b","title":"<code>fuzzy_and_min(a, b)</code>","text":"<p>Minimum t-norm (standard fuzzy AND).</p> <p>Parameters: - <code>a</code>, <code>b</code> (float | ndarray): Membership degrees</p> <p>Returns: <code>float | ndarray</code> - <code>min(a, b)</code></p> <p>Example: <pre><code>from fuzzy_systems.core import fuzzy_and_min\n\nresult = fuzzy_and_min(0.7, 0.5)  # Returns: 0.5\n</code></pre></p>"},{"location":"api_reference/core/#fuzzy_and_producta-b","title":"<code>fuzzy_and_product(a, b)</code>","text":"<p>Product t-norm.</p> <p>Returns: <code>float | ndarray</code> - <code>a * b</code></p>"},{"location":"api_reference/core/#or-operators-s-norms","title":"OR Operators (S-norms)","text":""},{"location":"api_reference/core/#fuzzy_or_maxa-b","title":"<code>fuzzy_or_max(a, b)</code>","text":"<p>Maximum s-norm (standard fuzzy OR).</p> <p>Parameters: - <code>a</code>, <code>b</code> (float | ndarray): Membership degrees</p> <p>Returns: <code>float | ndarray</code> - <code>max(a, b)</code></p> <p>Example: <pre><code>from fuzzy_systems.core import fuzzy_or_max\n\nresult = fuzzy_or_max(0.7, 0.5)  # Returns: 0.7\n</code></pre></p>"},{"location":"api_reference/core/#fuzzy_or_probabilistica-b","title":"<code>fuzzy_or_probabilistic(a, b)</code>","text":"<p>Probabilistic s-norm.</p> <p>Returns: <code>float | ndarray</code> - <code>a + b - a*b</code></p>"},{"location":"api_reference/core/#not-operators","title":"NOT Operators","text":""},{"location":"api_reference/core/#fuzzy_nota","title":"<code>fuzzy_not(a)</code>","text":"<p>Standard fuzzy negation.</p> <p>Parameters: - <code>a</code> (float | ndarray): Membership degree(s)</p> <p>Returns: <code>float | ndarray</code> - <code>1 - a</code></p> <p>Example: <pre><code>from fuzzy_systems.core import fuzzy_not\n\nresult = fuzzy_not(0.7)  # Returns: 0.3\n</code></pre></p>"},{"location":"api_reference/core/#defuzzification","title":"Defuzzification","text":""},{"location":"api_reference/core/#centroidx-mu","title":"<code>centroid(x, mu)</code>","text":"<p>Centroid (center of gravity) defuzzification method.</p> <p>Parameters: - <code>x</code> (ndarray): Universe of discourse values - <code>mu</code> (ndarray): Aggregated membership degrees</p> <p>Returns: <code>float</code> - Crisp output value</p> <p>Formula: \u222b x\u00b7\u03bc(x)dx / \u222b \u03bc(x)dx</p> <p>Example: <pre><code>from fuzzy_systems.core import centroid\nimport numpy as np\n\nx = np.linspace(0, 100, 500)\nmu = np.maximum(0.5 * triangular(x, (0, 0, 50)),\n                0.8 * triangular(x, (50, 100, 100)))\n\ncrisp_value = centroid(x, mu)\n</code></pre></p>"},{"location":"api_reference/core/#bisectorx-mu","title":"<code>bisector(x, mu)</code>","text":"<p>Bisector defuzzification method (divides area in half).</p> <p>Parameters: - <code>x</code> (ndarray): Universe of discourse values - <code>mu</code> (ndarray): Aggregated membership degrees</p> <p>Returns: <code>float</code> - Crisp output value</p>"},{"location":"api_reference/core/#mean_of_maximumx-mu","title":"<code>mean_of_maximum(x, mu)</code>","text":"<p>Mean of Maximum (MOM) defuzzification method.</p> <p>Parameters: - <code>x</code> (ndarray): Universe of discourse values - <code>mu</code> (ndarray): Aggregated membership degrees</p> <p>Returns: <code>float</code> - Mean of x values where \u03bc is maximum</p>"},{"location":"api_reference/core/#complete-example","title":"Complete Example","text":"<pre><code>import numpy as np\nfrom fuzzy_systems.core import (\n    LinguisticVariable,\n    triangular,\n    fuzzy_and_min,\n    fuzzy_or_max,\n    fuzzy_not\n)\n\n# Create linguistic variable\ntemperature = LinguisticVariable(\"temperature\", (0, 50))\ntemperature.add_term(\"cold\", \"trapezoidal\", (0, 0, 10, 20))\ntemperature.add_term(\"warm\", \"triangular\", (15, 25, 35))\ntemperature.add_term(\"hot\", \"trapezoidal\", (30, 40, 50, 50))\n\n# Fuzzify a value\ncurrent_temp = 28\ndegrees = temperature.fuzzify(current_temp)\nprint(degrees)  # {'cold': 0.0, 'warm': 0.143, 'hot': 0.333}\n\n# Apply fuzzy operations\nmu_warm = degrees['warm']\nmu_hot = degrees['hot']\n\ncomfort = fuzzy_and_min(mu_warm, fuzzy_not(mu_hot))\nprint(f\"Comfort level: {comfort:.3f}\")\n\n# Plot the variable\ntemperature.plot()\n</code></pre>"},{"location":"api_reference/core/#see-also","title":"See Also","text":"<ul> <li>Inference API - Build complete fuzzy inference systems</li> <li>User Guide: Fundamentals - Learn fuzzy logic concepts</li> <li>Examples - Practical examples</li> </ul>"},{"location":"api_reference/dynamics/","title":"Dynamics API Reference","text":"<p>The <code>fuzzy_systems.dynamics</code> module provides tools for dynamic systems with fuzzy uncertainty:</p> <ul> <li>FuzzyODE: Solve ODEs with fuzzy parameters/initial conditions (\u03b1-level method)</li> <li>PFuzzyDiscrete: Discrete dynamical systems with fuzzy rule-based evolution</li> <li>PFuzzyContinuous: Continuous dynamical systems with fuzzy rule-based evolution</li> </ul> <p>Reference: Barros, L. C., Bassanezi, R. C., &amp; Lodwick, W. A. (2017). A First Course in Fuzzy Logic, Fuzzy Dynamical Systems, and Biomathematics.</p>"},{"location":"api_reference/dynamics/#fuzzy-odes","title":"Fuzzy ODEs","text":""},{"location":"api_reference/dynamics/#fuzzynumber","title":"FuzzyNumber","text":"<p>Represent fuzzy numbers for use as initial conditions or parameters.</p>"},{"location":"api_reference/dynamics/#class-methods","title":"Class Methods","text":""},{"location":"api_reference/dynamics/#triangularcenter-spread-namenone","title":"<code>.triangular(center, spread, name=None)</code>","text":"<p>Create a triangular fuzzy number.</p> <p>Parameters: - <code>center</code> (float): Center (peak) of the triangle - <code>spread</code> (float): Half-width at base - <code>name</code> (str, optional): Name of the fuzzy number</p> <p>Returns: <code>FuzzyNumber</code></p> <p>Example: <pre><code>from fuzzy_systems.dynamics import FuzzyNumber\n\n# Triangular: \u03bc(x) peaks at 10, base from 8 to 12\ny0_fuzzy = FuzzyNumber.triangular(center=10, spread=2)\n</code></pre></p>"},{"location":"api_reference/dynamics/#trapezoidala-b-c-d-namenone","title":"<code>.trapezoidal(a, b, c, d, name=None)</code>","text":"<p>Create a trapezoidal fuzzy number.</p> <p>Parameters: - <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> (float): Trapezoidal parameters (a \u2264 b \u2264 c \u2264 d) - <code>name</code> (str, optional): Name of the fuzzy number</p> <p>Returns: <code>FuzzyNumber</code></p>"},{"location":"api_reference/dynamics/#gaussianmean-sigma-namenone","title":"<code>.gaussian(mean, sigma, name=None)</code>","text":"<p>Create a Gaussian fuzzy number.</p> <p>Parameters: - <code>mean</code> (float): Mean (center) - <code>sigma</code> (float): Standard deviation - <code>name</code> (str, optional): Name</p> <p>Returns: <code>FuzzyNumber</code></p>"},{"location":"api_reference/dynamics/#fuzzyodesolver","title":"FuzzyODESolver","text":"<p>Solve ordinary differential equations with fuzzy uncertainty.</p>"},{"location":"api_reference/dynamics/#constructor","title":"Constructor","text":"<pre><code>FuzzyODESolver(ode_func, t_span, y0_fuzzy=None, params=None,\n               alpha_levels=None, method='RK45', **options)\n</code></pre> <p>Parameters:</p> <ul> <li><code>ode_func</code> (callable): ODE function <code>f(t, y, *params) -&gt; dydt</code></li> <li><code>t_span</code> (tuple): Time interval <code>(t0, tf)</code></li> <li><code>y0_fuzzy</code> (list, optional): List of <code>FuzzyNumber</code> objects for initial conditions</li> <li><code>params</code> (dict, optional): Crisp or fuzzy parameters: <code>{name: value_or_FuzzyNumber}</code></li> <li><code>alpha_levels</code> (list, optional): \u03b1-cut levels (default: <code>[0, 0.25, 0.5, 0.75, 1.0]</code>)</li> <li><code>method</code> (str): Integration method: <code>'RK45'</code>, <code>'RK23'</code>, <code>'DOP853'</code>, <code>'Radau'</code>, <code>'BDF'</code>, <code>'LSODA'</code> (default: <code>'RK45'</code>)</li> <li><code>**options</code>: Additional options for <code>scipy.integrate.solve_ivp</code></li> </ul> <p>Example: <pre><code>from fuzzy_systems.dynamics import FuzzyODESolver, FuzzyNumber\nimport numpy as np\n\n# Define ODE: dy/dt = r*y*(1 - y/K)  (Logistic growth)\ndef logistic(t, y, r, K):\n    return r * y[0] * (1 - y[0] / K)\n\n# Fuzzy initial condition\ny0 = FuzzyNumber.triangular(center=10, spread=2)\n\n# Fuzzy parameters\nr_fuzzy = FuzzyNumber.triangular(center=1.0, spread=0.2)\nK_fuzzy = FuzzyNumber.triangular(center=100, spread=10)\n\n# Create solver\nsolver = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 20),\n    y0_fuzzy=[y0],\n    params={'r': r_fuzzy, 'K': K_fuzzy},\n    alpha_levels=[0, 0.5, 1.0]\n)\n</code></pre></p>"},{"location":"api_reference/dynamics/#methods","title":"Methods","text":""},{"location":"api_reference/dynamics/#solven_points100-paralleltrue-n_jobs-1","title":"<code>.solve(n_points=100, parallel=True, n_jobs=-1)</code>","text":"<p>Solve the fuzzy ODE using \u03b1-level method.</p> <p>Parameters: - <code>n_points</code> (int): Number of time points (default: <code>100</code>) - <code>parallel</code> (bool): Use parallel processing (default: <code>True</code>) - <code>n_jobs</code> (int): Number of parallel jobs. <code>-1</code> uses all CPUs (default: <code>-1</code>)</p> <p>Returns: <code>FuzzySolution</code> - Solution object</p> <p>Example: <pre><code>solution = solver.solve(n_points=200, parallel=True)\n</code></pre></p>"},{"location":"api_reference/dynamics/#plot_envelopevariablesnone-alpha_colorsnone-figsize12-6-showtrue","title":"<code>.plot_envelope(variables=None, alpha_colors=None, figsize=(12, 6), show=True)</code>","text":"<p>Plot fuzzy envelope showing uncertainty bands.</p> <p>Parameters: - <code>variables</code> (list, optional): Variable indices to plot. If None, plots all - <code>alpha_colors</code> (dict, optional): Custom colors for \u03b1-levels: <code>{alpha: color}</code> - <code>figsize</code> (tuple): Figure size (default: <code>(12, 6)</code>) - <code>show</code> (bool): Whether to call <code>plt.show()</code> (default: <code>True</code>)</p> <p>Returns: <code>tuple</code> - <code>(fig, axes)</code> matplotlib objects</p> <p>Example: <pre><code>solver.plot_envelope(\n    variables=[0],\n    alpha_colors={0: 'lightblue', 0.5: 'blue', 1.0: 'darkblue'}\n)\n</code></pre></p>"},{"location":"api_reference/dynamics/#fuzzysolution","title":"FuzzySolution","text":"<p>Solution object returned by <code>FuzzyODESolver.solve()</code>.</p>"},{"location":"api_reference/dynamics/#attributes","title":"Attributes","text":"<ul> <li><code>t</code> (ndarray): Time points</li> <li><code>alpha_levels</code> (list): \u03b1-cut levels used</li> <li><code>envelopes</code> (dict): Fuzzy envelopes: <code>{alpha: {'lower': array, 'upper': array}}</code></li> </ul>"},{"location":"api_reference/dynamics/#methods_1","title":"Methods","text":""},{"location":"api_reference/dynamics/#plotvariablesnone-kwargs","title":"<code>.plot(variables=None, **kwargs)</code>","text":"<p>Plot the fuzzy solution.</p> <p>Parameters: - <code>variables</code> (list, optional): Variables to plot - <code>**kwargs</code>: Additional plotting options</p>"},{"location":"api_reference/dynamics/#complete-example-fuzzy-logistic-growth","title":"Complete Example: Fuzzy Logistic Growth","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems.dynamics import FuzzyODESolver, FuzzyNumber\n\n# Define ODE: dy/dt = r*y*(1 - y/K)\ndef logistic(t, y, r, K):\n    \"\"\"Logistic growth model.\"\"\"\n    return r * y[0] * (1 - y[0] / K)\n\n# Fuzzy initial condition: population around 10 \u00b1 2\ny0 = FuzzyNumber.triangular(center=10, spread=2)\n\n# Fuzzy parameters\nr = FuzzyNumber.triangular(center=0.5, spread=0.1)  # Growth rate\nK = FuzzyNumber.triangular(center=100, spread=10)   # Carrying capacity\n\n# Solve fuzzy ODE\nsolver = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 30),\n    y0_fuzzy=[y0],\n    params={'r': r, 'K': K},\n    alpha_levels=[0, 0.25, 0.5, 0.75, 1.0],\n    method='RK45'\n)\n\nsolution = solver.solve(n_points=200)\n\n# Plot\nsolver.plot_envelope(\n    variables=[0],\n    figsize=(12, 6),\n    alpha_colors={\n        0: 'lightblue',\n        0.5: 'blue',\n        1.0: 'darkblue'\n    }\n)\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.title('Fuzzy Logistic Growth with Uncertain Parameters')\nplt.show()\n</code></pre>"},{"location":"api_reference/dynamics/#complete-example-fuzzy-holling-tanner-predator-prey","title":"Complete Example: Fuzzy Holling-Tanner (Predator-Prey)","text":"<pre><code>from fuzzy_systems.dynamics import FuzzyODESolver, FuzzyNumber\n\n# Holling-Tanner predator-prey model\ndef holling_tanner(t, y, r, K, a, b, c, d):\n    \"\"\"\n    Predator-prey with Holling Type II functional response.\n\n    y[0] = prey (x)\n    y[1] = predator (z)\n    \"\"\"\n    x, z = y\n    dx = r * x * (1 - x/K) - (a*x*z)/(b + x)\n    dz = c * z * (1 - d*z/x) if x &gt; 0 else 0\n    return [dx, dz]\n\n# Initial conditions (fuzzy)\nx0 = FuzzyNumber.triangular(center=40, spread=5)\nz0 = FuzzyNumber.triangular(center=15, spread=3)\n\n# Parameters (some fuzzy, some crisp)\nparams = {\n    'r': FuzzyNumber.triangular(1.0, 0.1),  # Fuzzy\n    'K': 100,                                # Crisp\n    'a': 1.0,\n    'b': 10,\n    'c': 0.5,\n    'd': 0.1\n}\n\n# Solve\nsolver = FuzzyODESolver(\n    ode_func=holling_tanner,\n    t_span=(0, 100),\n    y0_fuzzy=[x0, z0],\n    params=params,\n    alpha_levels=[0, 0.5, 1.0]\n)\n\nsolution = solver.solve()\n\n# Plot both variables\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\nsolver.plot_envelope(variables=[0], show=False)\nax1.set_title('Prey Population (x)')\nax1.set_xlabel('Time')\nax1.set_ylabel('Population')\n\nsolver.plot_envelope(variables=[1], show=False)\nax2.set_title('Predator Population (z)')\nax2.set_xlabel('Time')\nax2.set_ylabel('Population')\n\nplt.tight_layout()\nplt.show()\n\n# Phase space plot\n# (Would need to extract and plot lower/upper bounds in x-z plane)\n</code></pre>"},{"location":"api_reference/dynamics/#p-fuzzy-systems","title":"p-Fuzzy Systems","text":"<p>Systems where evolution is defined by fuzzy rules instead of equations.</p>"},{"location":"api_reference/dynamics/#pfuzzydiscrete","title":"PFuzzyDiscrete","text":"<p>Discrete dynamical system with fuzzy rule-based evolution.</p> <p>Discrete evolution: - Absolute mode: x_{n+1} = x_n + f(x_n) - Relative mode: x_{n+1} = x_n * (1 + f(x_n))</p>"},{"location":"api_reference/dynamics/#constructor_1","title":"Constructor","text":"<pre><code>PFuzzyDiscrete(fis, mode='absolute', state_vars=None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>fis</code> (MamdaniSystem | SugenoSystem): Fuzzy inference system</li> <li><code>mode</code> (str): Evolution mode: <code>'absolute'</code> or <code>'relative'</code> (default: <code>'absolute'</code>)</li> <li><code>state_vars</code> (list, optional): State variable names. If None, uses all FIS inputs</li> </ul> <p>Example: <pre><code>from fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.dynamics import PFuzzyDiscrete\n\n# Create FIS with rules\nfis = MamdaniSystem()\nfis.add_input('prey', (0, 100))\nfis.add_input('predator', (0, 100))\nfis.add_output('var_prey', (-5, 5))\nfis.add_output('var_predator', (-5, 5))\n\n# Add terms and rules...\n# (See examples below)\n\n# Create p-fuzzy system\npfuzzy = PFuzzyDiscrete(\n    fis=fis,\n    mode='absolute',\n    state_vars=['prey', 'predator']\n)\n</code></pre></p>"},{"location":"api_reference/dynamics/#methods_2","title":"Methods","text":""},{"location":"api_reference/dynamics/#simulatex0-n_steps-return_timetrue","title":"<code>.simulate(x0, n_steps, return_time=True)</code>","text":"<p>Simulate the discrete system.</p> <p>Parameters: - <code>x0</code> (dict | ndarray): Initial conditions: <code>{var_name: value}</code> or array - <code>n_steps</code> (int): Number of time steps - <code>return_time</code> (bool): If True, returns <code>(time, trajectory)</code>. Otherwise, only <code>trajectory</code> (default: <code>True</code>)</p> <p>Returns: <code>tuple | ndarray</code> - Time array and trajectory matrix, or just trajectory</p> <p>Example: <pre><code># Using dictionary\ntime, trajectory = pfuzzy.simulate(\n    x0={'prey': 50, 'predator': 40},\n    n_steps=200\n)\n\n# Using array (order matches state_vars)\ntime, trajectory = pfuzzy.simulate(\n    x0=[50, 40],\n    n_steps=200\n)\n</code></pre></p>"},{"location":"api_reference/dynamics/#plot_trajectoryvariablesnone-figsize12-6-showtrue","title":"<code>.plot_trajectory(variables=None, figsize=(12, 6), show=True)</code>","text":"<p>Plot time evolution of state variables.</p> <p>Parameters: - <code>variables</code> (list, optional): Variable names to plot. If None, plots all - <code>figsize</code> (tuple): Figure size - <code>show</code> (bool): Whether to call <code>plt.show()</code></p> <p>Returns: <code>tuple</code> - <code>(fig, ax)</code></p> <p>Example: <pre><code>pfuzzy.plot_trajectory(variables=['prey', 'predator'])\n</code></pre></p>"},{"location":"api_reference/dynamics/#plot_phase_spacevar_x-var_y-figsize8-8-showtrue","title":"<code>.plot_phase_space(var_x, var_y, figsize=(8, 8), show=True)</code>","text":"<p>Plot phase space (2D trajectory).</p> <p>Parameters: - <code>var_x</code> (str): Variable for x-axis - <code>var_y</code> (str): Variable for y-axis - <code>figsize</code> (tuple): Figure size - <code>show</code> (bool): Whether to call <code>plt.show()</code></p> <p>Returns: <code>tuple</code> - <code>(fig, ax)</code></p> <p>Example: <pre><code>pfuzzy.plot_phase_space('prey', 'predator')\n</code></pre></p>"},{"location":"api_reference/dynamics/#to_csvfilename-include_timetrue","title":"<code>.to_csv(filename, include_time=True)</code>","text":"<p>Export trajectory to CSV file.</p> <p>Parameters: - <code>filename</code> (str): Output file path - <code>include_time</code> (bool): Include time column (default: <code>True</code>)</p> <p>Example: <pre><code>pfuzzy.to_csv('trajectory.csv')\n</code></pre></p>"},{"location":"api_reference/dynamics/#pfuzzycontinuous","title":"PFuzzyContinuous","text":"<p>Continuous dynamical system with fuzzy rule-based evolution.</p> <p>Continuous evolution: - Absolute mode: dx/dt = f(x) - Relative mode: dx/dt = x * f(x)</p>"},{"location":"api_reference/dynamics/#constructor_2","title":"Constructor","text":"<pre><code>PFuzzyContinuous(fis, mode='absolute', state_vars=None)\n</code></pre> <p>Parameters: Same as <code>PFuzzyDiscrete</code></p>"},{"location":"api_reference/dynamics/#methods_3","title":"Methods","text":""},{"location":"api_reference/dynamics/#simulatex0-t_span-dt01-methodrk4-return_timetrue","title":"<code>.simulate(x0, t_span, dt=0.1, method='RK4', return_time=True)</code>","text":"<p>Simulate the continuous system.</p> <p>Parameters: - <code>x0</code> (dict | ndarray): Initial conditions - <code>t_span</code> (tuple): Time interval <code>(t0, tf)</code> - <code>dt</code> (float): Time step for integration (default: <code>0.1</code>) - <code>method</code> (str): Integration method: <code>'Euler'</code>, <code>'RK4'</code> (default: <code>'RK4'</code>) - <code>return_time</code> (bool): Return time array (default: <code>True</code>)</p> <p>Returns: <code>tuple | ndarray</code> - <code>(time, trajectory)</code> or just <code>trajectory</code></p> <p>Example: <pre><code>time, trajectory = pfuzzy.simulate(\n    x0={'prey': 50, 'predator': 40},\n    t_span=(0, 100),\n    dt=0.05,\n    method='RK4'\n)\n</code></pre></p> <p>Other methods (<code>.plot_trajectory()</code>, <code>.plot_phase_space()</code>, <code>.to_csv()</code>) are identical to <code>PFuzzyDiscrete</code>.</p>"},{"location":"api_reference/dynamics/#complete-example-discrete-predator-prey","title":"Complete Example: Discrete Predator-Prey","text":"<pre><code>from fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.dynamics import PFuzzyDiscrete\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create FIS\nfis = MamdaniSystem(name=\"Predator-Prey Discrete\")\n\n# Define variables\nfis.add_input('prey', (0, 100))\nfis.add_input('predator', (0, 100))\nfis.add_output('var_prey', (-2, 2))\nfis.add_output('var_predator', (-2, 2))\n\n# Add 4 linguistic terms per variable (Low, Medium-Low, Medium-High, High)\nfor var in ['prey', 'predator']:\n    fis.add_term(var, 'B', 'gaussian', (0, 12))         # Low\n    fis.add_term(var, 'MB', 'gaussian', (33, 12))       # Medium-Low\n    fis.add_term(var, 'MA', 'gaussian', (67, 12))       # Medium-High\n    fis.add_term(var, 'A', 'gaussian', (100, 12))       # High\n\n# Add output terms (8 per variable: 4 positive, 4 negative)\nlrg = 0.5\nfor out_var in ['var_prey', 'var_predator']:\n    # Negative variations\n    fis.add_term(out_var, 'A_n', 'trapezoidal', (-4*lrg, -4*lrg, -3*lrg, -2*lrg))\n    fis.add_term(out_var, 'MA_n', 'triangular', (-3*lrg, -2*lrg, -lrg))\n    fis.add_term(out_var, 'MB_n', 'triangular', (-2*lrg, -lrg, 0))\n    fis.add_term(out_var, 'B_n', 'triangular', (-lrg, 0, 0))\n    # Positive variations\n    fis.add_term(out_var, 'B_p', 'triangular', (0, 0, lrg))\n    fis.add_term(out_var, 'MB_p', 'triangular', (0, lrg, 2*lrg))\n    fis.add_term(out_var, 'MA_p', 'triangular', (lrg, 2*lrg, 3*lrg))\n    fis.add_term(out_var, 'A_p', 'trapezoidal', (2*lrg, 3*lrg, 4*lrg, 4*lrg))\n\n# Define 16 rules (4x4 matrix)\nrules = [\n    # Prey=B (Low)\n    ('B', 'B', 'MB_p', 'MB_n'),   # Few prey, few predators \u2192 prey increase\n    ('B', 'MB', 'B_p', 'MB_n'),\n    ('B', 'MA', 'B_n', 'MA_n'),\n    ('B', 'A', 'MB_n', 'A_n'),\n\n    # Prey=MB (Medium-Low)\n    ('MB', 'B', 'MA_p', 'B_n'),\n    ('MB', 'MB', 'MB_p', 'B_n'),\n    ('MB', 'MA', 'B_n', 'MB_n'),\n    ('MB', 'A', 'MB_n', 'MA_n'),\n\n    # Prey=MA (Medium-High)\n    ('MA', 'B', 'MB_p', 'MA_p'),\n    ('MA', 'MB', 'B_p', 'MB_p'),\n    ('MA', 'MA', 'MB_n', 'B_p'),\n    ('MA', 'A', 'MA_n', 'B_p'),\n\n    # Prey=A (High)\n    ('A', 'B', 'B_n', 'A_p'),\n    ('A', 'MB', 'MB_n', 'MA_p'),\n    ('A', 'MA', 'MA_n', 'MB_p'),\n    ('A', 'A', 'A_n', 'B_p')\n]\n\nfis.add_rules(rules)\n\n# Create p-fuzzy system\npfuzzy = PFuzzyDiscrete(\n    fis=fis,\n    mode='absolute',\n    state_vars=['prey', 'predator']\n)\n\n# Simulate\ntime, trajectory = pfuzzy.simulate(\n    x0={'prey': 50, 'predator': 40},\n    n_steps=250\n)\n\n# Plot results\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\n# Time series\npfuzzy.plot_trajectory(show=False)\nax1 = plt.gca()\nax1.set_title('Population Dynamics')\n\n# Phase space\npfuzzy.plot_phase_space('prey', 'predator', show=False)\nax2 = plt.gca()\nax2.set_title('Phase Space')\n\nplt.tight_layout()\nplt.show()\n\n# Export\npfuzzy.to_csv('predator_prey_discrete.csv')\n</code></pre>"},{"location":"api_reference/dynamics/#complete-example-continuous-population-growth","title":"Complete Example: Continuous Population Growth","text":"<pre><code>from fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.dynamics import PFuzzyContinuous\n\n# Create FIS for continuous population growth\nfis = MamdaniSystem()\n\n# Single variable: population\nfis.add_input('population', (0, 150))\nfis.add_output('growth_rate', (-5, 5))\n\n# Terms: Low, Medium, High population\nfis.add_term('population', 'low', 'triangular', (0, 0, 50))\nfis.add_term('population', 'medium', 'triangular', (25, 75, 125))\nfis.add_term('population', 'high', 'triangular', (100, 150, 150))\n\n# Growth rates: negative, zero, positive\nfis.add_term('growth_rate', 'negative', 'triangular', (-5, -2.5, 0))\nfis.add_term('growth_rate', 'zero', 'triangular', (-1, 0, 1))\nfis.add_term('growth_rate', 'positive', 'triangular', (0, 2.5, 5))\n\n# Rules (logistic-like behavior)\nfis.add_rules([\n    ('low', 'positive'),      # Low population \u2192 growth\n    ('medium', 'zero'),       # Medium population \u2192 equilibrium\n    ('high', 'negative')      # High population \u2192 decline\n])\n\n# Create continuous p-fuzzy system\npfuzzy = PFuzzyContinuous(\n    fis=fis,\n    mode='absolute',\n    state_vars=['population']\n)\n\n# Simulate\ntime, trajectory = pfuzzy.simulate(\n    x0={'population': 10},\n    t_span=(0, 50),\n    dt=0.1,\n    method='RK4'\n)\n\n# Plot\npfuzzy.plot_trajectory()\nplt.axhline(y=75, color='r', linestyle='--', label='Equilibrium (~75)')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"api_reference/dynamics/#comparison-fuzzy-ode-vs-p-fuzzy","title":"Comparison: Fuzzy ODE vs p-Fuzzy","text":"Feature Fuzzy ODE p-Fuzzy Evolution Mathematical equation: dy/dt = f(t, y) Fuzzy rules: IF...THEN Uncertainty Parameters &amp; initial conditions Rule-based behavior Method \u03b1-level cuts + ODE solver Direct FIS evaluation Output Fuzzy envelope (bands) Deterministic trajectory Best for Models with known equations but uncertain params Models defined by expert rules Interpretability Medium (equation-based) High (linguistic rules)"},{"location":"api_reference/dynamics/#see-also","title":"See Also","text":"<ul> <li>Core API - Fuzzy sets and membership functions</li> <li>Inference API - Build fuzzy systems for p-fuzzy</li> <li>Learning API - Learn fuzzy rules from data</li> <li>User Guide: Dynamics - Detailed tutorials</li> <li>Examples - Interactive notebooks</li> </ul>"},{"location":"api_reference/inference/","title":"Inference API Reference","text":"<p>The <code>fuzzy_systems.inference</code> module provides complete fuzzy inference systems:</p> <ul> <li>MamdaniSystem: Classic fuzzy inference with linguistic outputs</li> <li>SugenoSystem: TSK systems with functional outputs (order 0 and 1)</li> </ul>"},{"location":"api_reference/inference/#mamdanisystem","title":"MamdaniSystem","text":"<p>Classic Mamdani fuzzy inference system with linguistic rule base.</p>"},{"location":"api_reference/inference/#constructor","title":"Constructor","text":"<pre><code>MamdaniSystem(name=\"Mamdani FIS\", t_norm='min', s_norm='max',\n              implication='min', aggregation='max', defuzz_method='centroid')\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> (str): System name (default: <code>\"Mamdani FIS\"</code>)</li> <li><code>t_norm</code> (str): T-norm for AND operation: <code>'min'</code>, <code>'product'</code>, etc. (default: <code>'min'</code>)</li> <li><code>s_norm</code> (str): S-norm for OR operation: <code>'max'</code>, <code>'probabilistic'</code>, etc. (default: <code>'max'</code>)</li> <li><code>implication</code> (str): Implication method: <code>'min'</code> (Mamdani), <code>'product'</code> (Larsen) (default: <code>'min'</code>)</li> <li><code>aggregation</code> (str): Aggregation method: <code>'max'</code>, <code>'sum'</code>, <code>'probabilistic'</code> (default: <code>'max'</code>)</li> <li><code>defuzz_method</code> (str): Defuzzification: <code>'centroid'</code>, <code>'bisector'</code>, <code>'mom'</code>, <code>'som'</code>, <code>'lom'</code> (default: <code>'centroid'</code>)</li> </ul> <p>Example: <pre><code>from fuzzy_systems import MamdaniSystem\n\nsystem = MamdaniSystem(name=\"Temperature Control\")\n</code></pre></p>"},{"location":"api_reference/inference/#methods","title":"Methods","text":""},{"location":"api_reference/inference/#add_inputname-universe","title":"<code>.add_input(name, universe)</code>","text":"<p>Add an input variable to the system.</p> <p>Parameters: - <code>name</code> (str): Variable name (e.g., <code>\"temperature\"</code>) - <code>universe</code> (tuple): Range <code>(min, max)</code> of the variable</p> <p>Returns: <code>LinguisticVariable</code> - The created variable</p> <p>Example: <pre><code>system.add_input('temperature', (0, 40))\nsystem.add_input('humidity', (0, 100))\n</code></pre></p> <p>Alternative (pass LinguisticVariable): <pre><code>from fuzzy_systems.core import LinguisticVariable\n\ntemp_var = LinguisticVariable('temperature', (0, 40))\nsystem.add_input(temp_var)\n</code></pre></p>"},{"location":"api_reference/inference/#add_outputname-universe","title":"<code>.add_output(name, universe)</code>","text":"<p>Add an output variable to the system.</p> <p>Parameters: - <code>name</code> (str): Variable name (e.g., <code>\"fan_speed\"</code>) - <code>universe</code> (tuple): Range <code>(min, max)</code> of the variable</p> <p>Returns: <code>LinguisticVariable</code> - The created variable</p> <p>Example: <pre><code>system.add_output('fan_speed', (0, 100))\n</code></pre></p>"},{"location":"api_reference/inference/#add_termvariable_name-term_name-mf_type-params-mf_funcnone","title":"<code>.add_term(variable_name, term_name, mf_type, params, mf_func=None)</code>","text":"<p>Add a fuzzy term to an input or output variable.</p> <p>Parameters: - <code>variable_name</code> (str): Name of the variable (input or output) - <code>term_name</code> (str): Name of the term (e.g., <code>\"cold\"</code>, <code>\"hot\"</code>) - <code>mf_type</code> (str): Membership function type: <code>'triangular'</code>, <code>'trapezoidal'</code>, <code>'gaussian'</code>, etc. - <code>params</code> (tuple): Parameters for the membership function - <code>mf_func</code> (callable, optional): Custom membership function</p> <p>Example: <pre><code># Add terms to input\nsystem.add_term('temperature', 'cold', 'triangular', (0, 0, 20))\nsystem.add_term('temperature', 'warm', 'triangular', (10, 20, 30))\nsystem.add_term('temperature', 'hot', 'triangular', (20, 40, 40))\n\n# Add terms to output\nsystem.add_term('fan_speed', 'slow', 'triangular', (0, 0, 50))\nsystem.add_term('fan_speed', 'fast', 'triangular', (50, 100, 100))\n</code></pre></p>"},{"location":"api_reference/inference/#add_rulerule_dict-operatorand-weight10","title":"<code>.add_rule(rule_dict, operator='AND', weight=1.0)</code>","text":"<p>Add a single fuzzy rule to the system.</p> <p>Parameters: - <code>rule_dict</code> (dict | list | tuple): Rule specification - <code>operator</code> (str): <code>'AND'</code> or <code>'OR'</code> (default: <code>'AND'</code>) - <code>weight</code> (float): Rule weight in [0, 1] (default: <code>1.0</code>)</p> <p>Rule Formats:</p> <p>Format 1 - Dictionary (Recommended): <pre><code>system.add_rule({\n    'temperature': 'cold',\n    'humidity': 'high',\n    'fan_speed': 'slow'\n})\n\n# With operator and weight\nsystem.add_rule({\n    'temperature': 'hot',\n    'humidity': 'low',\n    'fan_speed': 'fast',\n    'operator': 'OR',\n    'weight': 0.9\n})\n</code></pre></p> <p>Format 2 - Tuple (Compact): <pre><code># (input1_term, input2_term, ..., output1_term, ...)\nsystem.add_rule(('cold', 'high', 'slow'))\nsystem.add_rule(('hot', 'low', 'fast'))\n</code></pre></p> <p>Format 3 - Tuple with indices: <pre><code># Use term indices instead of names\nsystem.add_rule((0, 2, 0))  # First term of each variable\n</code></pre></p>"},{"location":"api_reference/inference/#add_rulesrules_list-operatorand-weight10","title":"<code>.add_rules(rules_list, operator='AND', weight=1.0)</code>","text":"<p>Add multiple rules at once.</p> <p>Parameters: - <code>rules_list</code> (list): List of rules in any supported format - <code>operator</code> (str): Default operator for all rules - <code>weight</code> (float): Default weight for all rules</p> <p>Example: <pre><code># Using tuples (simple)\nsystem.add_rules([\n    ('cold', 'slow'),\n    ('warm', 'medium'),\n    ('hot', 'fast')\n])\n\n# Using dictionaries (explicit)\nsystem.add_rules([\n    {'temperature': 'cold', 'fan_speed': 'slow'},\n    {'temperature': 'hot', 'fan_speed': 'fast', 'operator': 'OR'}\n])\n\n# Mixed formats\nsystem.add_rules([\n    ('cold', 'slow'),\n    {'temperature': 'hot', 'fan_speed': 'fast', 'weight': 0.8}\n])\n</code></pre></p>"},{"location":"api_reference/inference/#evaluateinputs-kwargs","title":"<code>.evaluate(inputs, **kwargs)</code>","text":"<p>Evaluate the fuzzy system for given inputs.</p> <p>Parameters: - <code>inputs</code> (dict | list | tuple | scalar): Input values in various formats - <code>**kwargs</code>: Alternative way to pass inputs as keyword arguments</p> <p>Returns: <code>dict</code> - Output values: <code>{output_name: crisp_value}</code></p> <p>Input Formats:</p> <p>Format 1 - Dictionary: <pre><code>result = system.evaluate({'temperature': 25, 'humidity': 60})\n</code></pre></p> <p>Format 2 - Keyword arguments: <pre><code>result = system.evaluate(temperature=25, humidity=60)\n</code></pre></p> <p>Format 3 - List/tuple (order matches variable addition order): <pre><code>result = system.evaluate([25, 60])\n</code></pre></p> <p>Format 4 - Scalar (for single input): <pre><code>result = system.evaluate(25)\n</code></pre></p> <p>Example: <pre><code># Evaluate\nresult = system.evaluate(temperature=25)\nprint(f\"Fan speed: {result['fan_speed']:.1f}%\")\n# Output: Fan speed: 62.5%\n</code></pre></p>"},{"location":"api_reference/inference/#evaluate_detailedinputs-kwargs","title":"<code>.evaluate_detailed(inputs, **kwargs)</code>","text":"<p>Evaluate with detailed intermediate results.</p> <p>Parameters: - <code>inputs</code> (dict | list | tuple | scalar): Input values</p> <p>Returns: <code>dict</code> - Detailed results: <pre><code>{\n    'inputs': {...},           # Fuzzified inputs\n    'rule_activations': [...], # Activation level of each rule\n    'aggregated': {...},       # Aggregated output MFs\n    'outputs': {...}           # Final crisp outputs\n}\n</code></pre></p> <p>Example: <pre><code>details = system.evaluate_detailed(temperature=25)\n\nprint(\"Input fuzzification:\")\nprint(details['inputs'])\n# {'temperature': {'cold': 0.25, 'warm': 0.5, 'hot': 0.25}}\n\nprint(\"\\nRule activations:\")\nfor i, activation in enumerate(details['rule_activations']):\n    print(f\"  Rule {i+1}: {activation:.3f}\")\n\nprint(\"\\nFinal output:\")\nprint(details['outputs'])\n# {'fan_speed': 62.5}\n</code></pre></p>"},{"location":"api_reference/inference/#plot_variablesvar_namesnone-figsize12-8-showtrue","title":"<code>.plot_variables(var_names=None, figsize=(12, 8), show=True)</code>","text":"<p>Plot membership functions of variables.</p> <p>Parameters: - <code>var_names</code> (list, optional): List of variable names to plot. If None, plots all. - <code>figsize</code> (tuple): Figure size (default: <code>(12, 8)</code>) - <code>show</code> (bool): Whether to call <code>plt.show()</code> (default: <code>True</code>)</p> <p>Returns: <code>tuple</code> - <code>(fig, axes)</code> matplotlib objects</p> <p>Example: <pre><code># Plot all variables\nsystem.plot_variables()\n\n# Plot specific variables\nsystem.plot_variables(['temperature', 'fan_speed'])\n\n# Get figure for customization\nfig, axes = system.plot_variables(show=False)\naxes[0].set_title(\"My Custom Title\")\nfig.savefig('variables.png')\n</code></pre></p>"},{"location":"api_reference/inference/#plot_rule_matrixfigsize10-8-cmaprdylgn-showtrue","title":"<code>.plot_rule_matrix(figsize=(10, 8), cmap='RdYlGn', show=True)</code>","text":"<p>Plot rule matrix as a heatmap (for 2-input systems).</p> <p>Parameters: - <code>figsize</code> (tuple): Figure size (default: <code>(10, 8)</code>) - <code>cmap</code> (str): Colormap name (default: <code>'RdYlGn'</code>) - <code>show</code> (bool): Whether to call <code>plt.show()</code> (default: <code>True</code>)</p> <p>Returns: <code>tuple</code> - <code>(fig, ax)</code> matplotlib objects</p> <p>Example: <pre><code>system.plot_rule_matrix()\n</code></pre></p>"},{"location":"api_reference/inference/#export_rulesfilename-formattxt","title":"<code>.export_rules(filename, format='txt')</code>","text":"<p>Export rules to a file.</p> <p>Parameters: - <code>filename</code> (str): Output file path - <code>format</code> (str): Format: <code>'txt'</code>, <code>'json'</code>, <code>'csv'</code> (default: <code>'txt'</code>)</p> <p>Example: <pre><code>system.export_rules('rules.txt', format='txt')\nsystem.export_rules('rules.json', format='json')\nsystem.export_rules('rules.csv', format='csv')\n</code></pre></p>"},{"location":"api_reference/inference/#import_rulesfilename-formattxt","title":"<code>.import_rules(filename, format='txt')</code>","text":"<p>Import rules from a file.</p> <p>Parameters: - <code>filename</code> (str): Input file path - <code>format</code> (str): Format: <code>'txt'</code>, <code>'json'</code>, <code>'csv'</code> (default: <code>'txt'</code>)</p> <p>Example: <pre><code>system.import_rules('rules.json', format='json')\n</code></pre></p>"},{"location":"api_reference/inference/#savefilename","title":"<code>.save(filename)</code>","text":"<p>Save complete system (variables + rules) to a file.</p> <p>Parameters: - <code>filename</code> (str): Output file path (typically <code>.pkl</code> or <code>.json</code>)</p> <p>Example: <pre><code>system.save('my_system.pkl')\n</code></pre></p>"},{"location":"api_reference/inference/#loadfilename","title":"<code>.load(filename)</code>","text":"<p>Load complete system from a file (class method).</p> <p>Parameters: - <code>filename</code> (str): Input file path</p> <p>Returns: <code>MamdaniSystem</code> - Loaded system</p> <p>Example: <pre><code>system = MamdaniSystem.load('my_system.pkl')\n</code></pre></p>"},{"location":"api_reference/inference/#sugenosystem","title":"SugenoSystem","text":"<p>Sugeno (TSK) fuzzy inference system with functional outputs.</p>"},{"location":"api_reference/inference/#constructor_1","title":"Constructor","text":"<pre><code>SugenoSystem(name=\"Sugeno FIS\", t_norm='min', s_norm='max')\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> (str): System name (default: <code>\"Sugeno FIS\"</code>)</li> <li><code>t_norm</code> (str): T-norm for AND operation (default: <code>'min'</code>)</li> <li><code>s_norm</code> (str): S-norm for OR operation (default: <code>'max'</code>)</li> </ul> <p>Example: <pre><code>from fuzzy_systems import SugenoSystem\n\nsystem = SugenoSystem(name=\"Nonlinear Model\")\n</code></pre></p>"},{"location":"api_reference/inference/#methods_1","title":"Methods","text":"<p>Most methods are identical to <code>MamdaniSystem</code>: <code>.add_input()</code>, <code>.add_term()</code>, <code>.evaluate()</code>, etc.</p>"},{"location":"api_reference/inference/#key-differences","title":"Key Differences","text":""},{"location":"api_reference/inference/#add_outputname-order0","title":"<code>.add_output(name, order=0)</code>","text":"<p>Add output variable with functional definition.</p> <p>Parameters: - <code>name</code> (str): Variable name - <code>order</code> (int): Output order:     - <code>0</code>: Constant output (zero-order Sugeno)     - <code>1</code>: Linear function (first-order Sugeno)</p> <p>Example: <pre><code># Zero-order (constants)\nsystem.add_output('y', order=0)\n\n# First-order (linear functions)\nsystem.add_output('y', order=1)\n</code></pre></p>"},{"location":"api_reference/inference/#add_rule-with-functional-outputs","title":"<code>.add_rule()</code> with functional outputs","text":"<p>For Sugeno systems, consequents are numbers (order 0) or coefficient lists (order 1).</p> <p>Order 0 - Constant outputs: <pre><code>system.add_rules([\n    ('low', 2.0),   # IF x is low THEN y = 2.0\n    ('high', 8.0)   # IF x is high THEN y = 8.0\n])\n</code></pre></p> <p>Order 1 - Linear outputs: <pre><code># For y = a*x + b, provide (a, b)\nsystem.add_rules([\n    ('low', 2.0, 1.0),    # IF x is low THEN y = 2.0*x + 1.0\n    ('high', 0.5, 3.0)    # IF x is high THEN y = 0.5*x + 3.0\n])\n</code></pre></p> <p>Multiple inputs (order 1): <pre><code># For y = a*x1 + b*x2 + c, provide (a, b, c)\nsystem.add_rules([\n    ('low', 'low', 1.0, 0.5, 2.0),    # y = 1.0*x1 + 0.5*x2 + 2.0\n    ('high', 'high', 2.0, 1.0, 0.0)   # y = 2.0*x1 + 1.0*x2 + 0.0\n])\n</code></pre></p>"},{"location":"api_reference/inference/#complete-examples","title":"Complete Examples","text":""},{"location":"api_reference/inference/#example-1-mamdani-tipping-system","title":"Example 1: Mamdani Tipping System","text":"<pre><code>from fuzzy_systems import MamdaniSystem\n\n# Create system\nsystem = MamdaniSystem(name=\"Tipping System\")\n\n# Add inputs\nsystem.add_input('service', (0, 10))\nsystem.add_input('food', (0, 10))\n\n# Add output\nsystem.add_output('tip', (0, 25))\n\n# Add terms to inputs\nsystem.add_term('service', 'poor', 'triangular', (0, 0, 5))\nsystem.add_term('service', 'good', 'triangular', (0, 5, 10))\nsystem.add_term('service', 'excellent', 'triangular', (5, 10, 10))\n\nsystem.add_term('food', 'poor', 'triangular', (0, 0, 5))\nsystem.add_term('food', 'good', 'triangular', (0, 5, 10))\nsystem.add_term('food', 'delicious', 'triangular', (5, 10, 10))\n\n# Add terms to output\nsystem.add_term('tip', 'low', 'triangular', (0, 0, 13))\nsystem.add_term('tip', 'medium', 'triangular', (0, 13, 25))\nsystem.add_term('tip', 'high', 'triangular', (13, 25, 25))\n\n# Add rules\nsystem.add_rules([\n    {'service': 'poor', 'food': 'poor', 'tip': 'low'},\n    {'service': 'good', 'food': 'good', 'tip': 'medium'},\n    {'service': 'excellent', 'food': 'delicious', 'tip': 'high'},\n])\n\n# Evaluate\nresult = system.evaluate(service=7, food=8)\nprint(f\"Tip: {result['tip']:.1f}%\")\n\n# Visualize\nsystem.plot_variables()\nsystem.plot_rule_matrix()\n</code></pre>"},{"location":"api_reference/inference/#example-2-sugeno-zero-order","title":"Example 2: Sugeno Zero-Order","text":"<pre><code>from fuzzy_systems import SugenoSystem\n\n# Create system\nsystem = SugenoSystem()\n\n# Add input\nsystem.add_input('x', (0, 10))\nsystem.add_term('x', 'low', 'triangular', (0, 0, 5))\nsystem.add_term('x', 'medium', 'triangular', (0, 5, 10))\nsystem.add_term('x', 'high', 'triangular', (5, 10, 10))\n\n# Add output (order 0 = constant)\nsystem.add_output('y', order=0)\n\n# Add rules with constant outputs\nsystem.add_rules([\n    ('low', 2.0),      # IF x is low THEN y = 2.0\n    ('medium', 5.0),   # IF x is medium THEN y = 5.0\n    ('high', 8.0)      # IF x is high THEN y = 8.0\n])\n\n# Evaluate\nresult = system.evaluate(x=6)\nprint(f\"y = {result['y']:.2f}\")\n</code></pre>"},{"location":"api_reference/inference/#example-3-sugeno-first-order","title":"Example 3: Sugeno First-Order","text":"<pre><code>from fuzzy_systems import SugenoSystem\n\n# Create system\nsystem = SugenoSystem()\n\n# Add input\nsystem.add_input('x', (0, 10))\nsystem.add_term('x', 'low', 'triangular', (0, 0, 5))\nsystem.add_term('x', 'high', 'triangular', (5, 10, 10))\n\n# Add output (order 1 = linear function)\nsystem.add_output('y', order=1)\n\n# Add rules with linear functions: y = a*x + b\nsystem.add_rules([\n    ('low', 2.0, 1.0),    # IF x is low THEN y = 2.0*x + 1.0\n    ('high', 0.5, 3.0)    # IF x is high THEN y = 0.5*x + 3.0\n])\n\n# Evaluate\nresult = system.evaluate(x=7)\nprint(f\"y = {result['y']:.2f}\")\n\n# For x=7:\n# - mu_low = 0.0, mu_high = 0.4\n# - y_low = 2.0*7 + 1.0 = 15.0\n# - y_high = 0.5*7 + 3.0 = 6.5\n# - y_final = (0.0*15.0 + 0.4*6.5) / (0.0 + 0.4) = 6.5\n</code></pre>"},{"location":"api_reference/inference/#example-4-multiple-inputs-complex-rules","title":"Example 4: Multiple Inputs &amp; Complex Rules","text":"<pre><code>system = MamdaniSystem()\n\n# Multiple inputs\nsystem.add_input('temp', (0, 40))\nsystem.add_input('humidity', (0, 100))\nsystem.add_output('comfort', (0, 10))\n\n# Add terms\nfor var in ['temp', 'humidity']:\n    system.add_term(var, 'low', 'triangular', (0, 0, 50))\n    system.add_term(var, 'high', 'triangular', (50, 100, 100))\n\nsystem.add_term('comfort', 'uncomfortable', 'triangular', (0, 0, 5))\nsystem.add_term('comfort', 'comfortable', 'triangular', (5, 10, 10))\n\n# Rules with OR operator\nsystem.add_rules([\n    {\n        'temp': 'high',\n        'humidity': 'high',\n        'comfort': 'uncomfortable',\n        'operator': 'OR',\n        'weight': 0.9\n    },\n    {\n        'temp': 'low',\n        'humidity': 'low',\n        'comfort': 'comfortable',\n        'operator': 'AND'\n    }\n])\n\nresult = system.evaluate(temp=30, humidity=70)\nprint(f\"Comfort: {result['comfort']:.1f}/10\")\n</code></pre>"},{"location":"api_reference/inference/#see-also","title":"See Also","text":"<ul> <li>Core API - Membership functions, fuzzy sets, operators</li> <li>Learning API - Automatic rule generation and optimization</li> <li>User Guide: Inference - Detailed tutorials</li> <li>Examples - Interactive notebooks</li> </ul>"},{"location":"api_reference/learning/","title":"Learning API Reference","text":"<p>The <code>fuzzy_systems.learning</code> module provides algorithms for automatic rule generation and system optimization:</p> <ul> <li>WangMendelLearning: Automatic rule generation from data (single-pass algorithm)</li> <li>ANFIS: Adaptive Neuro-Fuzzy Inference System (gradient-based learning)</li> <li>MamdaniLearning: Mamdani system optimization with gradients and metaheuristics</li> <li>Metaheuristics: PSO, Differential Evolution, Genetic Algorithms</li> </ul>"},{"location":"api_reference/learning/#wangmendellearning","title":"WangMendelLearning","text":"<p>Automatic fuzzy rule generation using the Wang-Mendel algorithm (1992).</p> <p>Reference: Wang, L. X., &amp; Mendel, J. M. (1992). \"Generating fuzzy rules by learning from examples.\" IEEE Transactions on Systems, Man, and Cybernetics, 22(6), 1414-1427.</p>"},{"location":"api_reference/learning/#algorithm-steps","title":"Algorithm Steps","text":"<ol> <li>Partition variable domains (use existing MFs)</li> <li>Generate candidate rules from each data sample</li> <li>Assign degree to each rule based on membership strengths</li> <li>Resolve conflicts (keep rule with highest degree)</li> <li>Create final fuzzy system with learned rules</li> </ol>"},{"location":"api_reference/learning/#constructor","title":"Constructor","text":"<pre><code>WangMendelLearning(system, X, y, task='auto',\n                   scale_classification=True, verbose_init=False)\n</code></pre> <p>Parameters:</p> <ul> <li><code>system</code> (MamdaniSystem): Pre-configured system with variables and terms (NO rules yet)</li> <li><code>X</code> (ndarray): Input data, shape <code>(n_samples, n_features)</code></li> <li><code>y</code> (ndarray): Output data, shape <code>(n_samples,)</code> or <code>(n_samples, n_outputs)</code></li> <li><code>task</code> (str): <code>'auto'</code> (detect), <code>'regression'</code>, or <code>'classification'</code> (default: <code>'auto'</code>)</li> <li><code>scale_classification</code> (bool): Scale classification outputs to [0, 1] (default: <code>True</code>)</li> <li><code>verbose_init</code> (bool): Print initialization info (default: <code>False</code>)</li> </ul> <p>Example: <pre><code>import numpy as np\nfrom fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.learning import WangMendelLearning\n\n# Prepare data\nX_train = np.random.uniform(0, 10, (100, 2))\ny_train = np.sin(X_train[:, 0]) + np.cos(X_train[:, 1])\n\n# Create base system (with variables and terms, NO rules)\nsystem = MamdaniSystem()\nsystem.add_input('x1', (0, 10))\nsystem.add_input('x2', (0, 10))\nsystem.add_output('y', (-2, 2))\n\n# Add partitions (e.g., 5 terms per variable)\nfor var in ['x1', 'x2']:\n    for i in range(5):\n        center = i * 2.5\n        system.add_term(var, f'term_{i}', 'triangular',\n                       (max(0, center-2.5), center, min(10, center+2.5)))\n\n# Similar for output\nfor i in range(5):\n    center = -2 + i * 1.0\n    system.add_term('y', f'out_{i}', 'triangular',\n                   (max(-2, center-1), center, min(2, center+1)))\n\n# Learn rules from data\nwm = WangMendelLearning(system, X_train, y_train)\nwm.fit(verbose=True)\n</code></pre></p>"},{"location":"api_reference/learning/#methods","title":"Methods","text":""},{"location":"api_reference/learning/#fitverbosefalse","title":"<code>.fit(verbose=False)</code>","text":"<p>Generate fuzzy rules from the training data.</p> <p>Parameters: - <code>verbose</code> (bool): Print progress information (default: <code>False</code>)</p> <p>Returns: <code>MamdaniSystem</code> - The trained fuzzy system</p> <p>Example: <pre><code>trained_system = wm.fit(verbose=True)\n</code></pre></p> <p>Output (verbose=True): <pre><code>\ud83d\udd04 Wang-Mendel Algorithm Starting...\n   \u2713 Generated 100 candidate rules\n   \u2713 Resolved 23 conflicts\n   \u2713 Final rule base: 77 rules\n\u2705 Wang-Mendel training complete!\n</code></pre></p>"},{"location":"api_reference/learning/#predictx","title":"<code>.predict(X)</code>","text":"<p>Predict outputs for new inputs.</p> <p>Parameters: - <code>X</code> (ndarray): Input data, shape <code>(n_samples, n_features)</code></p> <p>Returns: <code>ndarray</code> - Predicted outputs</p> <p>For Regression: <pre><code>y_pred = wm.predict(X_test)  # Shape: (n_samples, n_outputs)\n</code></pre></p> <p>For Classification: <pre><code>y_pred_classes = wm.predict(X_test)  # Shape: (n_samples,) - class indices\n</code></pre></p>"},{"location":"api_reference/learning/#predict_probax-classification-only","title":"<code>.predict_proba(X)</code> (Classification only)","text":"<p>Predict class probabilities.</p> <p>Parameters: - <code>X</code> (ndarray): Input data</p> <p>Returns: <code>ndarray</code> - Probability matrix, shape <code>(n_samples, n_classes)</code></p> <p>Example: <pre><code>proba = wm.predict_proba(X_test)\nprint(proba[0])  # [0.1, 0.7, 0.2] for 3 classes\n</code></pre></p>"},{"location":"api_reference/learning/#get_training_stats","title":"<code>.get_training_stats()</code>","text":"<p>Get statistics about the training process.</p> <p>Returns: <code>dict</code> - Training statistics: <pre><code>{\n    'candidate_rules': 100,      # Rules generated from data\n    'final_rules': 77,           # Rules after conflict resolution\n    'conflicts_resolved': 23,    # Number of conflicts\n    'task': 'regression'         # Task type\n}\n</code></pre></p> <p>Example: <pre><code>stats = wm.get_training_stats()\nprint(f\"Generated {stats['candidate_rules']} rules\")\nprint(f\"Final: {stats['final_rules']} rules\")\n</code></pre></p>"},{"location":"api_reference/learning/#complete-example-regression","title":"Complete Example: Regression","text":"<pre><code>import numpy as np\nfrom fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.learning import WangMendelLearning\n\n# Generate nonlinear data\nX_train = np.linspace(0, 2*np.pi, 50).reshape(-1, 1)\ny_train = np.sin(X_train) + 0.1*X_train\n\n# Create system with 11 partitions\nsystem = MamdaniSystem()\nsystem.add_input('x', (0, 2*np.pi))\nsystem.add_output('y', (-2, 2))\n\n# Add 11 triangular terms to input and output\nn_terms = 11\nfor i in range(n_terms):\n    # Input terms\n    center_x = i * (2*np.pi) / (n_terms - 1)\n    width = (2*np.pi) / (n_terms - 1)\n    system.add_term('x', f'x_{i}', 'triangular',\n                   (max(0, center_x - width),\n                    center_x,\n                    min(2*np.pi, center_x + width)))\n\n    # Output terms\n    center_y = -2 + i * 4 / (n_terms - 1)\n    width_y = 4 / (n_terms - 1)\n    system.add_term('y', f'y_{i}', 'triangular',\n                   (max(-2, center_y - width_y),\n                    center_y,\n                    min(2, center_y + width_y)))\n\n# Train Wang-Mendel\nwm = WangMendelLearning(system, X_train, y_train)\nwm.fit(verbose=True)\n\n# Predict\nX_test = np.linspace(0, 2*np.pi, 200).reshape(-1, 1)\ny_pred = wm.predict(X_test)\n\n# Evaluate\nfrom sklearn.metrics import mean_squared_error, r2_score\ny_true = np.sin(X_test) + 0.1*X_test\nmse = mean_squared_error(y_true, y_pred)\nr2 = r2_score(y_true, y_pred)\n\nprint(f\"MSE: {mse:.4f}\")\nprint(f\"R\u00b2: {r2:.4f}\")\n</code></pre>"},{"location":"api_reference/learning/#complete-example-classification","title":"Complete Example: Classification","text":"<pre><code>import numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.model_selection import train_test_split\nfrom fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.learning import WangMendelLearning\n\n# Load Iris dataset\niris = load_iris()\nX = iris.data[:, [2, 3]]  # Use petal length and width\ny = iris.target\n\n# One-hot encode targets\nencoder = OneHotEncoder(sparse_output=False)\ny_onehot = encoder.fit_transform(y.reshape(-1, 1))\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y_onehot, test_size=0.3, random_state=42\n)\n\n# Create system with 3 terms per input, 1 output per class\nsystem = MamdaniSystem()\nsystem.add_input('petal_length', (X[:, 0].min(), X[:, 0].max()))\nsystem.add_input('petal_width', (X[:, 1].min(), X[:, 1].max()))\n\n# Add 3 binary outputs (one per class)\nfor i in range(3):\n    system.add_output(f'class_{i}', (0, 1))\n\n# Add terms (3 per variable)\nfor var in ['petal_length', 'petal_width']:\n    universe = system.input_variables[var].universe\n    for i in range(3):\n        center = universe[0] + i * (universe[1] - universe[0]) / 2\n        width = (universe[1] - universe[0]) / 3\n        system.add_term(var, f'term_{i}', 'triangular',\n                       (max(universe[0], center - width),\n                        center,\n                        min(universe[1], center + width)))\n\n# Add output terms (2 per class: 0 and 1)\nfor i in range(3):\n    system.add_term(f'class_{i}', 'no', 'triangular', (0, 0, 0.5))\n    system.add_term(f'class_{i}', 'yes', 'triangular', (0.5, 1, 1))\n\n# Train\nwm = WangMendelLearning(system, X_train, y_train, task='classification')\nwm.fit(verbose=True)\n\n# Predict\ny_pred_classes = wm.predict(X_test)\ny_pred_proba = wm.predict_proba(X_test)\n\n# Evaluate\nfrom sklearn.metrics import accuracy_score, classification_report\ny_test_classes = y_test.argmax(axis=1)\naccuracy = accuracy_score(y_test_classes, y_pred_classes)\n\nprint(f\"Accuracy: {accuracy:.2%}\")\nprint(\"\\nClassification Report:\")\nprint(classification_report(y_test_classes, y_pred_classes,\n                           target_names=iris.target_names))\n</code></pre>"},{"location":"api_reference/learning/#anfis","title":"ANFIS","text":"<p>Adaptive Neuro-Fuzzy Inference System with gradient-based learning.</p>"},{"location":"api_reference/learning/#constructor_1","title":"Constructor","text":"<pre><code>ANFIS(n_inputs, n_terms, n_outputs=1, mf_type='gaussian')\n</code></pre> <p>Parameters:</p> <ul> <li><code>n_inputs</code> (int): Number of input variables</li> <li><code>n_terms</code> (int): Number of membership functions per input</li> <li><code>n_outputs</code> (int): Number of outputs (default: <code>1</code>)</li> <li><code>mf_type</code> (str): Membership function type: <code>'gaussian'</code>, <code>'bell'</code> (default: <code>'gaussian'</code>)</li> </ul> <p>Example: <pre><code>from fuzzy_systems.learning import ANFIS\n\nanfis = ANFIS(n_inputs=2, n_terms=3, n_outputs=1)\n</code></pre></p>"},{"location":"api_reference/learning/#methods_1","title":"Methods","text":""},{"location":"api_reference/learning/#fitx-y-epochs100-learning_rate001-batch_sizenone-validation_split00-early_stoppingfalse-patience10-lyapunov_checktrue-verbosetrue","title":"<code>.fit(X, y, epochs=100, learning_rate=0.01, batch_size=None, validation_split=0.0, early_stopping=False, patience=10, lyapunov_check=True, verbose=True)</code>","text":"<p>Train ANFIS using gradient descent with backpropagation.</p> <p>Parameters:</p> <ul> <li><code>X</code> (ndarray): Input data, shape <code>(n_samples, n_inputs)</code></li> <li><code>y</code> (ndarray): Output data, shape <code>(n_samples, n_outputs)</code> or <code>(n_samples,)</code></li> <li><code>epochs</code> (int): Number of training epochs (default: <code>100</code>)</li> <li><code>learning_rate</code> (float): Learning rate (default: <code>0.01</code>)</li> <li><code>batch_size</code> (int, optional): Batch size for mini-batch gradient descent. If None, uses full batch</li> <li><code>validation_split</code> (float): Fraction of data for validation (default: <code>0.0</code>)</li> <li><code>early_stopping</code> (bool): Stop if validation loss doesn't improve (default: <code>False</code>)</li> <li><code>patience</code> (int): Epochs to wait before early stopping (default: <code>10</code>)</li> <li><code>lyapunov_check</code> (bool): Monitor Lyapunov stability (default: <code>True</code>)</li> <li><code>verbose</code> (bool): Print training progress (default: <code>True</code>)</li> </ul> <p>Returns: <code>dict</code> - Training history</p> <p>Example: <pre><code>history = anfis.fit(\n    X_train, y_train,\n    epochs=50,\n    learning_rate=0.01,\n    validation_split=0.2,\n    early_stopping=True,\n    verbose=True\n)\n</code></pre></p> <p>Output (verbose=True): <pre><code>Epoch 10/50 - Loss: 0.0234 - Val Loss: 0.0251 - Lyapunov: 0.98\nEpoch 20/50 - Loss: 0.0156 - Val Loss: 0.0178 - Lyapunov: 0.99\n...\n\u2705 Training complete!\n</code></pre></p>"},{"location":"api_reference/learning/#predictx_1","title":"<code>.predict(X)</code>","text":"<p>Predict outputs for new inputs.</p> <p>Parameters: - <code>X</code> (ndarray): Input data, shape <code>(n_samples, n_inputs)</code></p> <p>Returns: <code>ndarray</code> - Predictions, shape <code>(n_samples, n_outputs)</code></p> <p>Example: <pre><code>y_pred = anfis.predict(X_test)\n</code></pre></p>"},{"location":"api_reference/learning/#get_training_history","title":"<code>.get_training_history()</code>","text":"<p>Get complete training history.</p> <p>Returns: <code>dict</code> - History with keys: <pre><code>{\n    'epochs': [1, 2, 3, ...],\n    'loss': [0.5, 0.3, 0.2, ...],\n    'val_loss': [0.6, 0.4, 0.25, ...],  # If validation_split &gt; 0\n    'lyapunov': [0.95, 0.97, 0.99, ...]  # If lyapunov_check=True\n}\n</code></pre></p> <p>Example: <pre><code>history = anfis.get_training_history()\n\nimport matplotlib.pyplot as plt\nplt.plot(history['epochs'], history['loss'], label='Training')\nplt.plot(history['epochs'], history['val_loss'], label='Validation')\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.legend()\nplt.show()\n</code></pre></p>"},{"location":"api_reference/learning/#complete-example-anfis-regression","title":"Complete Example: ANFIS Regression","text":"<pre><code>import numpy as np\nfrom fuzzy_systems.learning import ANFIS\n\n# Generate data\nX_train = np.random.uniform(0, 10, (200, 2))\ny_train = np.sin(X_train[:, 0]) + np.cos(X_train[:, 1])\n\nX_test = np.random.uniform(0, 10, (50, 2))\ny_true = np.sin(X_test[:, 0]) + np.cos(X_test[:, 1])\n\n# Create and train ANFIS\nanfis = ANFIS(n_inputs=2, n_terms=5, n_outputs=1, mf_type='gaussian')\n\nhistory = anfis.fit(\n    X_train, y_train,\n    epochs=100,\n    learning_rate=0.01,\n    validation_split=0.2,\n    early_stopping=True,\n    patience=10,\n    verbose=True\n)\n\n# Predict\ny_pred = anfis.predict(X_test)\n\n# Evaluate\nfrom sklearn.metrics import mean_squared_error, r2_score\nmse = mean_squared_error(y_true, y_pred)\nr2 = r2_score(y_true, y_pred)\n\nprint(f\"MSE: {mse:.4f}\")\nprint(f\"R\u00b2: {r2:.4f}\")\n\n# Plot training curve\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\n\nplt.subplot(1, 2, 1)\nplt.plot(history['epochs'], history['loss'], label='Train')\nplt.plot(history['epochs'], history['val_loss'], label='Validation')\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.legend()\nplt.title('Learning Curve')\n\nplt.subplot(1, 2, 2)\nplt.plot(history['epochs'], history['lyapunov'])\nplt.xlabel('Epoch')\nplt.ylabel('Lyapunov Stability')\nplt.title('Stability Monitoring')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"api_reference/learning/#mamdanilearning","title":"MamdaniLearning","text":"<p>Optimize Mamdani systems using gradients or metaheuristics.</p>"},{"location":"api_reference/learning/#constructor_2","title":"Constructor","text":"<pre><code>MamdaniLearning(system=None, X=None, y=None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>system</code> (MamdaniSystem, optional): Existing Mamdani system to optimize</li> <li><code>X</code> (ndarray, optional): Training input data</li> <li><code>y</code> (ndarray, optional): Training output data</li> </ul> <p>Example: <pre><code>from fuzzy_systems.learning import MamdaniLearning\n\n# Create from existing system\nlearner = MamdaniLearning.from_mamdani(system, X_train, y_train)\n\n# Or create new\nlearner = MamdaniLearning()\n# ... configure ...\n</code></pre></p>"},{"location":"api_reference/learning/#class-methods","title":"Class Methods","text":""},{"location":"api_reference/learning/#from_mamdanisystem-x-y","title":"<code>.from_mamdani(system, X, y)</code>","text":"<p>Create MamdaniLearning from existing MamdaniSystem.</p> <p>Parameters: - <code>system</code> (MamdaniSystem): Existing fuzzy system - <code>X</code> (ndarray): Training inputs - <code>y</code> (ndarray): Training outputs</p> <p>Returns: <code>MamdaniLearning</code> - Learner instance</p> <p>Example: <pre><code>learner = MamdaniLearning.from_mamdani(system, X_train, y_train)\n</code></pre></p>"},{"location":"api_reference/learning/#methods_2","title":"Methods","text":""},{"location":"api_reference/learning/#fitx-y-methodgradient-epochs100-learning_rate001-kwargs","title":"<code>.fit(X, y, method='gradient', epochs=100, learning_rate=0.01, **kwargs)</code>","text":"<p>Optimize the fuzzy system.</p> <p>Parameters:</p> <ul> <li><code>X</code> (ndarray): Training input data</li> <li><code>y</code> (ndarray): Training output data</li> <li><code>method</code> (str): Optimization method:<ul> <li><code>'gradient'</code>: Gradient descent</li> <li><code>'pso'</code>: Particle Swarm Optimization</li> <li><code>'de'</code>: Differential Evolution</li> <li><code>'ga'</code>: Genetic Algorithm</li> </ul> </li> <li><code>epochs</code> (int): Number of iterations (default: <code>100</code>)</li> <li><code>learning_rate</code> (float): Learning rate for gradient (default: <code>0.01</code>)</li> <li><code>**kwargs</code>: Method-specific parameters</li> </ul> <p>Gradient-specific kwargs: - <code>batch_size</code> (int): Batch size for mini-batch - <code>momentum</code> (float): Momentum factor</p> <p>PSO-specific kwargs: - <code>n_particles</code> (int): Number of particles (default: <code>30</code>) - <code>inertia</code> (float): Inertia weight (default: <code>0.7</code>) - <code>cognitive</code> (float): Cognitive parameter (default: <code>1.5</code>) - <code>social</code> (float): Social parameter (default: <code>1.5</code>)</p> <p>DE-specific kwargs: - <code>population_size</code> (int): Population size (default: <code>50</code>) - <code>mutation_factor</code> (float): Mutation factor F (default: <code>0.8</code>) - <code>crossover_prob</code> (float): Crossover probability (default: <code>0.9</code>)</p> <p>GA-specific kwargs: - <code>population_size</code> (int): Population size (default: <code>50</code>) - <code>mutation_rate</code> (float): Mutation rate (default: <code>0.1</code>) - <code>crossover_rate</code> (float): Crossover rate (default: <code>0.8</code>)</p> <p>Example: <pre><code># Gradient descent\nlearner.fit(X_train, y_train, method='gradient',\n           epochs=100, learning_rate=0.01)\n\n# PSO\nlearner.fit(X_train, y_train, method='pso',\n           epochs=50, n_particles=30)\n\n# Differential Evolution\nlearner.fit(X_train, y_train, method='de',\n           epochs=100, population_size=50)\n</code></pre></p>"},{"location":"api_reference/learning/#predictx_2","title":"<code>.predict(X)</code>","text":"<p>Predict outputs using the optimized system.</p> <p>Parameters: - <code>X</code> (ndarray): Input data</p> <p>Returns: <code>ndarray</code> - Predictions</p>"},{"location":"api_reference/learning/#to_mamdani","title":"<code>.to_mamdani()</code>","text":"<p>Convert back to MamdaniSystem.</p> <p>Returns: <code>MamdaniSystem</code> - Optimized fuzzy system</p> <p>Example: <pre><code>optimized_system = learner.to_mamdani()\noptimized_system.plot_variables()\n</code></pre></p>"},{"location":"api_reference/learning/#complete-example-optimization-with-pso","title":"Complete Example: Optimization with PSO","text":"<pre><code>import numpy as np\nfrom fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.learning import MamdaniLearning\n\n# Generate data\nX_train = np.linspace(-5, 5, 100).reshape(-1, 1)\ny_train = -2 * X_train + 5 + np.random.normal(0, 0.5, X_train.shape)\n\n# Create initial system\nsystem = MamdaniSystem()\nsystem.add_input('x', (-5, 5))\nsystem.add_output('y', (-15, 15))\n\n# Add terms with suboptimal initial parameters\nsystem.add_term('x', 'low', 'triangular', (-5, -2, 1))\nsystem.add_term('x', 'high', 'triangular', (-1, 2, 5))\nsystem.add_term('y', 'low', 'triangular', (-15, -7, 1))\nsystem.add_term('y', 'high', 'triangular', (-1, 7, 15))\n\n# Initial rules\nsystem.add_rules([('low', 'high'), ('high', 'low')])\n\n# Create learner\nlearner = MamdaniLearning.from_mamdani(system, X_train, y_train)\n\n# Optimize with PSO\nhistory = learner.fit(\n    X_train, y_train,\n    method='pso',\n    epochs=100,\n    n_particles=30,\n    verbose=True\n)\n\n# Predict\ny_pred = learner.predict(X_train)\n\n# Evaluate\nfrom sklearn.metrics import mean_squared_error\nmse = mean_squared_error(y_train, y_pred)\nprint(f\"MSE after optimization: {mse:.4f}\")\n\n# Get optimized system\noptimized_system = learner.to_mamdani()\noptimized_system.save('optimized_system.pkl')\n</code></pre>"},{"location":"api_reference/learning/#metaheuristics","title":"Metaheuristics","text":"<p>Direct access to optimization algorithms.</p>"},{"location":"api_reference/learning/#pso","title":"PSO","text":"<p>Particle Swarm Optimization.</p> <pre><code>from fuzzy_systems.learning import PSO\n\noptimizer = PSO(\n    objective_func,\n    bounds,\n    n_particles=30,\n    max_iter=100,\n    inertia=0.7,\n    cognitive=1.5,\n    social=1.5\n)\n\nbest_params, best_cost = optimizer.optimize()\n</code></pre>"},{"location":"api_reference/learning/#de","title":"DE","text":"<p>Differential Evolution.</p> <pre><code>from fuzzy_systems.learning import DE\n\noptimizer = DE(\n    objective_func,\n    bounds,\n    population_size=50,\n    max_iter=100,\n    mutation_factor=0.8,\n    crossover_prob=0.9\n)\n\nbest_params, best_cost = optimizer.optimize()\n</code></pre>"},{"location":"api_reference/learning/#ga","title":"GA","text":"<p>Genetic Algorithm.</p> <pre><code>from fuzzy_systems.learning import GA\n\noptimizer = GA(\n    objective_func,\n    bounds,\n    population_size=50,\n    max_iter=100,\n    mutation_rate=0.1,\n    crossover_rate=0.8\n)\n\nbest_params, best_cost = optimizer.optimize()\n</code></pre>"},{"location":"api_reference/learning/#comparison-table","title":"Comparison Table","text":"Method Type Speed Accuracy Best For Wang-Mendel Rule generation \u26a1\u26a1\u26a1 Fast \u2b50\u2b50 Good Quick prototyping, interpretable rules ANFIS Neuro-fuzzy \u26a1\u26a1 Medium \u2b50\u2b50\u2b50 Excellent Precise approximation, differentiable problems MamdaniLearning (Gradient) Gradient \u26a1\u26a1 Medium \u2b50\u2b50\u2b50 Excellent Fine-tuning existing systems MamdaniLearning (PSO) Metaheuristic \u26a1 Slow \u2b50\u2b50\u2b50 Excellent Non-differentiable, global search MamdaniLearning (DE) Metaheuristic \u26a1 Slow \u2b50\u2b50\u2b50 Excellent Robust optimization, fewer parameters MamdaniLearning (GA) Metaheuristic \u26a1 Slow \u2b50\u2b50 Good Discrete/combinatorial optimization"},{"location":"api_reference/learning/#see-also","title":"See Also","text":"<ul> <li>Core API - Fuzzy sets and operators</li> <li>Inference API - Mamdani and Sugeno systems</li> <li>Dynamics API - Dynamic fuzzy systems</li> <li>User Guide: Learning - Detailed tutorials</li> <li>Examples - Interactive notebooks</li> </ul>"},{"location":"examples/gallery/","title":"Examples Gallery","text":"<p>Explore practical examples through interactive Colab notebooks organized by topic and difficulty.</p>"},{"location":"examples/gallery/#fundamentals-beginner","title":"\ud83d\udd30 Fundamentals (Beginner)","text":"<p>Learn the basics of fuzzy logic.</p>"},{"location":"examples/gallery/#membership-functions","title":"Membership Functions","text":"<p>What you'll learn: - Triangular, trapezoidal, gaussian, sigmoid functions - <code>FuzzySet</code> and <code>LinguisticVariable</code> classes - Fuzzification process - Fuzzy operators (AND, OR, NOT)</p> <p>Estimated time: 45-60 min</p>"},{"location":"examples/gallery/#thermal-comfort-system","title":"Thermal Comfort System","text":"<p>What you'll learn: - Model multiple variables (temperature + humidity) - Combine variables with fuzzy operators - Implement simple IF-THEN rules - Create 2D comfort maps</p> <p>Estimated time: 40-50 min</p>"},{"location":"examples/gallery/#inference-systems-intermediate","title":"\ud83c\udf9b\ufe0f Inference Systems (Intermediate)","text":"<p>Build complete fuzzy inference systems.</p>"},{"location":"examples/gallery/#mamdani-tipping-system","title":"Mamdani Tipping System","text":"<p>What you'll learn: - Complete Mamdani inference system - 5 Mamdani steps: fuzzification \u2192 rules \u2192 implication \u2192 aggregation \u2192 defuzzification - Multiple inputs (service + food quality) - 3D control surfaces</p> <p>Estimated time: 60-75 min</p>"},{"location":"examples/gallery/#sugeno-zero-order-system","title":"Sugeno Zero-Order System","text":"<p>What you'll learn: - Sugeno system with constant outputs - Difference between Mamdani and Sugeno - Weighted average defuzzification</p> <p>Estimated time: 45-60 min</p>"},{"location":"examples/gallery/#sugeno-first-order-system","title":"Sugeno First-Order System","text":"<p>What you'll learn: - Sugeno with linear output functions: y = ax + b - Function approximation - Comparison with zero-order</p> <p>Estimated time: 40-50 min</p>"},{"location":"examples/gallery/#voting-prediction","title":"Voting Prediction","text":"<p>What you'll learn: - Real-world application - Complex rule base - Multiple inputs (income + education)</p> <p>Estimated time: 50-70 min</p>"},{"location":"examples/gallery/#learning-optimization-advanced","title":"\ud83e\udde0 Learning &amp; Optimization (Advanced)","text":"<p>Automatic rule generation and system optimization.</p>"},{"location":"examples/gallery/#wang-mendel-nonlinear-approximation","title":"Wang-Mendel: Nonlinear Approximation","text":"<p>What you'll learn: - Automatic rule generation from data - Single-pass learning algorithm - Function approximation: f(x) = sin(x) + 0.1x - Rule conflict resolution</p> <p>Estimated time: 60-75 min</p>"},{"location":"examples/gallery/#wang-mendel-linear-function","title":"Wang-Mendel: Linear Function","text":"<p>What you'll learn: - Simple case study - Effect of number of partitions - Performance metrics (MSE, RMSE, R\u00b2)</p> <p>Estimated time: 40-50 min</p>"},{"location":"examples/gallery/#wang-mendel-iris-classification","title":"Wang-Mendel: Iris Classification","text":"<p>What you'll learn: - Classification with Wang-Mendel - Multi-class fuzzy classification - Interpretable fuzzy rules</p> <p>Estimated time: 50-65 min</p>"},{"location":"examples/gallery/#anfis-iris-classification","title":"ANFIS: Iris Classification","text":"<p>What you'll learn: - Adaptive Neuro-Fuzzy Inference System - Gradient-based learning (backpropagation) - Membership function refinement - Lyapunov stability monitoring</p> <p>Estimated time: 60-75 min</p>"},{"location":"examples/gallery/#anfis-regression","title":"ANFIS: Regression","text":"<p>What you'll learn: - ANFIS for regression problems - Nonlinear function approximation - Comparison with neural networks</p> <p>Estimated time: 50-65 min</p>"},{"location":"examples/gallery/#rules-optimization-with-pso","title":"Rules Optimization with PSO","text":"<p>What you'll learn: - Particle Swarm Optimization (PSO) - Metaheuristic optimization - Optimize membership function parameters</p> <p>Estimated time: 50-65 min</p>"},{"location":"examples/gallery/#rules-optimization-iris","title":"Rules Optimization: Iris","text":"<p>What you'll learn: - Comparison: PSO vs DE vs GA - Classification optimization - Best practices</p> <p>Estimated time: 55-70 min</p>"},{"location":"examples/gallery/#dynamic-systems-advanced","title":"\ud83c\udf0a Dynamic Systems (Advanced)","text":"<p>Fuzzy systems with time evolution.</p>"},{"location":"examples/gallery/#p-fuzzy-discrete-predator-prey","title":"p-Fuzzy Discrete: Predator-Prey","text":"<p>What you'll learn: - Discrete p-fuzzy systems: x_{n+1} = x_n + f(x_n) - Population dynamics with fuzzy rules - Phase space analysis - Multiple initial conditions</p> <p>Estimated time: 50-65 min</p>"},{"location":"examples/gallery/#p-fuzzy-continuous-predator-prey","title":"p-Fuzzy Continuous: Predator-Prey","text":"<p>What you'll learn: - Continuous p-fuzzy: dx/dt = f(x) - ODE integration (Euler, RK4) - Oscillatory dynamics - Vector fields</p> <p>Estimated time: 60-75 min</p>"},{"location":"examples/gallery/#p-fuzzy-discrete-population-growth","title":"p-Fuzzy Discrete: Population Growth","text":"<p>What you'll learn: - Single population model - Logistic-like fuzzy dynamics - Bifurcation analysis</p> <p>Estimated time: 45-60 min</p>"},{"location":"examples/gallery/#fuzzy-ode-logistic-growth","title":"Fuzzy ODE: Logistic Growth","text":"<p>What you'll learn: - ODEs with fuzzy parameters/initial conditions - \u03b1-level method for uncertainty propagation - Fuzzy envelopes</p> <p>Estimated time: 55-70 min</p>"},{"location":"examples/gallery/#fuzzy-ode-holling-tanner","title":"Fuzzy ODE: Holling-Tanner","text":"<p>What you'll learn: - System of ODEs with fuzzy uncertainty - Multi-dimensional envelopes - Phase space with uncertainty</p> <p>Estimated time: 60-75 min</p>"},{"location":"examples/gallery/#by-difficulty-level","title":"By Difficulty Level","text":""},{"location":"examples/gallery/#beginner-0-2-notebooks-recommended","title":"\ud83d\udfe2 Beginner (0-2 notebooks recommended)","text":"<ul> <li>Membership Functions</li> <li>Thermal Comfort</li> </ul>"},{"location":"examples/gallery/#intermediate-after-fundamentals","title":"\ud83d\udfe1 Intermediate (After fundamentals)","text":"<ul> <li>All Inference Systems (Mamdani, Sugeno, Voting)</li> </ul>"},{"location":"examples/gallery/#advanced-requires-mlmath-background","title":"\ud83d\udd34 Advanced (Requires ML/math background)","text":"<ul> <li>All Learning notebooks (Wang-Mendel, ANFIS, PSO)</li> <li>All Dynamics notebooks (p-fuzzy, Fuzzy ODEs)</li> </ul>"},{"location":"examples/gallery/#running-the-examples","title":"Running the Examples","text":""},{"location":"examples/gallery/#on-google-colab-recommended","title":"On Google Colab (Recommended)","text":"<ol> <li>Click any \"Open in Colab\" badge</li> <li>Run the first cell to install: <code>!pip install pyfuzzy-toolbox</code></li> <li>Execute cells sequentially</li> </ol>"},{"location":"examples/gallery/#locally","title":"Locally","text":"<pre><code># Clone repository\ngit clone https://github.com/1moi6/pyfuzzy-toolbox.git\ncd pyfuzzy-toolbox/notebooks_colab\n\n# Install dependencies\npip install pyfuzzy-toolbox jupyter\n\n# Launch Jupyter\njupyter notebook\n</code></pre>"},{"location":"examples/gallery/#need-help","title":"Need Help?","text":"<ul> <li>API Reference: Detailed documentation of all methods</li> <li>User Guide: Conceptual explanations and tutorials</li> <li>GitHub Issues: Report problems or ask questions</li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>pip (Python package manager)</li> </ul>"},{"location":"getting_started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The simplest way to install pyfuzzy-toolbox is via pip:</p> <pre><code>pip install pyfuzzy-toolbox\n</code></pre>"},{"location":"getting_started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Install with machine learning support (ANFIS, Wang-Mendel, optimization):</p> <pre><code>pip install pyfuzzy-toolbox[ml]\n</code></pre> <p>Install with development tools (testing, linting):</p> <pre><code>pip install pyfuzzy-toolbox[dev]\n</code></pre> <p>Install everything:</p> <pre><code>pip install pyfuzzy-toolbox[all]\n</code></pre>"},{"location":"getting_started/installation/#install-from-source","title":"Install from Source","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/1moi6/pyfuzzy-toolbox.git\ncd pyfuzzy-toolbox\npip install -e .\n</code></pre> <p>For editable install with development dependencies:</p> <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import fuzzy_systems as fs\n\nprint(f\"pyfuzzy-toolbox version: {fs.__version__}\")\n</code></pre>"},{"location":"getting_started/installation/#import-convention","title":"Import Convention","text":"<p>The recommended import convention is:</p> <pre><code>import fuzzy_systems as fs\n</code></pre> <p>Note: The package name on PyPI is <code>pyfuzzy-toolbox</code>, but you import it as <code>fuzzy_systems</code>.</p>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart: Create your first fuzzy system in 5 minutes</li> <li>Key Concepts: Learn fundamental fuzzy logic concepts</li> </ul>"},{"location":"getting_started/quickstart/","title":"Quickstart Guide","text":"<p>Get started with pyfuzzy-toolbox in 5 minutes!</p>"},{"location":"getting_started/quickstart/#installation","title":"Installation","text":"<pre><code>pip install pyfuzzy-toolbox\n</code></pre>"},{"location":"getting_started/quickstart/#your-first-fuzzy-system","title":"Your First Fuzzy System","text":"<p>Let's build a simple temperature-controlled fan system: - Input: Temperature (0-40\u00b0C) - Output: Fan speed (0-100%) - Rules: If cold \u2192 slow, If hot \u2192 fast</p>"},{"location":"getting_started/quickstart/#step-1-import","title":"Step 1: Import","text":"<pre><code>import fuzzy_systems as fs\n</code></pre>"},{"location":"getting_started/quickstart/#step-2-create-system","title":"Step 2: Create System","text":"<pre><code># Create Mamdani system\nsystem = fs.MamdaniSystem()\n</code></pre>"},{"location":"getting_started/quickstart/#step-3-define-input-variable","title":"Step 3: Define Input Variable","text":"<pre><code># Add input: temperature\nsystem.add_input('temperature', (0, 40))\n\n# Add linguistic terms\nsystem.add_term('temperature', 'cold', 'triangular', (0, 0, 20))\nsystem.add_term('temperature', 'hot', 'triangular', (20, 40, 40))\n</code></pre>"},{"location":"getting_started/quickstart/#step-4-define-output-variable","title":"Step 4: Define Output Variable","text":"<pre><code># Add output: fan speed\nsystem.add_output('fan_speed', (0, 100))\n\n# Add linguistic terms\nsystem.add_term('fan_speed', 'slow', 'triangular', (0, 0, 50))\nsystem.add_term('fan_speed', 'fast', 'triangular', (50, 100, 100))\n</code></pre>"},{"location":"getting_started/quickstart/#step-5-add-rules","title":"Step 5: Add Rules","text":"<pre><code># Define fuzzy rules\nsystem.add_rules([\n    ('cold', 'slow'),  # IF temperature is cold THEN fan_speed is slow\n    ('hot', 'fast')    # IF temperature is hot THEN fan_speed is fast\n])\n</code></pre>"},{"location":"getting_started/quickstart/#step-6-evaluate","title":"Step 6: Evaluate","text":"<pre><code># Test the system\nresult = system.evaluate(temperature=25)\nprint(f\"Fan speed: {result['fan_speed']:.1f}%\")\n# Output: Fan speed: 50.0%\n</code></pre>"},{"location":"getting_started/quickstart/#complete-example","title":"Complete Example","text":"<pre><code>import fuzzy_systems as fs\n\n# Create and configure system\nsystem = fs.MamdaniSystem()\nsystem.add_input('temperature', (0, 40))\nsystem.add_output('fan_speed', (0, 100))\n\n# Add terms\nsystem.add_term('temperature', 'cold', 'triangular', (0, 0, 20))\nsystem.add_term('temperature', 'hot', 'triangular', (20, 40, 40))\nsystem.add_term('fan_speed', 'slow', 'triangular', (0, 0, 50))\nsystem.add_term('fan_speed', 'fast', 'triangular', (50, 100, 100))\n\n# Add rules\nsystem.add_rules([\n    ('cold', 'slow'),\n    ('hot', 'fast')\n])\n\n# Evaluate\nresult = system.evaluate(temperature=25)\nprint(f\"Fan speed: {result['fan_speed']:.1f}%\")\n</code></pre>"},{"location":"getting_started/quickstart/#visualize-your-system","title":"Visualize Your System","text":"<pre><code># Plot input variable\nsystem.plot_variables(['temperature'])\n\n# Plot output variable\nsystem.plot_variables(['fan_speed'])\n\n# Plot rule matrix\nsystem.plot_rule_matrix()\n</code></pre>"},{"location":"getting_started/quickstart/#test-multiple-values","title":"Test Multiple Values","text":"<pre><code>test_temps = [5, 15, 25, 35]\n\nfor temp in test_temps:\n    result = system.evaluate(temperature=temp)\n    print(f\"Temperature: {temp}\u00b0C \u2192 Fan speed: {result['fan_speed']:.1f}%\")\n</code></pre> <p>Output: <pre><code>Temperature: 5\u00b0C \u2192 Fan speed: 12.5%\nTemperature: 15\u00b0C \u2192 Fan speed: 37.5%\nTemperature: 25\u00b0C \u2192 Fan speed: 62.5%\nTemperature: 35\u00b0C \u2192 Fan speed: 87.5%\n</code></pre></p>"},{"location":"getting_started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a working fuzzy system, explore more:</p> <ul> <li>User Guide: Fundamentals - Learn about membership functions, fuzzification, and operators</li> <li>User Guide: Inference - Build complex Mamdani and Sugeno systems</li> <li>Examples Gallery - See practical applications in Colab notebooks</li> <li>API Reference - Detailed documentation of all classes and methods</li> </ul>"},{"location":"getting_started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting_started/quickstart/#adding-more-terms","title":"Adding More Terms","text":"<pre><code>system.add_term('temperature', 'cold', 'triangular', (0, 0, 15))\nsystem.add_term('temperature', 'warm', 'triangular', (10, 20, 30))\nsystem.add_term('temperature', 'hot', 'triangular', (25, 40, 40))\n\nsystem.add_term('fan_speed', 'slow', 'triangular', (0, 0, 40))\nsystem.add_term('fan_speed', 'medium', 'triangular', (30, 50, 70))\nsystem.add_term('fan_speed', 'fast', 'triangular', (60, 100, 100))\n</code></pre>"},{"location":"getting_started/quickstart/#adding-more-rules","title":"Adding More Rules","text":"<pre><code>system.add_rules([\n    ('cold', 'slow'),\n    ('warm', 'medium'),\n    ('hot', 'fast')\n])\n</code></pre>"},{"location":"getting_started/quickstart/#multiple-inputs","title":"Multiple Inputs","text":"<pre><code>system.add_input('humidity', (0, 100))\nsystem.add_term('humidity', 'dry', 'triangular', (0, 0, 50))\nsystem.add_term('humidity', 'humid', 'triangular', (50, 100, 100))\n\n# Rules with multiple conditions\nsystem.add_rules([\n    {'temperature': 'hot', 'humidity': 'humid', 'fan_speed': 'fast'},\n    {'temperature': 'cold', 'humidity': 'dry', 'fan_speed': 'slow'}\n])\n</code></pre>"},{"location":"getting_started/quickstart/#help-support","title":"Help &amp; Support","text":"<ul> <li>Documentation: Full docs</li> <li>Issues: Report bugs</li> <li>PyPI: Package page</li> </ul>"},{"location":"quick_start/","title":"pyfuzzy-toolbox Quick Start Guides","text":"<p>Complete collection of quick start guides for all modules in the pyfuzzy-toolbox library.</p>"},{"location":"quick_start/#available-guides","title":"\ud83d\udcda Available Guides","text":""},{"location":"quick_start/#learning-algorithms","title":"\ud83e\udde0 Learning Algorithms","text":"<p>Learn fuzzy systems from data using various learning techniques.</p>"},{"location":"quick_start/#1-anfis-adaptive-neuro-fuzzy-inference-system","title":"1. ANFIS - Adaptive Neuro-Fuzzy Inference System","text":"<p>Hybrid learning combining neural networks and fuzzy logic</p> <ul> <li>\u2705 Supervised learning for regression/classification</li> <li>\u2705 Two training methods: <code>fit()</code> (gradient descent) and <code>fit_metaheuristic()</code> (PSO/DE/GA)</li> <li>\u2705 Automatic parameter optimization</li> <li>\ud83d\udcd3 Notebooks: <code>03_learning/anfis_regression.ipynb</code>, <code>03_learning/anfis_iris.ipynb</code></li> </ul> <p>Key Features: - Gaussian, Bell, and Sigmoid membership functions - Hybrid learning: LSE for consequents + gradient descent for premises - Metaheuristic optimization: PSO, DE, GA - Early stopping and adaptive learning rate</p> <p>When to use: Complex nonlinear regression/classification with automatic rule extraction.</p>"},{"location":"quick_start/#2-wang-mendel-learning","title":"2. Wang-Mendel Learning","text":"<p>Single-pass fuzzy rule extraction from data</p> <ul> <li>\u2705 Fast rule generation from training data</li> <li>\u2705 Automatic task detection (regression/classification)</li> <li>\u2705 No iterative optimization needed</li> <li>\ud83d\udcd3 Notebooks: <code>03_learning/wang_mendel_nonlinear.ipynb</code>, <code>03_learning/wang_mendel_iris.ipynb</code></li> </ul> <p>Key Features: - One-pass algorithm (very fast) - Automatic membership function generation - Rule conflict resolution - Handles multi-output systems</p> <p>When to use: Quick fuzzy model from data, interpretable rules, baseline models.</p>"},{"location":"quick_start/#3-mamdani-learning","title":"3. Mamdani Learning","text":"<p>Optimize Mamdani fuzzy system consequents with metaheuristics</p> <ul> <li>\u2705 Optimize rule consequents for existing Mamdani FIS</li> <li>\u2705 Four metaheuristic algorithms: SA, GA, PSO, DE</li> <li>\u2705 Preserves linguistic interpretability</li> <li>\ud83d\udcd3 Notebooks: <code>03_learning/rules_optimization.ipynb</code>, <code>03_learning/rules_optimization_iris.ipynb</code></li> </ul> <p>Key Features: - Simulated Annealing (SA): local search with probabilistic acceptance - Genetic Algorithm (GA): population-based with crossover/mutation - Particle Swarm Optimization (PSO): swarm intelligence - Differential Evolution (DE): mutation-based evolution</p> <p>When to use: Fine-tune existing Mamdani systems, optimize rule consequents while keeping antecedents.</p>"},{"location":"quick_start/#fuzzy-inference-systems","title":"\ud83c\udf9b\ufe0f Fuzzy Inference Systems","text":"<p>Build and use fuzzy inference systems for control and decision-making.</p>"},{"location":"quick_start/#4-mamdani-system","title":"4. Mamdani System","text":"<p>Linguistic fuzzy inference with fuzzy outputs</p> <ul> <li>\u2705 Manual or automatic membership function generation</li> <li>\u2705 Intuitive rule creation (dictionaries, lists, indices)</li> <li>\u2705 Multiple defuzzification methods</li> <li>\ud83d\udcd3 Notebooks: <code>02_inference/01_mamdani_tipping.ipynb</code>, <code>02_inference/02_voting_prediction.ipynb</code></li> </ul> <p>Key Features: - <code>add_auto_mfs()</code>: automatic MF generation with linguistic labels - Multiple rule formats: dict, list, tuple - Visualization: <code>plot_variables()</code>, <code>plot_output()</code>, <code>plot_rule_matrix()</code> - Save/load: <code>save()</code>, <code>load()</code>, <code>export_rules()</code>, <code>import_rules()</code></p> <p>When to use: Human-interpretable control systems, linguistic rules, fuzzy decision-making.</p>"},{"location":"quick_start/#5-sugeno-system","title":"5. Sugeno System","text":"<p>Efficient fuzzy inference with mathematical consequents</p> <ul> <li>\u2705 Order 0 (constant) or Order 1 (linear) consequents</li> <li>\u2705 No defuzzification needed (weighted average)</li> <li>\u2705 Ideal for ANFIS and optimization</li> <li>\ud83d\udcd3 Notebooks: <code>02_inference/03_sugeno_zero_order.ipynb</code>, <code>02_inference/04_sugeno_first_order.ipynb</code></li> </ul> <p>Key Features: - Order 0: IF-THEN rules with constant outputs (singletons) - Order 1: IF-THEN rules with linear functions of inputs - Faster computation than Mamdani - Better for learning algorithms (ANFIS compatible)</p> <p>When to use: Optimization tasks, ANFIS learning, smooth approximations, computational efficiency.</p>"},{"location":"quick_start/#dynamical-systems","title":"\ud83d\udd04 Dynamical Systems","text":"<p>Model temporal evolution with fuzzy rules.</p>"},{"location":"quick_start/#6-p-fuzzy-discrete","title":"6. p-Fuzzy Discrete","text":"<p>Discrete-time fuzzy dynamical systems</p> <ul> <li>\u2705 Model discrete-time evolution: x_{n+1} = x_n + f(x_n)</li> <li>\u2705 Absolute or relative modes</li> <li>\u2705 Single-step execution for analysis</li> <li>\ud83d\udcd3 Notebooks: <code>04_dynamics/pfuzzy_discrete_predator_prey.ipynb</code>, <code>04_dynamics/pfuzzy_population.ipynb</code></li> </ul> <p>Key Features: - Absolute mode: x_{n+1} = x_n + f(x_n) (additive change) - Relative mode: x_{n+1} = x_n \u00d7 f(x_n) (multiplicative change) - <code>simulate()</code>: run n_steps iterations - <code>step()</code>: single iteration for manual control - Export: <code>to_csv()</code> with international/Brazilian formats</p> <p>When to use: Population dynamics (generations), discrete events, time-series with discrete steps.</p>"},{"location":"quick_start/#7-p-fuzzy-continuous","title":"7. p-Fuzzy Continuous","text":"<p>Continuous-time fuzzy dynamical systems with ODEs</p> <ul> <li>\u2705 Model continuous evolution: dx/dt = f(x)</li> <li>\u2705 Euler or RK4 integration methods</li> <li>\u2705 Fixed or adaptive time stepping</li> <li>\ud83d\udcd3 Notebooks: <code>04_dynamics/pfuzzy_continuous_predator_prey.ipynb</code></li> </ul> <p>Key Features: - Absolute mode: dx/dt = f(x) (rate independent of state) - Relative mode: dx/dt = x\u00b7f(x) (rate proportional to state) - Integration methods: <code>'euler'</code> (fast), <code>'rk4'</code> (accurate) - Adaptive stepping: automatically adjusts dt for accuracy - Verbose mode: prints statistics (accepted/rejected steps, dt range)</p> <p>When to use: Physical processes, continuous growth, temperature/cooling systems, smooth dynamics.</p>"},{"location":"quick_start/#8-fuzzy-ode-solver","title":"8. Fuzzy ODE Solver","text":"<p>Solve ODEs with fuzzy initial conditions and parameters</p> <ul> <li>\u2705 Propagate uncertainty through differential equations</li> <li>\u2705 Fuzzy numbers for initial conditions and parameters</li> <li>\u2705 Three solution methods: standard, Monte Carlo, hierarchical</li> <li>\ud83d\udcd3 Notebooks: <code>04_dynamics/fuzzy_ode_logistic.ipynb</code>, <code>04_dynamics/fuzzy_ode_holling_tanner.ipynb</code></li> </ul> <p>Key Features: - Fuzzy numbers: triangular, gaussian, trapezoidal - \u03b1-cuts: confidence levels for uncertainty quantification - Solution methods:   - <code>'standard'</code>: full grid (most accurate)   - <code>'monte_carlo'</code>: sampling (10-400x faster for high dimensions)   - <code>'hierarchical'</code>: optimization (3-5x faster) - Visualization: plot \u03b1-level envelopes - Export: <code>to_csv()</code>, <code>to_dataframe()</code></p> <p>When to use: Uncertain initial conditions, imprecise parameters, possibilistic uncertainty (vs probabilistic).</p>"},{"location":"quick_start/#quick-reference-table","title":"\ud83d\uddc2\ufe0f Quick Reference Table","text":"Module Type Input Output Best For Notebooks ANFIS Learning Data (X, y) Sugeno FIS Regression, classification 01, 02 Wang-Mendel Learning Data (X, y) Mamdani FIS Fast rule extraction 03, 04 Mamdani Learning Learning FIS + Data Optimized FIS Fine-tuning consequents 05 Mamdani System Inference Variables + Rules FIS Linguistic control 01, 04 Sugeno System Inference Variables + Rules FIS Efficient inference 02, 03 p-Fuzzy Discrete Dynamics FIS + x\u2080 Trajectory Discrete-time evolution 01, 03 p-Fuzzy Continuous Dynamics FIS + x\u2080 Trajectory Continuous-time evolution 02 Fuzzy ODE Dynamics ODE + Fuzzy params Fuzzy trajectory Uncertainty propagation 04, 05"},{"location":"quick_start/#notebook-organization","title":"\ud83d\udcc2 Notebook Organization","text":"<p>All notebooks are available in the <code>notebooks_colab/</code> directory:</p> <pre><code>notebooks_colab/\n\u251c\u2500\u2500 01_fundamentals/          # Fuzzy logic basics\n\u2502   \u251c\u2500\u2500 01_membership_functions.ipynb\n\u2502   \u251c\u2500\u2500 02_fuzzy_operations.ipynb\n\u2502   \u251c\u2500\u2500 03_linguistic_variables.ipynb\n\u2502   \u2514\u2500\u2500 04_fuzzy_relations.ipynb\n\u2502\n\u251c\u2500\u2500 02_inference/              # Inference systems\n\u2502   \u251c\u2500\u2500 01_mamdani_tipping.ipynb\n\u2502   \u251c\u2500\u2500 02_sugeno_zero_order.ipynb\n\u2502   \u251c\u2500\u2500 03_sugeno_first_order.ipynb\n\u2502   \u2514\u2500\u2500 04_voting_prediction.ipynb\n\u2502\n\u251c\u2500\u2500 03_learning/               # Learning algorithms\n\u2502   \u251c\u2500\u2500 01_anfis_regression.ipynb\n\u2502   \u251c\u2500\u2500 02_anfis_classification.ipynb\n\u2502   \u251c\u2500\u2500 03_wang_mendel_regression.ipynb\n\u2502   \u251c\u2500\u2500 04_wang_mendel_classification.ipynb\n\u2502   \u2514\u2500\u2500 05_mamdani_learning_optimization.ipynb\n\u2502\n\u2514\u2500\u2500 04_dynamics/               # Dynamical systems\n    \u251c\u2500\u2500 01_pfuzzy_discrete_predator_prey.ipynb\n    \u251c\u2500\u2500 02_pfuzzy_continuous_predator_prey.ipynb\n    \u251c\u2500\u2500 03_pfuzzy_discrete_population.ipynb\n    \u251c\u2500\u2500 04_fuzzy_ode_logistic.ipynb\n    \u2514\u2500\u2500 05_fuzzy_ode_holling_tanner.ipynb\n</code></pre>"},{"location":"quick_start/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"quick_start/#installation","title":"Installation","text":"<pre><code>pip install pyfuzzy-toolbox\n</code></pre>"},{"location":"quick_start/#choose-your-path","title":"Choose Your Path","text":""},{"location":"quick_start/#1-i-want-to-learn-from-data","title":"1\ufe0f\u20e3 I want to learn from data","text":"<p>\u2192 Start with Wang-Mendel for quick rules, or ANFIS for accurate models</p>"},{"location":"quick_start/#2-i-want-to-build-a-control-system","title":"2\ufe0f\u20e3 I want to build a control system","text":"<p>\u2192 Start with Mamdani System for interpretability, or Sugeno System for efficiency</p>"},{"location":"quick_start/#3-i-want-to-model-temporal-dynamics","title":"3\ufe0f\u20e3 I want to model temporal dynamics","text":"<p>\u2192 Start with p-Fuzzy Discrete for discrete-time, or p-Fuzzy Continuous for continuous-time</p>"},{"location":"quick_start/#4-i-have-uncertain-parameters","title":"4\ufe0f\u20e3 I have uncertain parameters","text":"<p>\u2192 Start with Fuzzy ODE Solver</p>"},{"location":"quick_start/#learning-path","title":"\ud83d\udcd6 Learning Path","text":""},{"location":"quick_start/#beginner-path","title":"Beginner Path","text":"<ol> <li>Fundamentals \u2192 Notebooks <code>01_fundamentals/</code></li> <li>Inference \u2192 Mamdani System</li> <li>Learning \u2192 Wang-Mendel</li> </ol>"},{"location":"quick_start/#intermediate-path","title":"Intermediate Path","text":"<ol> <li>Advanced Inference \u2192 Sugeno System</li> <li>Learning \u2192 ANFIS</li> <li>Dynamics \u2192 p-Fuzzy Discrete</li> </ol>"},{"location":"quick_start/#advanced-path","title":"Advanced Path","text":"<ol> <li>Optimization \u2192 Mamdani Learning</li> <li>Continuous Dynamics \u2192 p-Fuzzy Continuous</li> <li>Uncertainty \u2192 Fuzzy ODE Solver</li> </ol>"},{"location":"quick_start/#common-use-cases","title":"\ud83d\udca1 Common Use Cases","text":""},{"location":"quick_start/#control-systems","title":"Control Systems","text":"<ul> <li>Tipping problem: Mamdani System \u2192 Notebook <code>02_inference/01_mamdani_tipping.ipynb</code></li> <li>Temperature control: Sugeno System \u2192 Notebook <code>02_inference/02_sugeno_zero_order.ipynb</code></li> </ul>"},{"location":"quick_start/#machine-learning","title":"Machine Learning","text":"<ul> <li>Regression: ANFIS \u2192 Notebook <code>03_learning/01_anfis_regression.ipynb</code></li> <li>Classification: Wang-Mendel \u2192 Notebook <code>03_learning/04_wang_mendel_classification.ipynb</code></li> </ul>"},{"location":"quick_start/#population-dynamics","title":"Population Dynamics","text":"<ul> <li>Predator-prey (discrete): p-Fuzzy Discrete \u2192 Notebook <code>04_dynamics/01_pfuzzy_discrete_predator_prey.ipynb</code></li> <li>Predator-prey (continuous): p-Fuzzy Continuous \u2192 Notebook <code>04_dynamics/02_pfuzzy_continuous_predator_prey.ipynb</code></li> </ul>"},{"location":"quick_start/#uncertainty-modeling","title":"Uncertainty Modeling","text":"<ul> <li>Logistic growth with fuzzy parameters: Fuzzy ODE Solver \u2192 Notebook <code>04_dynamics/04_fuzzy_ode_logistic.ipynb</code></li> <li>Epidemic model with uncertain transmission: Fuzzy ODE Solver \u2192 Notebook <code>04_dynamics/05_fuzzy_ode_holling_tanner.ipynb</code></li> </ul>"},{"location":"quick_start/#additional-resources","title":"\ud83d\udd17 Additional Resources","text":"<ul> <li>Main Documentation: https://1moi6.github.io/pyfuzzy-toolbox/</li> <li>GitHub Repository: https://github.com/1moi6/pyfuzzy-toolbox</li> <li>PyPI Package: https://pypi.org/project/pyfuzzy-toolbox/</li> <li>Issue Tracker: https://github.com/1moi6/pyfuzzy-toolbox/issues</li> </ul>"},{"location":"quick_start/#document-structure","title":"\ud83d\udcdd Document Structure","text":"<p>Each quickstart guide follows the same structure:</p> <ol> <li>Overview - What is it and why use it</li> <li>Basic Concepts - Key ideas and terminology</li> <li>Getting Started - Minimal working example</li> <li>Parameters - Detailed parameter descriptions</li> <li>Methods - Available methods and their uses</li> <li>Visualization - How to plot results</li> <li>Export - Saving results</li> <li>Complete Examples - Real-world applications</li> <li>Tips &amp; Best Practices - Expert recommendations</li> <li>Common Issues - Troubleshooting guide</li> <li>Advanced Features - Power-user techniques</li> <li>References - Academic citations</li> </ol>"},{"location":"quick_start/#quick-navigation","title":"\ud83c\udfaf Quick Navigation","text":"<ul> <li>ANFIS | Wang-Mendel | Mamdani Learning</li> <li>Mamdani System | Sugeno System</li> <li>p-Fuzzy Discrete | p-Fuzzy Continuous | Fuzzy ODE</li> </ul> <p>Generated with pyfuzzy-toolbox documentation system</p>"},{"location":"quick_start/anfis/","title":"ANFIS Quick Start Guide","text":""},{"location":"quick_start/anfis/#overview","title":"Overview","text":"<p>ANFIS (Adaptive Neuro-Fuzzy Inference System) is a hybrid learning system that combines neural networks and fuzzy logic for supervised learning tasks.</p>"},{"location":"quick_start/anfis/#1-instantiate-anfis-class","title":"1. Instantiate ANFIS Class","text":"<pre><code>from fuzzy_systems.learning import ANFIS\n\n# Create ANFIS instance\nanfis = ANFIS(\n    n_inputs=2,                    # Number of input variables\n    n_mfs=[3, 3],                  # Number of membership functions per input\n    mf_type='gaussmf',             # Type: 'gaussmf', 'gbellmf', or 'sigmf'\n    learning_rate=0.01,            # Learning rate for gradient descent\n    input_ranges=[(-5, 5), (-5, 5)],  # Optional: input bounds (default: (-8, 8))\n    lambda_l1=0.0,                 # L1 regularization (Lasso) on MF widths\n    lambda_l2=0.01,                # L2 regularization (Ridge) on MF widths\n    batch_size=32,                 # Batch size (None=batch, 1=SGD, 16-128=minibatch)\n    use_adaptive_lr=False,         # Use adaptive learning rate (slower but guaranteed convergence)\n    classification=False           # Set True for classification tasks\n)\n</code></pre>"},{"location":"quick_start/anfis/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>n_inputs</code>: Number of input features</li> <li><code>n_mfs</code>: Number of membership functions per input (int or list)</li> <li><code>mf_type</code>:</li> <li><code>'gaussmf'</code>: Gaussian (parameters: center, sigma)</li> <li><code>'gbellmf'</code>: Generalized bell (parameters: width, slope, center)</li> <li><code>'sigmf'</code>: Sigmoid (parameters: slope, center)</li> <li><code>learning_rate</code>: Step size for gradient descent (typical: 0.001-0.1)</li> <li><code>lambda_l1/lambda_l2</code>: Regularization coefficients to prevent overfitting</li> <li><code>batch_size</code>:</li> <li><code>None</code>: Full batch gradient descent</li> <li><code>1</code>: Stochastic gradient descent</li> <li><code>16-128</code>: Mini-batch (recommended)</li> </ul>"},{"location":"quick_start/anfis/#2-training-with-fit-hybrid-learning","title":"2. Training with <code>fit()</code> - Hybrid Learning","text":"<p>The <code>fit()</code> method uses hybrid learning: - Least Squares Estimation (LSE) for consequent parameters (fast, analytical) - Gradient Descent for premise parameters (membership functions)</p> <pre><code># Prepare data\nX_train = ...  # shape: (n_samples, n_inputs)\ny_train = ...  # shape: (n_samples,)\nX_val = ...    # Optional validation set\ny_val = ...\n\n# Train with hybrid learning\nanfis.fit(\n    X=X_train,\n    y=y_train,\n    epochs=100,                        # Number of training epochs\n    verbose=True,                      # Print progress\n    train_premises=True,               # Adjust membership functions (True) or only consequents (False)\n    X_val=X_val,                       # Optional: validation data\n    y_val=y_val,\n    early_stopping_patience=20,        # Stop if no improvement for N epochs\n    restore_best_weights=True          # Restore best model when early stopping\n)\n\n# Make predictions\ny_pred = anfis.predict(X_test)\n</code></pre>"},{"location":"quick_start/anfis/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>epochs</code>: Number of training iterations</li> <li><code>train_premises</code>:</li> <li><code>True</code>: Adjust both MFs and consequents (full hybrid learning)</li> <li><code>False</code>: Only adjust consequents via LSE (faster, simpler)</li> <li><code>early_stopping_patience</code>: Stop training if validation loss doesn't improve for N epochs</li> <li><code>restore_best_weights</code>: Automatically restore best model (requires validation data)</li> </ul>"},{"location":"quick_start/anfis/#when-to-use-fit","title":"When to Use <code>fit()</code>","text":"<p>\u2705 Good for: - Fast convergence with gradient-based optimization - When you have good initialization - Computational efficiency (especially with <code>train_premises=False</code>)</p> <p>\u26a0\ufe0f Limitations: - May converge to local minima - Requires tuning learning rate - Gradient vanishing/exploding in deep networks</p>"},{"location":"quick_start/anfis/#3-training-with-fit_metaheuristic-evolutionary-optimization","title":"3. Training with <code>fit_metaheuristic()</code> - Evolutionary Optimization","text":"<p>The <code>fit_metaheuristic()</code> method uses metaheuristic algorithms to optimize all parameters simultaneously: - PSO (Particle Swarm Optimization) - DE (Differential Evolution) - GA (Genetic Algorithm)</p> <pre><code># Train with metaheuristic optimization\nanfis.fit_metaheuristic(\n    X=X_train,\n    y=y_train,\n    optimizer='pso',                   # Optimizer: 'pso', 'de', or 'ga'\n    n_particles=30,                    # Population size\n    n_iterations=100,                  # Number of optimization iterations\n    verbose=True,                      # Print progress\n    X_val=X_val,                       # Optional: validation data\n    y_val=y_val,\n    early_stopping_patience=20,        # Stop if no improvement for N iterations\n    restore_best_weights=True,         # Restore best parameters\n    # PSO-specific parameters\n    w=0.7,                             # Inertia weight\n    c1=1.5,                            # Cognitive parameter\n    c2=1.5,                            # Social parameter\n    # DE-specific parameters\n    # F=0.8,                           # Differential weight\n    # CR=0.9,                          # Crossover probability\n    # GA-specific parameters\n    # crossover_rate=0.8,\n    # mutation_rate=0.1\n)\n\n# Make predictions\ny_pred = anfis.predict(X_test)\n</code></pre>"},{"location":"quick_start/anfis/#key-parameters_2","title":"Key Parameters","text":"<ul> <li><code>optimizer</code>: Choose optimization algorithm:</li> <li><code>'pso'</code>: Particle Swarm Optimization (recommended)</li> <li><code>'de'</code>: Differential Evolution (robust)</li> <li><code>'ga'</code>: Genetic Algorithm (exploratory)</li> <li><code>n_particles</code>: Population size (typical: 20-50)</li> <li><code>n_iterations</code>: Number of optimization iterations (typical: 50-200)</li> </ul>"},{"location":"quick_start/anfis/#optimizer-specific-parameters","title":"Optimizer-Specific Parameters","text":"<p>PSO: - <code>w</code>: Inertia weight (0.4-0.9, balances exploration/exploitation) - <code>c1</code>: Cognitive parameter (1.0-2.0, personal best attraction) - <code>c2</code>: Social parameter (1.0-2.0, global best attraction)</p> <p>DE: - <code>F</code>: Differential weight (0.5-1.0, mutation scale) - <code>CR</code>: Crossover probability (0.7-0.95, recombination rate)</p> <p>GA: - <code>crossover_rate</code>: Crossover probability (0.7-0.9) - <code>mutation_rate</code>: Mutation probability (0.01-0.1)</p>"},{"location":"quick_start/anfis/#when-to-use-fit_metaheuristic","title":"When to Use <code>fit_metaheuristic()</code>","text":"<p>\u2705 Good for: - Global optimization (avoids local minima) - No need to tune learning rates - Robust to initialization - Optimizes all parameters simultaneously</p> <p>\u26a0\ufe0f Limitations: - Slower than gradient descent - Requires more function evaluations - Stochastic (results may vary between runs)</p>"},{"location":"quick_start/anfis/#4-comparison-fit-vs-fit_metaheuristic","title":"4. Comparison: <code>fit()</code> vs <code>fit_metaheuristic()</code>","text":"Aspect <code>fit()</code> <code>fit_metaheuristic()</code> Algorithm Gradient Descent + LSE PSO/DE/GA Convergence Local optimum Global optimum Speed Fast Slower Stability Requires LR tuning Self-adaptive Consequents LSE (analytical) Evolutionary Premises Gradient (analytical) Evolutionary Regularization Widths only All parameters Best for Quick training, good init Global search, robust"},{"location":"quick_start/anfis/#5-complete-example","title":"5. Complete Example","text":"<pre><code>import numpy as np\nfrom fuzzy_systems.learning import ANFIS\nfrom sklearn.model_selection import train_test_split\n\n# Generate synthetic data\nX = np.random.uniform(-5, 5, (500, 2))\ny = np.sin(X[:, 0]) + np.cos(X[:, 1]) + np.random.normal(0, 0.1, 500)\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.2, random_state=42)\n\n# Create ANFIS\nanfis = ANFIS(\n    n_inputs=2,\n    n_mfs=[3, 3],\n    mf_type='gaussmf',\n    learning_rate=0.01,\n    lambda_l2=0.01,\n    batch_size=32\n)\n\n# Option 1: Train with hybrid learning\nanfis.fit(\n    X_train, y_train,\n    epochs=100,\n    X_val=X_val, y_val=y_val,\n    early_stopping_patience=20,\n    verbose=True\n)\n\n# Option 2: Train with metaheuristics (uncomment to use)\n# anfis.fit_metaheuristic(\n#     X_train, y_train,\n#     optimizer='pso',\n#     n_particles=30,\n#     n_iterations=100,\n#     X_val=X_val, y_val=y_val,\n#     verbose=True\n# )\n\n# Evaluate\ny_pred = anfis.predict(X_test)\nmse = np.mean((y_test - y_pred) ** 2)\nprint(f\"Test MSE: {mse:.4f}\")\n\n# Visualize (if 2D input)\nanfis.visualizar_mfs()  # Plot membership functions\n</code></pre>"},{"location":"quick_start/anfis/#6-tips-and-best-practices","title":"6. Tips and Best Practices","text":""},{"location":"quick_start/anfis/#initialization","title":"Initialization","text":"<ul> <li>Start with 2-5 membership functions per input</li> <li>Use Gaussian MFs (<code>gaussmf</code>) for smooth, general-purpose modeling</li> <li>Set appropriate <code>input_ranges</code> if you know the data bounds</li> </ul>"},{"location":"quick_start/anfis/#training","title":"Training","text":"<ul> <li>Use validation data to prevent overfitting</li> <li>Enable early stopping to save computation time</li> <li>Start with <code>train_premises=False</code> for quick baseline</li> </ul>"},{"location":"quick_start/anfis/#hyperparameter-tuning","title":"Hyperparameter Tuning","text":"<ul> <li>Learning rate: Start with 0.01, decrease if unstable</li> <li>Regularization: Use <code>lambda_l2=0.001-0.1</code> to prevent overfitting</li> <li>Batch size: 32-64 is usually optimal</li> </ul>"},{"location":"quick_start/anfis/#when-results-differ","title":"When Results Differ","text":"<p>If <code>fit()</code> and <code>fit_metaheuristic()</code> give very different results: - <code>fit()</code> likely found a local minimum - <code>fit_metaheuristic()</code> likely found a better global minimum - Try multiple random seeds for <code>fit_metaheuristic()</code> to verify consistency</p>"},{"location":"quick_start/anfis/#performance","title":"Performance","text":"<ul> <li>Speed: <code>fit()</code> with <code>train_premises=False</code> &gt; <code>fit()</code> &gt; <code>fit_metaheuristic()</code></li> <li>Accuracy: <code>fit_metaheuristic()</code> \u2265 <code>fit()</code> (but stochastic)</li> </ul>"},{"location":"quick_start/anfis/#7-troubleshooting","title":"7. Troubleshooting","text":"Problem Solution Training unstable Reduce learning rate, increase regularization Overfitting Add L2 regularization, use early stopping, reduce n_mfs Slow convergence Increase learning rate, use adaptive LR, try metaheuristics Poor performance Increase n_mfs, try different mf_type, use metaheuristics NaN values Check input ranges, reduce learning rate, add regularization"},{"location":"quick_start/anfis/#references","title":"References","text":"<ul> <li>Jang, J. S. (1993). \"ANFIS: adaptive-network-based fuzzy inference system.\" IEEE Transactions on Systems, Man, and Cybernetics, 23(3), 665-685.</li> </ul>"},{"location":"quick_start/fuzzy_ode/","title":"Fuzzy ODE Solver Quick Start Guide","text":""},{"location":"quick_start/fuzzy_ode/#overview","title":"Overview","text":"<p>FuzzyODESolver solves ordinary differential equations (ODEs) with fuzzy initial conditions and/or fuzzy parameters, computing solutions as \u03b1-level sets that form fuzzy envelopes over time.</p> <p>Key Concept: <pre><code>dy/dt = f(t, y, parameters)\n\nWhere:\n- y\u2080 can be fuzzy (e.g., \"around 10\")\n- parameters can be fuzzy (e.g., \"growth rate \u2248 0.5\")\n- Solution y(t) is fuzzy at each time point\n</code></pre></p> <p>Applications: - Modeling uncertainty in initial conditions - Systems with imprecise parameters - Epidemiological models with uncertain rates - Population dynamics with fuzzy carrying capacity - Any ODE with incomplete/imprecise information</p> <p>Advantages: - Quantify uncertainty propagation - Multiple scenarios in single solution - \u03b1-level interpretation (confidence intervals) - No need for probabilistic assumptions</p>"},{"location":"quick_start/fuzzy_ode/#1-basic-concepts","title":"1. Basic Concepts","text":""},{"location":"quick_start/fuzzy_ode/#what-is-a-fuzzy-ode","title":"What is a Fuzzy ODE?","text":"<p>A fuzzy ODE is a differential equation where: 1. Initial conditions are fuzzy numbers (not single values) 2. Parameters can be fuzzy 3. Solution is a fuzzy-valued function</p> <p>Example: <pre><code>Regular ODE:  dy/dt = 0.5y(1 - y/100),  y(0) = 10\nFuzzy ODE:    dy/dt = r\u00b7y(1 - y/K),     y\u2080 \u2248 10 \u00b1 2, r \u2248 0.5 \u00b1 0.05\n</code></pre></p>"},{"location":"quick_start/fuzzy_ode/#fuzzy-numbers","title":"Fuzzy Numbers","text":"<p>Fuzzy numbers represent imprecise values using membership functions:</p> <pre><code>from fuzzy_systems.dynamics.fuzzy_ode import FuzzyNumber\n\n# Triangular: \"approximately 10, spread 2\"\nnum1 = FuzzyNumber.triangular(center=10, spread=2)\n# Support: [8, 12], peak at 10\n\n# Gaussian: \"around 50, sigma 5\"\nnum2 = FuzzyNumber.gaussian(mean=50, sigma=5)\n\n# Trapezoidal: \"between 20-30, certainty 23-27\"\nnum3 = FuzzyNumber.trapezoidal(a=20, b=23, c=27, d=30)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#-cuts-alpha-levels","title":"\u03b1-Cuts (Alpha Levels)","text":"<p>An \u03b1-cut extracts an interval from a fuzzy number at confidence level \u03b1:</p> <pre><code>\u03b1 = 1.0 \u2192 Core (most likely values)\n\u03b1 = 0.5 \u2192 Medium confidence\n\u03b1 = 0.0 \u2192 Support (all possible values)\n</code></pre> <p>The solver computes \u03b1-cuts for multiple levels, creating fuzzy envelopes.</p>"},{"location":"quick_start/fuzzy_ode/#2-creating-fuzzy-numbers","title":"2. Creating Fuzzy Numbers","text":""},{"location":"quick_start/fuzzy_ode/#triangular-fuzzy-numbers","title":"Triangular Fuzzy Numbers","text":"<pre><code>from fuzzy_systems.dynamics.fuzzy_ode import FuzzyNumber\n\n# Symmetric triangular\ny0 = FuzzyNumber.triangular(center=10, spread=2)\n# Represents: \"around 10, \u00b12\"\n# Support: [8, 12], peak at 10\n\n# Check membership\nprint(y0.membership(10))    # 1.0 (core)\nprint(y0.membership(9))     # 0.5\nprint(y0.membership(8))     # 0.0 (boundary)\n\n# Extract \u03b1-cut\ninterval = y0.alpha_cut(alpha=0.5)\nprint(interval)  # (9.0, 11.0)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#gaussian-fuzzy-numbers","title":"Gaussian Fuzzy Numbers","text":"<pre><code># Gaussian: smoother, no hard boundaries\nparam = FuzzyNumber.gaussian(\n    mean=0.5,\n    sigma=0.1,\n    n_sigmas=3  # Support extends 3 sigmas\n)\n# Support: [0.2, 0.8] (3\u03c3 from mean)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#trapezoidal-fuzzy-numbers","title":"Trapezoidal Fuzzy Numbers","text":"<pre><code># Trapezoidal: plateau in the middle\ncapacity = FuzzyNumber.trapezoidal(\n    a=80,   # Left boundary\n    b=90,   # Start of plateau\n    c=110,  # End of plateau\n    d=120   # Right boundary\n)\n# Core (\u03b1=1.0): [90, 110]\n# Support (\u03b1=0.0): [80, 120]\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#3-defining-the-ode-function","title":"3. Defining the ODE Function","text":"<p>The ODE function must accept <code>(t, y, **params)</code>:</p> <pre><code>def my_ode(t, y, r, K):\n    \"\"\"\n    ODE: dy/dt = r * y * (1 - y/K)\n\n    Args:\n        t: Time (scalar)\n        y: State vector (array)\n        r: Parameter 1\n        K: Parameter 2\n\n    Returns:\n        dy/dt (array, same shape as y)\n    \"\"\"\n    return r * y * (1 - y / K)\n</code></pre> <p>Important: - Signature must be <code>(t, y, **params)</code> - <code>y</code> is always an array (even for 1D systems) - Return array with same shape as <code>y</code> - Parameters passed via <code>**params</code> (unpacked dict)</p>"},{"location":"quick_start/fuzzy_ode/#4-creating-the-solver","title":"4. Creating the Solver","text":""},{"location":"quick_start/fuzzy_ode/#basic-setup","title":"Basic Setup","text":"<pre><code>from fuzzy_systems.dynamics.fuzzy_ode import FuzzyODESolver, FuzzyNumber\n\n# Define ODE\ndef logistic(t, y, r, K):\n    return r * y * (1 - y / K)\n\n# Create fuzzy initial condition\ny0_fuzzy = FuzzyNumber.triangular(center=10, spread=2)\n\n# Create fuzzy parameter\nr_fuzzy = FuzzyNumber.triangular(center=0.5, spread=0.05)\n\n# Create solver\nsolver = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 50),\n    initial_condition=[y0_fuzzy],       # List of FuzzyNumber or float\n    params={'r': r_fuzzy, 'K': 100},    # Dict with FuzzyNumber or float\n    n_alpha_cuts=11,                    # Number of \u03b1-levels (2-50)\n    method='RK45',                      # Integration method\n    var_names=['population']            # Variable names (optional)\n)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#solver-parameters","title":"Solver Parameters","text":"<ul> <li><code>ode_func</code>: ODE function with signature <code>(t, y, **params)</code></li> <li><code>t_span</code>: Time interval <code>(t_start, t_end)</code></li> <li><code>initial_condition</code>: List of initial values (FuzzyNumber or float)</li> <li><code>params</code>: Dict of parameters (FuzzyNumber or float)</li> <li><code>n_alpha_cuts</code>: Number of \u03b1-levels (default: 11)</li> <li>More = smoother envelopes, slower computation</li> <li>Typical range: 5-25</li> <li><code>method</code>: Integration method (default: 'RK45')</li> <li>Options: 'RK45', 'RK23', 'DOP853', 'Radau', 'BDF', 'LSODA'</li> <li>RK45 = good default (Runge-Kutta 4<sup>th</sup>/5<sup>th</sup> order)</li> <li><code>t_eval</code>: Time points for evaluation (optional)</li> <li>If <code>None</code>, uses 100 points uniformly spaced</li> <li><code>n_jobs</code>: Parallel workers (default: -1 = all cores)</li> <li><code>rtol</code>, <code>atol</code>: Numerical tolerances (default: 1e-6, 1e-9)</li> <li><code>var_names</code>: List of variable names for plots</li> </ul>"},{"location":"quick_start/fuzzy_ode/#5-solving-fuzzy-odes","title":"5. Solving Fuzzy ODEs","text":""},{"location":"quick_start/fuzzy_ode/#method-1-standard-default","title":"Method 1: Standard (Default)","text":"<pre><code># Solve with standard method\nsolution = solver.solve(\n    method='standard',\n    n_grid_points=20,  # Points per dimension per \u03b1-level\n    verbose=True\n)\n</code></pre> <p>Characteristics: - Most accurate - Slowest (explores full grid) - Best for low-dimensional problems (1-3 variables) - Grid size: <code>n_grid_points^(n_vars + n_fuzzy_params)</code> per \u03b1</p>"},{"location":"quick_start/fuzzy_ode/#method-2-monte-carlo-recommended-for-high-dimensions","title":"Method 2: Monte Carlo (Recommended for High Dimensions)","text":"<pre><code># Solve with Monte Carlo sampling\nsolution = solver.solve(\n    method='monte_carlo',\n    n_samples=1000,     # Number of random samples\n    random_seed=42,     # For reproducibility\n    verbose=True\n)\n</code></pre> <p>Characteristics: - Fastest for high-dimensional problems - Scalable (10-400x faster in high dimensions) - Stochastic (results vary slightly) - Best for: many fuzzy parameters, multi-variable systems</p>"},{"location":"quick_start/fuzzy_ode/#method-3-hierarchical","title":"Method 3: Hierarchical","text":"<pre><code># Solve with hierarchical optimization\nsolution = solver.solve(\n    method='hierarchical',\n    verbose=True\n)\n</code></pre> <p>Characteristics: - 3-5x faster than standard - Deterministic (same results every time) - Good middle ground - Reuses computations from higher \u03b1-levels</p>"},{"location":"quick_start/fuzzy_ode/#6-working-with-solutions","title":"6. Working with Solutions","text":""},{"location":"quick_start/fuzzy_ode/#solution-object","title":"Solution Object","text":"<pre><code># Solve\nsolution = solver.solve(method='monte_carlo')\n\n# Access attributes\nprint(solution.t)            # Time points\nprint(solution.y_min.shape)  # (n_alpha, n_vars, n_time)\nprint(solution.y_max.shape)  # (n_alpha, n_vars, n_time)\nprint(solution.alphas)       # \u03b1-levels used\nprint(solution.var_names)    # Variable names\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#get-specific-level","title":"Get Specific \u03b1-Level","text":"<pre><code># Extract envelope for specific \u03b1\ny_min_05, y_max_05 = solution.get_alpha_level(alpha=0.5)\n# y_min_05.shape: (n_vars, n_time)\n# y_max_05.shape: (n_vars, n_time)\n\n# Plot specific \u03b1-level\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 6))\nplt.fill_between(solution.t, y_min_05[0], y_max_05[0],\n                 alpha=0.3, label='\u03b1=0.5')\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#7-visualization","title":"7. Visualization","text":""},{"location":"quick_start/fuzzy_ode/#plot-fuzzy-solution","title":"Plot Fuzzy Solution","text":"<pre><code># Plot with all \u03b1-levels\nsolution.plot(\n    var_idx=0,                # Variable index (0 for first)\n    alpha_levels=None,        # None = all, or list like [0.0, 0.5, 1.0]\n    show=True\n)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#custom-multi-variable-plot","title":"Custom Multi-Variable Plot","text":"<pre><code>import matplotlib.pyplot as plt\n\n# For multi-variable system\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\nfor var_idx in range(2):\n    ax = axes[var_idx]\n\n    # Plot each \u03b1-level\n    cmap = plt.cm.Blues\n    for i, alpha in enumerate(solution.alphas):\n        y_min, y_max = solution.get_alpha_level(alpha)\n        color = cmap(0.3 + 0.7 * alpha)\n\n        ax.fill_between(\n            solution.t,\n            y_min[var_idx],\n            y_max[var_idx],\n            alpha=0.3,\n            color=color,\n            label=f'\u03b1={alpha:.1f}' if i % 3 == 0 else None\n        )\n\n    ax.set_xlabel('Time', fontsize=12)\n    ax.set_ylabel(solution.var_names[var_idx], fontsize=12)\n    ax.set_title(f'{solution.var_names[var_idx]} Evolution')\n    ax.legend()\n    ax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#8-exporting-results","title":"8. Exporting Results","text":""},{"location":"quick_start/fuzzy_ode/#export-to-csv","title":"Export to CSV","text":"<pre><code># Export specific \u03b1-level to CSV\nsolution.to_csv('fuzzy_solution.csv', alpha=0.5)\n\n# Export with European format\nsolution.to_csv('solution.csv', alpha=1.0, sep=';', decimal=',')\n</code></pre> <p>CSV Format: <pre><code>time,population_min,population_max\n0.000000,8.000000,12.000000\n0.500000,8.234100,12.765900\n1.000000,8.521234,13.478766\n...\n</code></pre></p>"},{"location":"quick_start/fuzzy_ode/#export-to-dataframe","title":"Export to DataFrame","text":"<pre><code># Convert to pandas DataFrame\ndf = solution.to_dataframe(alpha=0.5)\nprint(df.head())\n\n# Access metadata\nprint(df.attrs['alpha_level'])\nprint(df.attrs['n_alpha_levels'])\nprint(df.attrs['var_names'])\n\n# Further processing\ndf['y_mean'] = (df['y0_min'] + df['y0_max']) / 2\ndf['y_width'] = df['y0_max'] - df['y0_min']\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#9-complete-example-logistic-growth","title":"9. Complete Example: Logistic Growth","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems.dynamics.fuzzy_ode import FuzzyODESolver, FuzzyNumber\n\n# ============================================================================\n# Define ODE: Logistic growth model\n# ============================================================================\ndef logistic(t, y, r, K):\n    \"\"\"dy/dt = r * y * (1 - y/K)\"\"\"\n    return r * y * (1 - y / K)\n\n# ============================================================================\n# Scenario A: Fuzzy Initial Condition Only\n# ============================================================================\ny0_fuzzy = FuzzyNumber.triangular(center=10, spread=4)\n\nsolver_a = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 50),\n    initial_condition=[y0_fuzzy],\n    params={'r': 0.2, 'K': 100},\n    n_alpha_cuts=15,\n    var_names=['population']\n)\n\nsol_a = solver_a.solve(method='monte_carlo', n_samples=1000, verbose=True)\nsol_a.plot()\nplt.title('Scenario A: Fuzzy Initial Condition')\n\n# ============================================================================\n# Scenario B: Fuzzy Carrying Capacity\n# ============================================================================\nK_fuzzy = FuzzyNumber.triangular(center=100, spread=20)\n\nsolver_b = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 50),\n    initial_condition=[10.0],  # Crisp y0\n    params={'r': 0.2, 'K': K_fuzzy},\n    n_alpha_cuts=15,\n    var_names=['population']\n)\n\nsol_b = solver_b.solve(method='monte_carlo', verbose=True)\nsol_b.plot()\nplt.title('Scenario B: Fuzzy Carrying Capacity')\n\n# ============================================================================\n# Scenario C: Fuzzy Growth Rate\n# ============================================================================\nr_fuzzy = FuzzyNumber.triangular(center=0.2, spread=0.04)\n\nsolver_c = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 50),\n    initial_condition=[10.0],\n    params={'r': r_fuzzy, 'K': 100},\n    n_alpha_cuts=15,\n    var_names=['population']\n)\n\nsol_c = solver_c.solve(method='monte_carlo', verbose=True)\nsol_c.plot()\nplt.title('Scenario C: Fuzzy Growth Rate')\n\n# ============================================================================\n# Scenario D: Everything Fuzzy\n# ============================================================================\ny0_fuzzy_d = FuzzyNumber.triangular(center=10, spread=4)\nr_fuzzy_d = FuzzyNumber.triangular(center=0.2, spread=0.04)\nK_fuzzy_d = FuzzyNumber.triangular(center=100, spread=20)\n\nsolver_d = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 50),\n    initial_condition=[y0_fuzzy_d],\n    params={'r': r_fuzzy_d, 'K': K_fuzzy_d},\n    n_alpha_cuts=15,\n    var_names=['population']\n)\n\nsol_d = solver_d.solve(method='monte_carlo', n_samples=2000, verbose=True)\nsol_d.plot()\nplt.title('Scenario D: All Parameters Fuzzy')\n\n# ============================================================================\n# Compare All Scenarios\n# ============================================================================\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\naxes = axes.flatten()\n\nscenarios = [\n    (sol_a, 'Scenario A: y\u2080 Fuzzy'),\n    (sol_b, 'Scenario B: K Fuzzy'),\n    (sol_c, 'Scenario C: r Fuzzy'),\n    (sol_d, 'Scenario D: All Fuzzy')\n]\n\nfor ax, (sol, title) in zip(axes, scenarios):\n    cmap = plt.cm.Blues\n    for i, alpha in enumerate(sol.alphas):\n        y_min, y_max = sol.get_alpha_level(alpha)\n        color = cmap(0.3 + 0.7 * alpha)\n        ax.fill_between(sol.t, y_min[0], y_max[0],\n                       alpha=0.3, color=color)\n\n    ax.set_xlabel('Time', fontsize=11)\n    ax.set_ylabel('Population', fontsize=11)\n    ax.set_title(title, fontweight='bold')\n    ax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n# Export results\nsol_d.to_csv('logistic_fuzzy_all.csv', alpha=0.5)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#10-complete-example-sir-epidemic-model","title":"10. Complete Example: SIR Epidemic Model","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems.dynamics.fuzzy_ode import FuzzyODESolver, FuzzyNumber\n\n# ============================================================================\n# SIR Model with Fuzzy Parameters\n# ============================================================================\ndef sir_model(t, y, beta, gamma):\n    \"\"\"\n    SIR epidemic model\n\n    S: Susceptible\n    I: Infected\n    R: Recovered\n\n    dS/dt = -beta * S * I\n    dI/dt = beta * S * I - gamma * I\n    dR/dt = gamma * I\n    \"\"\"\n    S, I, R = y\n    N = S + I + R  # Total population (constant)\n\n    dS = -beta * S * I / N\n    dI = beta * S * I / N - gamma * I\n    dR = gamma * I\n\n    return np.array([dS, dI, dR])\n\n# ============================================================================\n# Setup with Fuzzy Transmission Rate\n# ============================================================================\n# Initial conditions (crisp)\nS0 = 990.0\nI0 = 10.0\nR0 = 0.0\n\n# Fuzzy transmission rate: \"beta around 0.5 \u00b1 0.1\"\nbeta_fuzzy = FuzzyNumber.triangular(center=0.5, spread=0.1)\n\n# Recovery rate (crisp): 1/14 (14-day recovery)\ngamma_crisp = 1.0 / 14.0\n\n# Create solver\nsolver = FuzzyODESolver(\n    ode_func=sir_model,\n    t_span=(0, 160),\n    initial_condition=[S0, I0, R0],\n    params={'beta': beta_fuzzy, 'gamma': gamma_crisp},\n    n_alpha_cuts=11,\n    var_names=['Susceptible', 'Infected', 'Recovered']\n)\n\n# Solve\nsolution = solver.solve(method='monte_carlo', n_samples=1500, verbose=True)\n\n# ============================================================================\n# Visualize All Compartments\n# ============================================================================\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\ncompartments = ['Susceptible', 'Infected', 'Recovered']\ncolors_map = [plt.cm.Reds, plt.cm.Oranges, plt.cm.Greens]\n\nfor idx, (ax, name, cmap) in enumerate(zip(axes, compartments, colors_map)):\n    for i, alpha in enumerate(solution.alphas):\n        y_min, y_max = solution.get_alpha_level(alpha)\n        color = cmap(0.3 + 0.7 * alpha)\n        ax.fill_between(\n            solution.t,\n            y_min[idx],\n            y_max[idx],\n            alpha=0.4,\n            color=color,\n            label=f'\u03b1={alpha:.1f}' if i % 3 == 0 else None\n        )\n\n    ax.set_xlabel('Days', fontsize=12)\n    ax.set_ylabel('Population', fontsize=12)\n    ax.set_title(f'{name} Population', fontweight='bold', fontsize=13)\n    ax.legend(loc='best')\n    ax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n# ============================================================================\n# Export Peak Infection Time (\u03b1=0.5)\n# ============================================================================\ny_min_05, y_max_05 = solution.get_alpha_level(alpha=0.5)\nI_envelope = (y_min_05[1] + y_max_05[1]) / 2\npeak_time = solution.t[np.argmax(I_envelope)]\npeak_value = np.max(I_envelope)\n\nprint(f\"\\nPeak Infection (\u03b1=0.5):\")\nprint(f\"  Time: {peak_time:.1f} days\")\nprint(f\"  Value: {peak_value:.0f} infected\")\n\n# Export\nsolution.to_csv('sir_fuzzy_beta.csv', alpha=0.5)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#11-tips-and-best-practices","title":"11. Tips and Best Practices","text":""},{"location":"quick_start/fuzzy_ode/#choosing-the-right-method","title":"Choosing the Right Method","text":"Method Best For Speed Accuracy Stochastic Standard 1-2 variables, few fuzzy params Slow Highest No Monte Carlo High dimensions, many fuzzy params Fast Good Yes Hierarchical Medium problems, deterministic Medium High No <p>Recommendations: - 1-2 fuzzy inputs \u2192 <code>standard</code> (n_grid_points=20) - 3+ fuzzy inputs \u2192 <code>monte_carlo</code> (n_samples=1000-5000) - Need deterministic \u2192 <code>hierarchical</code></p>"},{"location":"quick_start/fuzzy_ode/#choosing-n_alpha_cuts","title":"Choosing n_alpha_cuts","text":"<pre><code># Coarse (fast, less smooth)\nn_alpha_cuts=5   # [0.0, 0.25, 0.5, 0.75, 1.0]\n\n# Standard (good balance)\nn_alpha_cuts=11  # [0.0, 0.1, ..., 0.9, 1.0]\n\n# Fine (smooth, slower)\nn_alpha_cuts=25  # [0.0, 0.04, ..., 0.96, 1.0]\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#choosing-fuzzy-number-types","title":"Choosing Fuzzy Number Types","text":"<p>Triangular: - Simple, easy to interpret - Use when: \"approximately X, \u00b1Y\" - Example: <code>FuzzyNumber.triangular(center=10, spread=2)</code></p> <p>Gaussian: - Smooth, no hard boundaries - Use when: uncertainty is continuous - Example: <code>FuzzyNumber.gaussian(mean=10, sigma=2)</code></p> <p>Trapezoidal: - Plateau of maximum certainty - Use when: \"between X and Y, most likely Z to W\" - Example: <code>FuzzyNumber.trapezoidal(a=8, b=9, c=11, d=12)</code></p>"},{"location":"quick_start/fuzzy_ode/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Fast exploration (low accuracy)\nsol = solver.solve(method='monte_carlo', n_samples=500)\n\n# Standard (good balance)\nsol = solver.solve(method='monte_carlo', n_samples=2000)\n\n# High accuracy (slower)\nsol = solver.solve(method='monte_carlo', n_samples=10000)\n\n# Use parallel processing (default)\nsolver = FuzzyODESolver(..., n_jobs=-1)  # All cores\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#numerical-stability","title":"Numerical Stability","text":"<pre><code># Stiff systems: use appropriate solver\nsolver = FuzzyODESolver(\n    ...,\n    method='BDF',  # Better for stiff ODEs\n    rtol=1e-5,\n    atol=1e-8\n)\n\n# Non-stiff, high accuracy\nsolver = FuzzyODESolver(\n    ...,\n    method='DOP853',  # 8th order Runge-Kutta\n    rtol=1e-8,\n    atol=1e-10\n)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#12-common-patterns","title":"12. Common Patterns","text":""},{"location":"quick_start/fuzzy_ode/#pattern-1-uncertain-initial-conditions","title":"Pattern 1: Uncertain Initial Conditions","text":"<pre><code># Measurement uncertainty in starting population\ny0 = FuzzyNumber.gaussian(mean=100, sigma=10)\n\nsolver = FuzzyODESolver(\n    ode_func=my_ode,\n    t_span=(0, 50),\n    initial_condition=[y0],\n    params={'rate': 0.1}  # Known parameter\n)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#pattern-2-parameter-uncertainty","title":"Pattern 2: Parameter Uncertainty","text":"<pre><code># Unknown growth rate, measured as \"around 0.5\"\nrate = FuzzyNumber.triangular(center=0.5, spread=0.1)\n\nsolver = FuzzyODESolver(\n    ode_func=my_ode,\n    t_span=(0, 50),\n    initial_condition=[100.0],  # Known initial condition\n    params={'rate': rate}\n)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#pattern-3-multiple-uncertainties","title":"Pattern 3: Multiple Uncertainties","text":"<pre><code># Both initial condition and parameters are fuzzy\ny0 = FuzzyNumber.triangular(center=100, spread=20)\nrate = FuzzyNumber.triangular(center=0.5, spread=0.1)\ncapacity = FuzzyNumber.gaussian(mean=1000, sigma=100)\n\nsolver = FuzzyODESolver(\n    ode_func=logistic,\n    t_span=(0, 50),\n    initial_condition=[y0],\n    params={'r': rate, 'K': capacity}\n)\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#13-common-issues-and-solutions","title":"13. Common Issues and Solutions","text":"Problem Cause Solution Very wide envelopes Too much uncertainty Reduce fuzzy spreads, check \u03b1-cuts Solution doesn't match crisp Numerical issues Increase n_samples (MC) or n_grid_points (standard) Slow computation High dimensions Use <code>method='monte_carlo'</code> with fewer samples Envelopes cross \u03b1-levels not monotonic Check fuzzy number definitions Memory error Too many grid points Reduce n_grid_points or use Monte Carlo NaN values ODE solver failed Check ODE function, adjust rtol/atol"},{"location":"quick_start/fuzzy_ode/#debugging-tips","title":"Debugging Tips","text":"<pre><code># Test ODE function with crisp values\ny_test = np.array([10.0])\ndydt = my_ode(0, y_test, r=0.5, K=100)\nprint(f\"dy/dt at t=0: {dydt}\")\n\n# Test fuzzy number\ny0 = FuzzyNumber.triangular(center=10, spread=2)\nprint(f\"Support: {y0.support}\")\nprint(f\"\u03b1=0.5 cut: {y0.alpha_cut(0.5)}\")\nprint(f\"Membership at 10: {y0.membership(10)}\")\n\n# Solve with verbose\nsol = solver.solve(method='monte_carlo', verbose=True)\n# Shows progress and statistics\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#14-advanced-multi-variable-systems","title":"14. Advanced: Multi-Variable Systems","text":"<pre><code># Lotka-Volterra Predator-Prey with fuzzy parameters\ndef lotka_volterra(t, y, alpha, beta, delta, gamma):\n    \"\"\"\n    Predator-prey model\n    x: prey, y: predator\n    \"\"\"\n    x, y_pred = y\n    dx = alpha * x - beta * x * y_pred\n    dy = delta * x * y_pred - gamma * y_pred\n    return np.array([dx, dy])\n\n# Fuzzy parameters\nalpha_fuzzy = FuzzyNumber.triangular(center=1.0, spread=0.1)\nbeta_fuzzy = FuzzyNumber.triangular(center=0.1, spread=0.02)\ndelta_fuzzy = FuzzyNumber.triangular(center=0.075, spread=0.015)\ngamma_fuzzy = FuzzyNumber.triangular(center=1.5, spread=0.15)\n\n# Fuzzy initial conditions\nx0_fuzzy = FuzzyNumber.triangular(center=40, spread=5)\ny0_fuzzy = FuzzyNumber.triangular(center=9, spread=2)\n\nsolver = FuzzyODESolver(\n    ode_func=lotka_volterra,\n    t_span=(0, 50),\n    initial_condition=[x0_fuzzy, y0_fuzzy],\n    params={\n        'alpha': alpha_fuzzy,\n        'beta': beta_fuzzy,\n        'delta': delta_fuzzy,\n        'gamma': gamma_fuzzy\n    },\n    n_alpha_cuts=11,\n    var_names=['Prey', 'Predator']\n)\n\n# Use Monte Carlo for high-dimensional problem\nsolution = solver.solve(method='monte_carlo', n_samples=5000, verbose=True)\n\n# Plot both variables\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\nfor idx, name in enumerate(['Prey', 'Predator']):\n    solution.plot(var_idx=idx, ax=axes[idx], show=False)\n    axes[idx].set_title(f'{name} Population')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"quick_start/fuzzy_ode/#15-comparison-with-other-approaches","title":"15. Comparison with Other Approaches","text":""},{"location":"quick_start/fuzzy_ode/#fuzzy-ode-vs-monte-carlo-simulation","title":"Fuzzy ODE vs Monte Carlo Simulation","text":"Aspect Fuzzy ODE Monte Carlo Uncertainty Possibilistic Probabilistic Input Fuzzy numbers Probability distributions Output \u03b1-level envelopes Confidence intervals Assumptions None (membership) Statistical (distribution) Interpretation Possibility Probability"},{"location":"quick_start/fuzzy_ode/#when-to-use-fuzzy-ode","title":"When to Use Fuzzy ODE","text":"<p>\u2705 Use Fuzzy ODE when: - Data is imprecise, not random - Expert knowledge is qualitative (\"around\", \"approximately\") - No probability distributions available - Want worst-case/best-case scenarios</p> <p>\u274c Use Monte Carlo when: - Have probability distributions - Data is from random processes - Need statistical confidence intervals</p>"},{"location":"quick_start/fuzzy_ode/#references","title":"References","text":"<ul> <li>Barros, L. C., Bassanezi, R. C., &amp; Lodwick, W. A. (2017). A First Course in Fuzzy Logic, Fuzzy Dynamical Systems, and Biomathematics. Springer.</li> <li>Kaleva, O. (1987). \"Fuzzy differential equations.\" Fuzzy Sets and Systems, 24(3), 301-317.</li> <li>Bede, B., &amp; Gal, S. G. (2005). \"Generalizations of the differentiability of fuzzy-number-valued functions with applications to fuzzy differential equations.\" Fuzzy Sets and Systems, 151(3), 581-599.</li> </ul>"},{"location":"quick_start/mamdani_learning/","title":"Mamdani Learning Quick Start Guide","text":""},{"location":"quick_start/mamdani_learning/#overview","title":"Overview","text":"<p>MamdaniLearning is a class for learning optimal fuzzy rules in Mamdani systems using metaheuristic optimization. Unlike Wang-Mendel (which extracts rules from data in a single pass), MamdaniLearning iteratively searches for the best rule combinations using evolutionary algorithms.</p> <p>Key Features: - Optimizes rule consequents (outputs) for existing membership functions - Supports multiple metaheuristic algorithms (SA, GA, PSO, DE) - Pre-computes rule activations for efficiency - Works with any pre-configured Mamdani system - No gradient computation required</p>"},{"location":"quick_start/mamdani_learning/#algorithm-overview","title":"Algorithm Overview","text":""},{"location":"quick_start/mamdani_learning/#what-mamdanilearning-does","title":"What MamdaniLearning Does","text":"<ol> <li>Takes a Mamdani system with defined membership functions for inputs and outputs</li> <li>Generates all possible rules from the Cartesian product of input MFs</li> <li>Optimizes which output MF each rule should use as its consequent</li> <li>Uses metaheuristics to search the discrete space of possible rule combinations</li> </ol>"},{"location":"quick_start/mamdani_learning/#what-it-optimizes","title":"What It Optimizes","text":"<ul> <li>Input: Pre-defined membership functions (triangular, trapezoidal, etc.)</li> <li>Output: Assignment of output terms to rules (e.g., Rule 1 \u2192 \"high\", Rule 2 \u2192 \"low\")</li> <li>Objective: Minimize prediction error (RMSE) on training data</li> </ul>"},{"location":"quick_start/mamdani_learning/#difference-from-other-methods","title":"Difference from Other Methods","text":"Method What it learns Algorithm Speed Wang-Mendel Selects rules from data One-pass extraction Very fast MamdaniLearning Optimizes rule consequents Metaheuristics Moderate ANFIS Adjusts MF parameters + consequents Gradient descent + LSE Slow"},{"location":"quick_start/mamdani_learning/#1-setup-create-and-configure-mamdani-system","title":"1. Setup: Create and Configure Mamdani System","text":"<p>Before using MamdaniLearning, you must create a Mamdani system with all membership functions defined.</p> <pre><code>from fuzzy_systems.inference import MamdaniSystem\nfrom fuzzy_systems.learning import MamdaniLearning\nimport numpy as np\n\n# Create Mamdani system\nsystem = MamdaniSystem()\n\n# Add input variables\nsystem.add_input('temperature', (0, 40))\nsystem.add_input('humidity', (0, 100))\n\n# Add output variable\nsystem.add_output('fan_speed', (0, 100))\n\n# Define INPUT membership functions\n# Temperature: cold, warm, hot\nsystem.add_term('temperature', 'cold', 'trapezoidal', (0, 0, 10, 20))\nsystem.add_term('temperature', 'warm', 'triangular', (15, 25, 35))\nsystem.add_term('temperature', 'hot', 'trapezoidal', (30, 35, 40, 40))\n\n# Humidity: dry, normal, wet\nsystem.add_term('humidity', 'dry', 'trapezoidal', (0, 0, 20, 40))\nsystem.add_term('humidity', 'normal', 'triangular', (30, 50, 70))\nsystem.add_term('humidity', 'wet', 'trapezoidal', (60, 80, 100, 100))\n\n# Define OUTPUT membership functions\n# Fan speed: low, medium, high\nsystem.add_term('fan_speed', 'low', 'triangular', (0, 0, 50))\nsystem.add_term('fan_speed', 'medium', 'triangular', (25, 50, 75))\nsystem.add_term('fan_speed', 'high', 'triangular', (50, 100, 100))\n</code></pre>"},{"location":"quick_start/mamdani_learning/#important-notes","title":"Important Notes","text":"<ul> <li>All membership functions must be defined before learning</li> <li>The learner will create all possible rules (Cartesian product)</li> <li>For 3 MFs per input \u00d7 2 inputs = 3\u00d73 = 9 rules total</li> <li>Each rule can have any of the 3 output terms (low/medium/high)</li> <li>MamdaniLearning finds the best assignment of outputs to rules</li> </ul>"},{"location":"quick_start/mamdani_learning/#2-instantiate-mamdanilearning-class","title":"2. Instantiate MamdaniLearning Class","text":"<pre><code># Create learner\nlearner = MamdaniLearning(\n    fis=system,           # Pre-configured Mamdani system\n    num_points=1000,      # Discretization points for output universe\n    verbose=True          # Print progress information\n)\n</code></pre>"},{"location":"quick_start/mamdani_learning/#parameters","title":"Parameters","text":"<ul> <li><code>fis</code>: MamdaniSystem</li> <li>Must have all input/output variables and terms defined</li> <li> <p>Rules will be created/optimized automatically</p> </li> <li> <p><code>num_points</code>: int, default=1000</p> </li> <li>Number of discretization points for output domain</li> <li>Higher = more accurate defuzzification, but slower</li> <li> <p>Typical range: 500-2000</p> </li> <li> <p><code>verbose</code>: bool, default=True</p> </li> <li>Print detailed progress during optimization</li> <li>Shows iteration count, cost evolution, temperature (SA), etc.</li> </ul>"},{"location":"quick_start/mamdani_learning/#3-training-with-fit_rules","title":"3. Training with <code>fit_rules()</code>","text":"<p>The <code>fit_rules()</code> method optimizes the fuzzy rules using metaheuristic algorithms:</p> <pre><code># Prepare data\nX_train = ...  # shape: (n_samples, n_features)\ny_train = ...  # shape: (n_samples,)\n\n# Train with Simulated Annealing (default)\nlearner.fit_rules(\n    X_train=X_train,\n    y_train=y_train,\n    optimizer='sa',                      # Algorithm: 'sa', 'ga', 'pso', 'de'\n    optimizer_params=None,               # Optional: algorithm-specific parameters\n    initial_solution_method='random'     # Initialization: 'random', 'uniform', 'gradient'\n)\n</code></pre>"},{"location":"quick_start/mamdani_learning/#parameters_1","title":"Parameters","text":"<ul> <li><code>X_train</code>: np.ndarray, shape (n_samples, n_features)</li> <li>Training input data</li> <li> <p>Must match number of input variables in system</p> </li> <li> <p><code>y_train</code>: np.ndarray, shape (n_samples,)</p> </li> <li>Training target values</li> <li> <p>Currently supports single-output systems</p> </li> <li> <p><code>optimizer</code>: str, default='sa'</p> </li> <li> <p>Optimization algorithm:</p> <ul> <li><code>'sa'</code>: Simulated Annealing (recommended for small-medium problems)</li> <li><code>'ga'</code>: Genetic Algorithm (good for discrete optimization)</li> <li><code>'pso'</code>: Particle Swarm Optimization (fast convergence)</li> <li><code>'de'</code>: Differential Evolution (robust)</li> </ul> </li> <li> <p><code>optimizer_params</code>: dict, optional</p> </li> <li> <p>Algorithm-specific hyperparameters (see section 4)</p> </li> <li> <p><code>initial_solution_method</code>: str, default='random'</p> </li> <li>How to initialize the rule consequents:<ul> <li><code>'random'</code>: Random assignment of output terms</li> <li><code>'uniform'</code>: All rules start with middle output term</li> <li><code>'gradient'</code>: Data-driven initialization (recommended for faster convergence)</li> </ul> </li> </ul>"},{"location":"quick_start/mamdani_learning/#return-value","title":"Return Value","text":"<p>Returns <code>self</code> for method chaining: <pre><code>learner = MamdaniLearning(system).fit_rules(X_train, y_train)\n</code></pre></p>"},{"location":"quick_start/mamdani_learning/#4-optimizer-specific-parameters","title":"4. Optimizer-Specific Parameters","text":""},{"location":"quick_start/mamdani_learning/#41-simulated-annealing-optimizersa","title":"4.1 Simulated Annealing (<code>optimizer='sa'</code>)","text":"<p>Best for: Small-to-medium rule bases, guarantees convergence</p> <pre><code>learner.fit_rules(\n    X_train, y_train,\n    optimizer='sa',\n    optimizer_params={\n        'temperature_init': 100.0,      # Initial temperature\n        'temperature_min': 0.01,        # Minimum temperature (stopping criterion)\n        'cooling_rate': 0.95,           # Temperature decay (0.9-0.99)\n        'max_iterations': 5000,         # Maximum iterations\n        'plateau_iterations': 1000,     # Stop if no improvement for N iterations\n        'cooling_schedule': 'exponential'  # 'exponential', 'linear', or 'logarithmic'\n    }\n)\n</code></pre> <p>Parameters: - <code>temperature_init</code>: Starting temperature (higher = more exploration) - <code>cooling_rate</code>: Decay factor per iteration (closer to 1 = slower cooling) - <code>cooling_schedule</code>: How temperature decreases   - <code>'exponential'</code>: T *= cooling_rate (default, balanced)   - <code>'linear'</code>: T -= (T_init - T_min) / max_iter (fast cooling)   - <code>'logarithmic'</code>: T = T_init / log(1 + iteration) (slow cooling)</p> <p>Tips: - Start with high temperature (50-200) for good exploration - Use cooling_rate 0.90-0.99 (0.95 is good default) - Increase max_iterations if solution hasn't converged</p>"},{"location":"quick_start/mamdani_learning/#42-genetic-algorithm-optimizerga","title":"4.2 Genetic Algorithm (<code>optimizer='ga'</code>)","text":"<p>Best for: Large rule bases, diverse solution exploration</p> <pre><code>learner.fit_rules(\n    X_train, y_train,\n    optimizer='ga',\n    optimizer_params={\n        'pop_size': 100,                # Population size\n        'max_gen': 500,                 # Maximum generations\n        'elite_ratio': 0.15,            # Fraction of elites to keep (0.1-0.2)\n        'crossover_rate': 0.8,          # Probability of crossover (0.7-0.9)\n        'crossover_type': 'uniform',    # 'uniform' or 'single_point'\n        'mutation_rate': 0.05,          # Probability of mutation (0.01-0.1)\n        'tournament_size': 5,           # Tournament selection size (3-7)\n        'adaptive_mutation': True,      # Increase mutation when stagnant\n        'plateau_generations': 50,      # Trigger adaptive mutation after N gens\n        'mutation_boost_factor': 2.0    # Mutation rate multiplier when stagnant\n    }\n)\n</code></pre> <p>Parameters: - <code>pop_size</code>: Number of individuals (50-200, larger for complex problems) - <code>elite_ratio</code>: Fraction of best individuals preserved (typical: 0.1-0.2) - <code>crossover_rate</code>: Higher = more recombination (0.7-0.9) - <code>mutation_rate</code>: Higher = more exploration (0.01-0.1) - <code>adaptive_mutation</code>: Automatically increases mutation when stuck</p> <p>Tips: - Use <code>crossover_type='uniform'</code> for better exploration - Enable <code>adaptive_mutation=True</code> to escape local optima - Balance: high crossover (0.8) + low mutation (0.05)</p>"},{"location":"quick_start/mamdani_learning/#43-particle-swarm-optimization-optimizerpso","title":"4.3 Particle Swarm Optimization (<code>optimizer='pso'</code>)","text":"<p>Best for: Fast convergence, continuous-like exploration</p> <pre><code>learner.fit_rules(\n    X_train, y_train,\n    optimizer='pso',\n    optimizer_params={\n        'n_particles': 30,          # Number of particles (20-50)\n        'n_iterations': 100,        # Number of iterations (50-200)\n        'w_max': 0.9,               # Initial inertia weight (exploration)\n        'w_min': 0.4,               # Final inertia weight (exploitation)\n        'c1': 1.49618,              # Cognitive parameter (personal best attraction)\n        'c2': 1.49618               # Social parameter (global best attraction)\n    }\n)\n</code></pre> <p>Parameters: - <code>w_max/w_min</code>: Inertia weight (linearly decreases from w_max to w_min)   - High w = exploration, low w = exploitation - <code>c1</code>: Attraction to personal best (typical: 1.5-2.0) - <code>c2</code>: Attraction to global best (typical: 1.5-2.0)</p> <p>Tips: - Use c1 \u2248 c2 for balanced exploration/exploitation - Increase c1 for more individual exploration - Increase c2 for faster convergence (may get stuck)</p>"},{"location":"quick_start/mamdani_learning/#44-differential-evolution-optimizerde","title":"4.4 Differential Evolution (<code>optimizer='de'</code>)","text":"<p>Best for: Robust global optimization, fewer parameters</p> <pre><code>learner.fit_rules(\n    X_train, y_train,\n    optimizer='de',\n    optimizer_params={\n        'pop_size': 50,             # Population size (30-100)\n        'max_iter': 100,            # Maximum iterations (50-200)\n        'F': 0.8,                   # Differential weight (0.5-1.0)\n        'CR': 0.9                   # Crossover probability (0.7-0.95)\n    }\n)\n</code></pre> <p>Parameters: - <code>F</code>: Differential weight (controls mutation scale)   - Low F (0.5-0.7) = conservative   - High F (0.8-1.0) = aggressive exploration - <code>CR</code>: Crossover rate   - High CR (0.8-0.95) = more information exchange</p> <p>Tips: - Use F=0.8, CR=0.9 as good defaults - Increase pop_size for complex problems - More stable than GA, fewer hyperparameters</p>"},{"location":"quick_start/mamdani_learning/#5-making-predictions","title":"5. Making Predictions","text":"<p>After training, use the learned rules to make predictions:</p> <pre><code># Make predictions\nX_test = ...  # shape: (n_samples, n_features)\ny_pred = learner.predict(X_test)\n</code></pre>"},{"location":"quick_start/mamdani_learning/#prediction-methods","title":"Prediction Methods","text":"<pre><code># Basic prediction\ny_pred = learner.predict(X_test)\n\n# Calculate RMSE on test set\nrmse = learner.score(X_test, y_test)\nprint(f\"Test RMSE: {rmse:.4f}\")\n</code></pre>"},{"location":"quick_start/mamdani_learning/#6-accessing-learned-rules-and-history","title":"6. Accessing Learned Rules and History","text":""},{"location":"quick_start/mamdani_learning/#61-get-learned-rules","title":"6.1 Get Learned Rules","text":"<pre><code># Get best rule consequent indices\nrules = learner.get_rules()\nprint(f\"Optimized rules: {rules}\")\n# Example output: [0, 2, 1, 0, 2, 1, 0, 1, 2]\n# This means: Rule 0 uses output term 0 (low)\n#             Rule 1 uses output term 2 (high)\n#             Rule 2 uses output term 1 (medium), etc.\n</code></pre>"},{"location":"quick_start/mamdani_learning/#62-get-best-cost","title":"6.2 Get Best Cost","text":"<pre><code># Get final optimization cost (RMSE)\nbest_cost = learner.get_cost()\nprint(f\"Best RMSE: {best_cost:.6f}\")\n</code></pre>"},{"location":"quick_start/mamdani_learning/#63-get-optimization-history","title":"6.3 Get Optimization History","text":"<pre><code># Get convergence history\nhistory = learner.get_history()\n\n# Plot convergence\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 5))\nplt.plot(history['costs'])\nplt.xlabel('Iteration')\nplt.ylabel('RMSE')\nplt.title('Optimization Convergence')\nplt.grid(True)\nplt.show()\n</code></pre> <p>History dictionary contains: <pre><code>{\n    'costs': list,           # Cost at each iteration\n    'temperatures': list,    # Temperature schedule (SA only)\n    'acceptances': list,     # Acceptance rate (SA only)\n    'best_fitnesses': list,  # Best fitness per generation (GA only)\n    'avg_fitnesses': list,   # Average fitness per generation (GA only)\n    # ... optimizer-specific metrics\n}\n</code></pre></p>"},{"location":"quick_start/mamdani_learning/#7-complete-example","title":"7. Complete Example","text":"<pre><code>import numpy as np\nfrom fuzzy_systems.inference import MamdaniSystem\nfrom fuzzy_systems.learning import MamdaniLearning\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\n# ============================================================================\n# 1. Generate synthetic data\n# ============================================================================\nnp.random.seed(42)\nX = np.random.uniform(0, 10, (500, 2))\ny = np.sin(X[:, 0]) * np.cos(X[:, 1]) + np.random.normal(0, 0.1, 500)\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n# ============================================================================\n# 2. Create and configure Mamdani system\n# ============================================================================\nsystem = MamdaniSystem()\n\n# Inputs\nsystem.add_input('x1', (0, 10))\nsystem.add_input('x2', (0, 10))\n\n# Add 3 terms per input\nfor var in ['x1', 'x2']:\n    system.add_term(var, 'low', 'triangular', (0, 0, 5))\n    system.add_term(var, 'medium', 'triangular', (2.5, 5, 7.5))\n    system.add_term(var, 'high', 'triangular', (5, 10, 10))\n\n# Output\nsystem.add_output('y', (-2, 2))\nsystem.add_term('y', 'negative', 'triangular', (-2, -2, 0))\nsystem.add_term('y', 'zero', 'triangular', (-1, 0, 1))\nsystem.add_term('y', 'positive', 'triangular', (0, 2, 2))\n\nprint(f\"Total possible rules: 3 \u00d7 3 = 9\")\nprint(f\"Each rule can have 3 different consequents (negative/zero/positive)\")\n\n# ============================================================================\n# 3. Create learner and optimize rules\n# ============================================================================\nlearner = MamdaniLearning(system, num_points=1000, verbose=True)\n\n# Train with Simulated Annealing\nlearner.fit_rules(\n    X_train, y_train,\n    optimizer='sa',\n    optimizer_params={\n        'temperature_init': 100.0,\n        'cooling_rate': 0.95,\n        'max_iterations': 3000,\n        'plateau_iterations': 500\n    },\n    initial_solution_method='gradient'\n)\n\n# ============================================================================\n# 4. Evaluate\n# ============================================================================\ny_pred_train = learner.predict(X_train)\ny_pred_test = learner.predict(X_test)\n\nrmse_train = learner.score(X_train, y_train)\nrmse_test = learner.score(X_test, y_test)\n\nprint(f\"\\n{'='*70}\")\nprint(\"RESULTS\")\nprint(f\"{'='*70}\")\nprint(f\"Train RMSE: {rmse_train:.6f}\")\nprint(f\"Test RMSE:  {rmse_test:.6f}\")\nprint(f\"Best rules: {learner.get_rules()}\")\n\n# ============================================================================\n# 5. Plot convergence\n# ============================================================================\nhistory = learner.get_history()\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\n# Cost evolution\nax1.plot(history['costs'])\nax1.set_xlabel('Iteration')\nax1.set_ylabel('RMSE')\nax1.set_title('Cost Evolution')\nax1.grid(True)\n\n# Temperature evolution (SA only)\nif 'temperatures' in history:\n    ax2.plot(history['temperatures'])\n    ax2.set_xlabel('Iteration')\n    ax2.set_ylabel('Temperature')\n    ax2.set_title('Temperature Schedule')\n    ax2.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# ============================================================================\n# 6. Plot predictions\n# ============================================================================\nplt.figure(figsize=(10, 5))\nplt.scatter(y_test, y_pred_test, alpha=0.6)\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)\nplt.xlabel('True Values')\nplt.ylabel('Predictions')\nplt.title(f'Test Set Predictions (RMSE: {rmse_test:.4f})')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"quick_start/mamdani_learning/#8-choosing-the-right-optimizer","title":"8. Choosing the Right Optimizer","text":""},{"location":"quick_start/mamdani_learning/#decision-guide","title":"Decision Guide","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  How many rules in your system?     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502               \u2502\n    &lt; 20 rules     &gt; 20 rules\n       \u2502               \u2502\n       \u25bc               \u25bc\n  Use SA/PSO      Use GA/DE\n  (faster)        (better exploration)\n       \u2502               \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Do you need guaranteed convergence?\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502               \u2502\n      YES              NO\n       \u2502               \u2502\n       \u25bc               \u25bc\n     Use SA      Use GA/PSO/DE\n   (proven)       (faster, stochastic)\n</code></pre>"},{"location":"quick_start/mamdani_learning/#recommendations-by-problem-size","title":"Recommendations by Problem Size","text":"Rules Best Algorithm Typical Time Parameters &lt; 10 SA Fast (seconds) temperature_init=100, cooling_rate=0.95 10-30 SA or PSO Medium (minutes) SA: cooling_rate=0.97, PSO: n_particles=30 30-100 GA or DE Slow (minutes-hours) GA: pop_size=100, DE: pop_size=50 &gt; 100 GA Very slow pop_size=200, max_gen=1000"},{"location":"quick_start/mamdani_learning/#algorithm-characteristics","title":"Algorithm Characteristics","text":"<p>Simulated Annealing (SA): - \u2705 Theoretical convergence guarantee - \u2705 Few hyperparameters - \u2705 Good for small-medium problems - \u274c Slow for large problems - \u274c Sequential (no parallelization)</p> <p>Genetic Algorithm (GA): - \u2705 Excellent exploration - \u2705 Handles large search spaces - \u2705 Can be parallelized - \u274c Many hyperparameters to tune - \u274c Can be slow to converge</p> <p>Particle Swarm Optimization (PSO): - \u2705 Fast convergence - \u2705 Few parameters - \u2705 Good balance exploration/exploitation - \u274c Can get stuck in local optima - \u274c Adapted for discrete spaces (may be suboptimal)</p> <p>Differential Evolution (DE): - \u2705 Robust and reliable - \u2705 Very few parameters - \u2705 Good for difficult landscapes - \u274c Slower than PSO - \u274c Adapted for discrete spaces</p>"},{"location":"quick_start/mamdani_learning/#9-tips-and-best-practices","title":"9. Tips and Best Practices","text":""},{"location":"quick_start/mamdani_learning/#membership-function-design","title":"Membership Function Design","text":"<pre><code># Good: 3-5 MFs with 50% overlap\nsystem.add_term('temp', 'low', 'triangular', (0, 0, 5))\nsystem.add_term('temp', 'med', 'triangular', (2.5, 5, 7.5))\nsystem.add_term('temp', 'high', 'triangular', (5, 10, 10))\n\n# Bad: Too many MFs = exponential rule growth\n# 5 MFs \u00d7 5 MFs \u00d7 5 MFs = 125 rules!\n</code></pre>"},{"location":"quick_start/mamdani_learning/#initial-solution","title":"Initial Solution","text":"<pre><code># Random: Good default\nlearner.fit_rules(X, y, initial_solution_method='random')\n\n# Gradient: Best for faster convergence (uses data)\nlearner.fit_rules(X, y, initial_solution_method='gradient')\n\n# Uniform: All rules start with middle term (conservative)\nlearner.fit_rules(X, y, initial_solution_method='uniform')\n</code></pre>"},{"location":"quick_start/mamdani_learning/#monitoring-convergence","title":"Monitoring Convergence","text":"<pre><code># Check if optimization converged\nhistory = learner.get_history()\ncosts = history['costs']\n\n# Plateau detection\nlast_100 = costs[-100:]\nif max(last_100) - min(last_100) &lt; 1e-4:\n    print(\"\u2713 Converged (cost plateau)\")\nelse:\n    print(\"\u26a0\ufe0f Not converged, increase max_iterations\")\n</code></pre>"},{"location":"quick_start/mamdani_learning/#overfitting-prevention","title":"Overfitting Prevention","text":"<pre><code># Use validation set for early stopping (manual)\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2)\n\nlearner.fit_rules(X_train, y_train, optimizer='sa')\n\nrmse_train = learner.score(X_train, y_train)\nrmse_val = learner.score(X_val, y_val)\n\nif rmse_val &gt; rmse_train * 1.5:\n    print(\"\u26a0\ufe0f Overfitting detected\")\n</code></pre>"},{"location":"quick_start/mamdani_learning/#computational-efficiency","title":"Computational Efficiency","text":"<pre><code># Pre-computation is automatic, but you can control discretization\nlearner = MamdaniLearning(\n    system,\n    num_points=500    # Lower = faster, less accurate defuzzification\n)\n\n# For very large datasets, consider sampling\nif len(X_train) &gt; 1000:\n    indices = np.random.choice(len(X_train), 1000, replace=False)\n    X_sample = X_train[indices]\n    y_sample = y_train[indices]\n    learner.fit_rules(X_sample, y_sample)\n</code></pre>"},{"location":"quick_start/mamdani_learning/#10-troubleshooting","title":"10. Troubleshooting","text":"Problem Possible Cause Solution Slow convergence Too many rules Reduce MFs per variable Stuck in local optimum SA cooling too fast Decrease cooling_rate (0.95\u21920.98) Poor accuracy Bad MF placement Adjust MF centers/shapes Overfitting Too many rules Reduce MFs, add regularization No improvement Bad initialization Try <code>initial_solution_method='gradient'</code> NaN values Defuzzification issues Check MF coverage, increase num_points"},{"location":"quick_start/mamdani_learning/#11-comparison-with-other-methods","title":"11. Comparison with Other Methods","text":""},{"location":"quick_start/mamdani_learning/#vs-wang-mendel","title":"vs Wang-Mendel","text":"<p>Wang-Mendel: - \u2705 Very fast (single pass) - \u2705 No hyperparameters - \u274c No optimization (may be suboptimal)</p> <p>MamdaniLearning: - \u2705 Optimizes for best accuracy - \u2705 Flexible (multiple algorithms) - \u274c Slower (iterative)</p> <p>When to use which: - Use Wang-Mendel for quick baseline - Use MamdaniLearning to improve accuracy</p>"},{"location":"quick_start/mamdani_learning/#vs-anfis","title":"vs ANFIS","text":"<p>ANFIS: - \u2705 Learns MF parameters + consequents - \u2705 Gradient-based (efficient for continuous) - \u274c Complex implementation - \u274c Requires differentiable MFs</p> <p>MamdaniLearning: - \u2705 Simpler (only learns consequents) - \u2705 Works with any MF type - \u2705 Interpretable rules - \u274c Doesn't adjust MF shapes</p> <p>When to use which: - Use MamdaniLearning for interpretability, fixed MFs - Use ANFIS for maximum accuracy, flexible MFs</p>"},{"location":"quick_start/mamdani_learning/#12-advanced-usage","title":"12. Advanced Usage","text":""},{"location":"quick_start/mamdani_learning/#sequential-optimization","title":"Sequential Optimization","text":"<pre><code># Step 1: Quick initialization with Wang-Mendel\nfrom fuzzy_systems.learning import WangMendelLearning\nwm = WangMendelLearning(system, X_train, y_train)\nwm.fit()\n\n# Step 2: Fine-tune with MamdaniLearning\nlearner = MamdaniLearning(system)\nlearner.fit_rules(X_train, y_train, optimizer='pso',\n                 initial_solution_method='random')\n</code></pre>"},{"location":"quick_start/mamdani_learning/#comparing-multiple-optimizers","title":"Comparing Multiple Optimizers","text":"<pre><code>results = {}\n\nfor opt in ['sa', 'ga', 'pso', 'de']:\n    learner = MamdaniLearning(system, verbose=False)\n    learner.fit_rules(X_train, y_train, optimizer=opt)\n    rmse = learner.score(X_test, y_test)\n    results[opt] = rmse\n    print(f\"{opt.upper()}: RMSE = {rmse:.6f}\")\n\nbest_opt = min(results, key=results.get)\nprint(f\"\\nBest optimizer: {best_opt.upper()}\")\n</code></pre>"},{"location":"quick_start/mamdani_learning/#references","title":"References","text":"<ul> <li>Mamdani, E. H., &amp; Assilian, S. (1975). \"An experiment in linguistic synthesis with a fuzzy logic controller.\" International Journal of Man-Machine Studies, 7(1), 1-13.</li> <li>Kirkpatrick, S., et al. (1983). \"Optimization by simulated annealing.\" Science, 220(4598), 671-680.</li> <li>Holland, J. H. (1992). \"Genetic algorithms.\" Scientific American, 267(1), 66-73.</li> <li>Kennedy, J., &amp; Eberhart, R. (1995). \"Particle swarm optimization.\" IEEE International Conference on Neural Networks.</li> <li>Storn, R., &amp; Price, K. (1997). \"Differential evolution\u2013a simple and efficient heuristic for global optimization.\" Journal of Global Optimization, 11(4), 341-359.</li> </ul>"},{"location":"quick_start/mamdani_system/","title":"Mamdani FIS Quick Start Guide","text":""},{"location":"quick_start/mamdani_system/#overview","title":"Overview","text":"<p>MamdaniSystem is a fuzzy inference system that uses linguistic rules with fuzzy outputs for decision-making and control applications.</p> <p>Key Features: - Flexible input/output variable creation - Manual or automatic membership function generation - Intuitive rule creation - Multiple visualization tools - Rule export/import capabilities - System persistence (save/load)</p>"},{"location":"quick_start/mamdani_system/#1-creating-a-mamdani-fis","title":"1. Creating a Mamdani FIS","text":""},{"location":"quick_start/mamdani_system/#basic-instantiation","title":"Basic Instantiation","text":"<pre><code>from fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.core.membership_functions import TNorm, SNorm, DefuzzMethod\n\n# Create Mamdani system\nfis = MamdaniSystem(\n    name=\"My FIS\",\n    and_method=TNorm.MIN,              # T-norm for AND operator\n    or_method=SNorm.MAX,               # S-norm for OR operator\n    implication_method='min',          # Implication: 'min' or 'product'\n    aggregation_method='max',          # Aggregation: 'max', 'sum', 'probabilistic'\n    defuzzification_method=DefuzzMethod.CENTROID  # Defuzzification method\n)\n</code></pre>"},{"location":"quick_start/mamdani_system/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>name</code>: System identifier</li> <li><code>and_method</code>: T-norm for AND operations</li> <li><code>TNorm.MIN</code>: Minimum (default, most common)</li> <li><code>TNorm.PRODUCT</code>: Product</li> <li><code>TNorm.LUKASIEWICZ</code>: Lukasiewicz</li> <li><code>or_method</code>: S-norm for OR operations</li> <li><code>SNorm.MAX</code>: Maximum (default)</li> <li><code>SNorm.PROBOR</code>: Probabilistic OR</li> <li><code>SNorm.LUKASIEWICZ</code>: Lukasiewicz</li> <li><code>implication_method</code>: Rule implication</li> <li><code>'min'</code>: Minimum (default, Mamdani)</li> <li><code>'product'</code>: Product (Larsen)</li> <li><code>aggregation_method</code>: Aggregate multiple rules</li> <li><code>'max'</code>: Maximum (default)</li> <li><code>'sum'</code>: Bounded sum</li> <li><code>'probabilistic'</code>: Probabilistic OR</li> <li><code>defuzzification_method</code>: Convert fuzzy output to crisp</li> <li><code>DefuzzMethod.CENTROID</code>: Center of area (most common)</li> <li><code>DefuzzMethod.BISECTOR</code>: Bisector of area</li> <li><code>DefuzzMethod.MOM</code>: Mean of maximum</li> <li><code>DefuzzMethod.SOM</code>: Smallest of maximum</li> <li><code>DefuzzMethod.LOM</code>: Largest of maximum</li> </ul>"},{"location":"quick_start/mamdani_system/#2-adding-variables","title":"2. Adding Variables","text":""},{"location":"quick_start/mamdani_system/#input-variables","title":"Input Variables","text":"<pre><code># Add input variable with universe of discourse\nfis.add_input('temperature', (0, 100))  # Temperature from 0 to 100\nfis.add_input('humidity', (0, 100))     # Humidity from 0 to 100\n</code></pre>"},{"location":"quick_start/mamdani_system/#output-variables","title":"Output Variables","text":"<pre><code># Add output variable\nfis.add_output('fan_speed', (0, 100))   # Fan speed from 0 to 100\n</code></pre>"},{"location":"quick_start/mamdani_system/#3-adding-membership-functions-manual","title":"3. Adding Membership Functions (Manual)","text":""},{"location":"quick_start/mamdani_system/#method-1-using-add_term","title":"Method 1: Using <code>add_term()</code>","text":"<pre><code># Add membership functions manually\n# Syntax: add_term(variable_name, term_name, mf_type, parameters)\n\n# Temperature: cold, warm, hot\nfis.add_term('temperature', 'cold', 'triangular', (0, 0, 50))\nfis.add_term('temperature', 'warm', 'triangular', (0, 50, 100))\nfis.add_term('temperature', 'hot', 'triangular', (50, 100, 100))\n\n# Humidity: low, medium, high\nfis.add_term('humidity', 'low', 'trapezoidal', (0, 0, 30, 50))\nfis.add_term('humidity', 'medium', 'triangular', (30, 50, 70))\nfis.add_term('humidity', 'high', 'trapezoidal', (50, 70, 100, 100))\n\n# Fan speed: slow, medium, fast\nfis.add_term('fan_speed', 'slow', 'gaussian', (25, 10))\nfis.add_term('fan_speed', 'medium', 'gaussian', (50, 10))\nfis.add_term('fan_speed', 'fast', 'gaussian', (75, 10))\n</code></pre>"},{"location":"quick_start/mamdani_system/#available-membership-function-types","title":"Available Membership Function Types","text":"Type Parameters Example <code>'triangular'</code> (a, b, c) <code>(0, 50, 100)</code> <code>'trapezoidal'</code> (a, b, c, d) <code>(0, 20, 80, 100)</code> <code>'gaussian'</code> (center, sigma) <code>(50, 15)</code> <code>'bell'</code> (center, width, slope) <code>(50, 20, 2)</code> <code>'sigmoid'</code> (center, slope) <code>(50, 0.1)</code>"},{"location":"quick_start/mamdani_system/#4-adding-membership-functions-automatic","title":"4. Adding Membership Functions (Automatic)","text":""},{"location":"quick_start/mamdani_system/#using-add_auto_mfs-quick-setup","title":"Using <code>add_auto_mfs()</code> - Quick Setup","text":"<pre><code># Automatically generate evenly spaced membership functions\nfis.add_input('temperature', (0, 100))\nfis.add_auto_mfs(\n    variable_name='temperature',\n    n_mfs=3,                          # Number of MFs (minimum 2)\n    mf_type='triangular',             # MF type\n    label_prefix=None,                # Custom labels (None = linguistic)\n    overlap_strategy='standard'       # 'standard' or 'perfect'\n)\n\n# This creates 3 triangular MFs with linguistic labels:\n# - 'very low' at left\n# - 'medium' at center\n# - 'very high' at right\n</code></pre>"},{"location":"quick_start/mamdani_system/#key-parameters_1","title":"Key Parameters","text":"<ul> <li><code>n_mfs</code>: Number of membership functions (\u2265 2)</li> <li><code>mf_type</code>: Type of membership function</li> <li><code>'triangular'</code>: Triangle-shaped (default)</li> <li><code>'gaussian'</code>: Gaussian/bell-shaped</li> <li><code>'trapezoidal'</code>: Trapezoid-shaped</li> <li><code>'bell'</code>: Generalized bell</li> <li><code>label_prefix</code>: Custom label prefix</li> <li><code>None</code>: Uses linguistic labels (very low, low, medium, high, very high, etc.)</li> <li><code>'temp_'</code>: Creates labels like temp_1, temp_2, temp_3</li> <li><code>overlap_strategy</code>: How MFs overlap</li> <li><code>'standard'</code>: Standard overlap (default)</li> <li><code>'perfect'</code>: Perfect overlap (sum of memberships = 1.0 at any point)</li> </ul>"},{"location":"quick_start/mamdani_system/#linguistic-labels-when-label_prefixnone","title":"Linguistic Labels (when <code>label_prefix=None</code>)","text":"<p>For different <code>n_mfs</code>, automatic linguistic labels are generated:</p> <ul> <li>n_mfs=2: very low, very high</li> <li>n_mfs=3: very low, medium, very high</li> <li>n_mfs=4: very low, low, high, very high</li> <li>n_mfs=5: very low, low, medium, high, very high</li> <li>n_mfs=7: very low, low, somewhat low, medium, somewhat high, high, very high</li> </ul>"},{"location":"quick_start/mamdani_system/#example-complete-system-with-auto-mfs","title":"Example: Complete System with Auto MFs","text":"<pre><code>from fuzzy_systems import MamdaniSystem\n\n# Create system\nfis = MamdaniSystem(name=\"Temperature Controller\")\n\n# Add variables\nfis.add_input('temperature', (0, 100))\nfis.add_input('humidity', (0, 100))\nfis.add_output('fan_speed', (0, 100))\n\n# Generate MFs automatically\nfis.add_auto_mfs('temperature', n_mfs=3, mf_type='triangular')\nfis.add_auto_mfs('humidity', n_mfs=3, mf_type='triangular')\nfis.add_auto_mfs('fan_speed', n_mfs=3, mf_type='triangular')\n\n# Now you have:\n# temperature: very low, medium, very high\n# humidity: very low, medium, very high\n# fan_speed: very low, medium, very high\n</code></pre>"},{"location":"quick_start/mamdani_system/#5-adding-rules","title":"5. Adding Rules","text":""},{"location":"quick_start/mamdani_system/#method-1-using-dictionaries-most-readable","title":"Method 1: Using Dictionaries (Most Readable)","text":"<pre><code># Add rules using variable and term names\nfis.add_rule({\n    'temperature': 'cold',\n    'humidity': 'high',\n    'fan_speed': 'slow',\n    'operator': 'AND',\n    'weight': 1.0\n})\n\n# Operator and weight are optional\nfis.add_rule({\n    'temperature': 'hot',\n    'humidity': 'high',\n    'fan_speed': 'fast'\n})\n</code></pre>"},{"location":"quick_start/mamdani_system/#method-2-using-lists-ordered-by-variable","title":"Method 2: Using Lists (Ordered by Variable)","text":"<pre><code># Rules as lists: [input1_term, input2_term, ..., output1_term, ...]\n# Order follows the order variables were added\nfis.add_rule(['cold', 'low', 'slow'])\nfis.add_rule(['warm', 'medium', 'medium'])\nfis.add_rule(['hot', 'high', 'fast'])\n</code></pre>"},{"location":"quick_start/mamdani_system/#method-3-batch-adding-with-add_rules","title":"Method 3: Batch Adding with <code>add_rules()</code>","text":"<pre><code># Add multiple rules at once\nfis.add_rules([\n    {'temperature': 'cold', 'humidity': 'low', 'fan_speed': 'slow'},\n    {'temperature': 'cold', 'humidity': 'high', 'fan_speed': 'medium'},\n    {'temperature': 'warm', 'humidity': 'low', 'fan_speed': 'medium'},\n    {'temperature': 'warm', 'humidity': 'high', 'fan_speed': 'medium'},\n    {'temperature': 'hot', 'humidity': 'low', 'fan_speed': 'medium'},\n    {'temperature': 'hot', 'humidity': 'high', 'fan_speed': 'fast'}\n])\n</code></pre>"},{"location":"quick_start/mamdani_system/#rule-parameters","title":"Rule Parameters","text":"<ul> <li><code>operator</code>: Rule connector</li> <li><code>'AND'</code>: All conditions must be true (default)</li> <li><code>'OR'</code>: At least one condition must be true</li> <li><code>weight</code>: Rule importance (0.0 to 1.0, default: 1.0)</li> <li>Used to reduce rule influence without removing it</li> <li>Example: <code>weight=0.5</code> reduces rule firing strength by half</li> </ul>"},{"location":"quick_start/mamdani_system/#6-evaluating-the-system","title":"6. Evaluating the System","text":""},{"location":"quick_start/mamdani_system/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code># Evaluate with dictionary\noutput = fis.evaluate({'temperature': 75, 'humidity': 80})\nprint(f\"Fan speed: {output['fan_speed']:.2f}\")\n\n# Evaluate with keyword arguments\noutput = fis.evaluate(temperature=75, humidity=80)\n\n# Evaluate with positional arguments (follows variable order)\noutput = fis.evaluate(75, 80)\n</code></pre>"},{"location":"quick_start/mamdani_system/#detailed-evaluation-debugging","title":"Detailed Evaluation (Debugging)","text":"<pre><code># Get detailed information about inference process\nresult = fis.evaluate_detailed(temperature=75, humidity=80)\n\nprint(f\"Inputs: {result['inputs']}\")\nprint(f\"Fuzzified: {result['fuzzified']}\")\nprint(f\"Outputs: {result['outputs']}\")\nprint(f\"Rule activations: {result['rule_activations']}\")\n</code></pre>"},{"location":"quick_start/mamdani_system/#7-visualization","title":"7. Visualization","text":""},{"location":"quick_start/mamdani_system/#plot-inputoutput-variables","title":"Plot Input/Output Variables","text":"<pre><code># Plot all variables (inputs and outputs)\nfis.plot_variables()\n\n# Plot specific variable\nfis.plot_variables(variables=['temperature'])\n\n# Customize plot\nfis.plot_variables(\n    variables=['temperature', 'humidity'],\n    figsize=(12, 6),\n    grid=True\n)\n</code></pre>"},{"location":"quick_start/mamdani_system/#plot-output-surface-2d-input-only","title":"Plot Output Surface (2D Input Only)","text":"<pre><code># Plot 3D surface for 2-input, 1-output systems\nfis.plot_output(\n    output_var='fan_speed',\n    resolution=50,              # Points per dimension\n    figsize=(10, 8),\n    colormap='viridis'\n)\n</code></pre>"},{"location":"quick_start/mamdani_system/#plot-rule-matrix","title":"Plot Rule Matrix","text":"<pre><code># Visualize rule firing strength matrix (2D systems)\nfis.plot_rule_matrix(\n    input1='temperature',\n    input2='humidity',\n    output='fan_speed',\n    resolution=30\n)\n\n# Alternative 2D visualization\nfis.plot_rule_matrix_2d(\n    output_var='fan_speed',\n    resolution=30\n)\n</code></pre>"},{"location":"quick_start/mamdani_system/#8-rule-management","title":"8. Rule Management","text":""},{"location":"quick_start/mamdani_system/#export-rules","title":"Export Rules","text":"<pre><code># Export rules to JSON format\nrules_json = fis.export_rules()\nprint(rules_json)\n\n# Save rules to file\nimport json\nwith open('rules.json', 'w') as f:\n    json.dump(rules_json, f, indent=2)\n</code></pre>"},{"location":"quick_start/mamdani_system/#import-rules","title":"Import Rules","text":"<pre><code># Import rules from JSON\nrules_json = [\n    {\n        \"antecedents\": {\"temperature\": \"cold\", \"humidity\": \"low\"},\n        \"consequents\": {\"fan_speed\": \"slow\"},\n        \"operator\": \"AND\",\n        \"weight\": 1.0\n    },\n    {\n        \"antecedents\": {\"temperature\": \"hot\", \"humidity\": \"high\"},\n        \"consequents\": {\"fan_speed\": \"fast\"},\n        \"operator\": \"AND\",\n        \"weight\": 1.0\n    }\n]\n\nfis.import_rules(rules_json)\n</code></pre>"},{"location":"quick_start/mamdani_system/#clear-rules","title":"Clear Rules","text":"<pre><code># Remove all rules\nfis.rule_base.rules.clear()\n</code></pre>"},{"location":"quick_start/mamdani_system/#9-system-persistence","title":"9. System Persistence","text":""},{"location":"quick_start/mamdani_system/#save-system-to-file","title":"Save System to File","text":"<pre><code># Save entire system (variables, MFs, rules)\nfis.save('temperature_controller.fis')\n</code></pre>"},{"location":"quick_start/mamdani_system/#load-system-from-file","title":"Load System from File","text":"<pre><code>from fuzzy_systems import MamdaniSystem\n\n# Load saved system\nfis = MamdaniSystem.load('temperature_controller.fis')\n\n# Use immediately\noutput = fis.evaluate(temperature=75, humidity=80)\n</code></pre>"},{"location":"quick_start/mamdani_system/#export-to-json","title":"Export to JSON","text":"<pre><code># Export system to JSON format\nfis_json = fis.to_json()\n\n# Save JSON to file\nwith open('fis.json', 'w') as f:\n    json.dump(fis_json, f, indent=2)\n</code></pre>"},{"location":"quick_start/mamdani_system/#import-from-json","title":"Import from JSON","text":"<pre><code># Load from JSON\nwith open('fis.json', 'r') as f:\n    fis_json = json.load(f)\n\nfis = MamdaniSystem.from_json(fis_json)\n</code></pre>"},{"location":"quick_start/mamdani_system/#10-complete-example","title":"10. Complete Example","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems import MamdaniSystem\nfrom fuzzy_systems.core.membership_functions import DefuzzMethod\n\n# ============================================================================\n# Step 1: Create System\n# ============================================================================\nfis = MamdaniSystem(\n    name=\"Temperature Controller\",\n    defuzzification_method=DefuzzMethod.CENTROID\n)\n\n# ============================================================================\n# Step 2: Add Variables\n# ============================================================================\nfis.add_input('temperature', (0, 100))\nfis.add_input('humidity', (0, 100))\nfis.add_output('fan_speed', (0, 100))\n\n# ============================================================================\n# Step 3: Generate Membership Functions Automatically\n# ============================================================================\nfis.add_auto_mfs('temperature', n_mfs=3, mf_type='triangular')\nfis.add_auto_mfs('humidity', n_mfs=3, mf_type='triangular')\nfis.add_auto_mfs('fan_speed', n_mfs=3, mf_type='triangular')\n\n# ============================================================================\n# Step 4: Add Rules\n# ============================================================================\nfis.add_rules([\n    {'temperature': 'very low', 'humidity': 'very low', 'fan_speed': 'very low'},\n    {'temperature': 'very low', 'humidity': 'medium', 'fan_speed': 'very low'},\n    {'temperature': 'very low', 'humidity': 'very high', 'fan_speed': 'medium'},\n    {'temperature': 'medium', 'humidity': 'very low', 'fan_speed': 'very low'},\n    {'temperature': 'medium', 'humidity': 'medium', 'fan_speed': 'medium'},\n    {'temperature': 'medium', 'humidity': 'very high', 'fan_speed': 'medium'},\n    {'temperature': 'very high', 'humidity': 'very low', 'fan_speed': 'medium'},\n    {'temperature': 'very high', 'humidity': 'medium', 'fan_speed': 'very high'},\n    {'temperature': 'very high', 'humidity': 'very high', 'fan_speed': 'very high'}\n])\n\n# ============================================================================\n# Step 5: Evaluate System\n# ============================================================================\n# Single evaluation\noutput = fis.evaluate(temperature=75, humidity=60)\nprint(f\"Temperature: 75\u00b0C, Humidity: 60%\")\nprint(f\"Fan Speed: {output['fan_speed']:.2f}%\")\nprint()\n\n# Multiple evaluations\nprint(\"System Response Table:\")\nprint(f\"{'Temperature':&lt;12} {'Humidity':&lt;12} {'Fan Speed':&lt;12}\")\nprint(\"-\" * 40)\n\nfor temp in [20, 40, 60, 80]:\n    for hum in [30, 60, 90]:\n        result = fis.evaluate(temperature=temp, humidity=hum)\n        print(f\"{temp:&lt;12} {hum:&lt;12} {result['fan_speed']:&lt;12.2f}\")\n\n# ============================================================================\n# Step 6: Visualize\n# ============================================================================\n# Plot membership functions\nfis.plot_variables()\n\n# Plot control surface\nfis.plot_output('fan_speed', resolution=50)\n\n# Plot rule matrix\nfis.plot_rule_matrix('temperature', 'humidity', 'fan_speed')\n\n# ============================================================================\n# Step 7: Save System\n# ============================================================================\nfis.save('temperature_controller.fis')\nprint(\"System saved successfully!\")\n\n# Export rules\nrules = fis.export_rules()\nwith open('rules.json', 'w') as f:\n    json.dump(rules, f, indent=2)\nprint(\"Rules exported successfully!\")\n</code></pre>"},{"location":"quick_start/mamdani_system/#11-tips-and-best-practices","title":"11. Tips and Best Practices","text":""},{"location":"quick_start/mamdani_system/#system-design","title":"System Design","text":"<ul> <li>Start simple: Begin with 2-3 membership functions per variable</li> <li>Use <code>add_auto_mfs()</code>: Faster than manual definition for symmetric distributions</li> <li>Triangular MFs: Good default choice (simple, efficient)</li> <li>Gaussian MFs: Better for smooth control surfaces</li> <li>Rule coverage: Ensure rules cover all important input combinations</li> </ul>"},{"location":"quick_start/mamdani_system/#membership-function-selection","title":"Membership Function Selection","text":"MF Type Best For Advantages Disadvantages Triangular General-purpose, control Simple, fast, interpretable Sharp peaks Gaussian Smooth control, modeling Smooth, differentiable More parameters Trapezoidal Flat regions, classification Stable plateau More parameters Bell Smooth transitions Very smooth Computationally expensive"},{"location":"quick_start/mamdani_system/#defuzzification-methods","title":"Defuzzification Methods","text":"<ul> <li>Centroid: Most common, balanced (default choice)</li> <li>Bisector: Similar to centroid but may be faster</li> <li>MOM/SOM/LOM: Use when you need extreme values</li> <li>For control: Use centroid or bisector</li> <li>For classification: Consider MOM (mean of maximum)</li> </ul>"},{"location":"quick_start/mamdani_system/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Reduce <code>num_points</code>: Use 100-500 for evaluation (default: 1000)</li> <li>Minimize rules: More rules = slower inference</li> <li>Use triangular MFs: Fastest computation</li> <li>Cache evaluations: Store results if inputs repeat</li> </ul>"},{"location":"quick_start/mamdani_system/#rule-design","title":"Rule Design","text":"<ul> <li>Complete rule base: Cover all critical regions</li> <li>Avoid contradictions: Don't assign different outputs to same inputs</li> <li>Use weights: Instead of removing rules, reduce weight (0.1-0.5)</li> <li>Test edge cases: Verify behavior at universe boundaries</li> </ul>"},{"location":"quick_start/mamdani_system/#visualization-best-practices","title":"Visualization Best Practices","text":"<ul> <li>Plot early: Visualize MFs before adding rules</li> <li>Check surface: Use <code>plot_output()</code> to verify system behavior</li> <li>Rule matrix: Useful for debugging 2-input systems</li> <li>Document decisions: Save plots with system versions</li> </ul>"},{"location":"quick_start/mamdani_system/#debugging","title":"Debugging","text":"<pre><code># Use detailed evaluation to debug\nresult = fis.evaluate_detailed(temperature=50, humidity=50)\n\n# Check which rules fired\nfor i, activation in enumerate(result['rule_activations']):\n    if activation &gt; 0.01:\n        rule = fis.rule_base.rules[i]\n        print(f\"Rule {i}: activation = {activation:.3f}\")\n        print(f\"  {rule}\")\n</code></pre>"},{"location":"quick_start/mamdani_system/#12-common-issues-and-solutions","title":"12. Common Issues and Solutions","text":"Problem Cause Solution Output always constant Only one rule fires Add more rules, check MF overlap Output at universe boundary Defuzzification issue Check rule consequents, verify MF coverage Slow evaluation Too many points Reduce <code>num_points</code> parameter Unexpected behavior Rule contradictions Review rule base with <code>export_rules()</code> NaN output No rules fire Check input ranges, MF coverage Jerky control surface Sharp MF transitions Use Gaussian instead of triangular"},{"location":"quick_start/mamdani_system/#13-comparison-with-sugeno-systems","title":"13. Comparison with Sugeno Systems","text":"Aspect Mamdani Sugeno Output Fuzzy sets Mathematical functions Interpretability High (linguistic) Medium (numeric) Computation Slower (defuzzification) Faster (weighted average) Learning Harder to optimize Easier (linear consequents) Control Better for complex Better for simple Best for Human interpretation Mathematical optimization"},{"location":"quick_start/mamdani_system/#14-advanced-features","title":"14. Advanced Features","text":""},{"location":"quick_start/mamdani_system/#custom-t-norms-and-s-norms","title":"Custom T-norms and S-norms","text":"<pre><code>from fuzzy_systems.core.membership_functions import TNorm, SNorm\n\n# Use different operators\nfis = MamdaniSystem(\n    and_method=TNorm.PRODUCT,      # Product T-norm\n    or_method=SNorm.PROBOR         # Probabilistic OR\n)\n</code></pre>"},{"location":"quick_start/mamdani_system/#custom-defuzzification-points","title":"Custom Defuzzification Points","text":"<pre><code># Use more points for smoother defuzzification\noutput = fis.evaluate(temperature=75, humidity=60, num_points=2000)\n</code></pre>"},{"location":"quick_start/mamdani_system/#weighted-rules","title":"Weighted Rules","text":"<pre><code># Add rules with different importance\nfis.add_rule({\n    'temperature': 'very high',\n    'humidity': 'very high',\n    'fan_speed': 'very high',\n    'weight': 1.0  # Critical rule\n})\n\nfis.add_rule({\n    'temperature': 'medium',\n    'humidity': 'medium',\n    'fan_speed': 'medium',\n    'weight': 0.5  # Less important\n})\n</code></pre>"},{"location":"quick_start/mamdani_system/#references","title":"References","text":"<ul> <li>Mamdani, E. H., &amp; Assilian, S. (1975). \"An experiment in linguistic synthesis with a fuzzy logic controller.\" International Journal of Man-Machine Studies, 7(1), 1-13.</li> <li>Zadeh, L. A. (1965). \"Fuzzy sets.\" Information and Control, 8(3), 338-353.</li> </ul>"},{"location":"quick_start/pfuzzy_continuous/","title":"p-Fuzzy Continuous System Quick Start Guide","text":""},{"location":"quick_start/pfuzzy_continuous/#overview","title":"Overview","text":"<p>p-Fuzzy Continuous systems are continuous-time dynamical systems where the evolution is governed by ordinary differential equations (ODEs) with fuzzy inference rules.</p> <p>Key Concept: <pre><code>dx/dt = f(x)           [absolute mode]\ndx/dt = x \u00d7 f(x)       [relative mode]\n</code></pre></p> <p>Where <code>f(x)</code> is determined by a Fuzzy Inference System (FIS).</p> <p>Applications: - Population dynamics (continuous growth models) - Chemical reactions and enzyme kinetics - Temperature/cooling systems - Ecological models - Continuous control systems - Physical processes (Newton's law of cooling, etc.)</p> <p>Advantages: - Model continuous processes with linguistic rules - Natural representation of rate-based systems - Smooth trajectories (no discretization artifacts) - Integrate expert knowledge without explicit equations</p>"},{"location":"quick_start/pfuzzy_continuous/#1-basic-concepts","title":"1. Basic Concepts","text":""},{"location":"quick_start/pfuzzy_continuous/#what-is-a-p-fuzzy-continuous-system","title":"What is a p-Fuzzy Continuous System?","text":"<p>A p-Fuzzy continuous system models dynamics using differential equations where the derivative is defined by fuzzy rules:</p> <p>Mathematical Form: <pre><code>dx\u2081/dt = f\u2081(x\u2081, x\u2082, ..., x\u2099)\ndx\u2082/dt = f\u2082(x\u2081, x\u2082, ..., x\u2099)\n...\ndx\u2099/dt = f\u2099(x\u2081, x\u2082, ..., x\u2099)\n</code></pre></p> <p>Where each <code>f\u1d62</code> is computed by the FIS.</p>"},{"location":"quick_start/pfuzzy_continuous/#evolution-modes","title":"Evolution Modes","text":"<p>Absolute Mode (additive change): <pre><code>dx/dt = f(x)\n</code></pre> - Rate of change is independent of current state magnitude - Example: Newton's law of cooling: dT/dt = -k(T - T_ambient)</p> <p>Relative Mode (multiplicative change): <pre><code>dx/dt = x \u00d7 f(x)\n</code></pre> - Rate of change is proportional to current state - Example: Exponential growth: dN/dt = r \u00d7 N</p>"},{"location":"quick_start/pfuzzy_continuous/#integration-methods","title":"Integration Methods","text":"<p>The system supports two numerical integration methods:</p> <p>Euler Method (1<sup>st</sup> order): - Simple and fast - Less accurate (O(h\u00b2) error) - Requires smaller time steps</p> <p>Runge-Kutta 4<sup>th</sup> Order (RK4) (recommended): - More accurate (O(h\u2075) error) - Allows larger time steps - Better for smooth solutions</p>"},{"location":"quick_start/pfuzzy_continuous/#2-creating-a-p-fuzzy-continuous-system","title":"2. Creating a p-Fuzzy Continuous System","text":""},{"location":"quick_start/pfuzzy_continuous/#step-1-create-the-fuzzy-inference-system","title":"Step 1: Create the Fuzzy Inference System","text":"<pre><code>import fuzzy_systems as fs\n\n# Create FIS\nfis = fs.MamdaniSystem(name=\"Cooling System\")\n\n# Input: current temperature\nfis.add_input('temperature', (0, 100))\nfis.add_term('temperature', 'cold', 'triangular', (0, 0, 50))\nfis.add_term('temperature', 'warm', 'triangular', (0, 50, 100))\nfis.add_term('temperature', 'hot', 'triangular', (50, 100, 100))\n\n# Output: cooling rate (dT/dt)\nfis.add_output('cooling_rate', (-10, 0))\nfis.add_term('cooling_rate', 'fast', 'triangular', (-10, -10, -5))\nfis.add_term('cooling_rate', 'medium', 'triangular', (-10, -5, 0))\nfis.add_term('cooling_rate', 'slow', 'triangular', (-5, 0, 0))\n\n# Rules\nfis.add_rules([\n    {'temperature': 'hot', 'cooling_rate': 'fast'},\n    {'temperature': 'warm', 'cooling_rate': 'medium'},\n    {'temperature': 'cold', 'cooling_rate': 'slow'}\n])\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#step-2-create-p-fuzzy-continuous-system","title":"Step 2: Create p-Fuzzy Continuous System","text":"<pre><code>from fuzzy_systems.dynamics import PFuzzyContinuous\n\npfuzzy = PFuzzyContinuous(\n    fis=fis,\n    mode='absolute',               # 'absolute' or 'relative'\n    state_vars=['temperature'],    # State variable names\n    method='rk4'                   # Integration: 'euler' or 'rk4'\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>fis</code>: Fuzzy inference system (Mamdani or Sugeno)</li> <li><code>mode</code>: Evolution mode</li> <li><code>'absolute'</code>: dx/dt = f(x)</li> <li><code>'relative'</code>: dx/dt = x \u00d7 f(x)</li> <li><code>state_vars</code>: List of state variable names (optional)</li> <li>If <code>None</code>, uses all FIS input variables</li> <li><code>method</code>: Numerical integration method</li> <li><code>'euler'</code>: Euler method (simpler, less accurate)</li> <li><code>'rk4'</code>: Runge-Kutta 4<sup>th</sup> order (recommended)</li> </ul>"},{"location":"quick_start/pfuzzy_continuous/#3-simulating-the-system","title":"3. Simulating the System","text":""},{"location":"quick_start/pfuzzy_continuous/#fixed-time-step-simulation","title":"Fixed Time Step Simulation","text":"<pre><code># Initial condition\nx0 = {'temperature': 80.0}\n\n# Time span: from t=0 to t=10\nt_span = (0, 10)\n\n# Fixed time step\ndt = 0.1\n\n# Simulate\ntime, trajectory = pfuzzy.simulate(\n    x0=x0,\n    t_span=t_span,\n    dt=dt,\n    adaptive=False,\n    verbose=False\n)\n\nprint(f\"Time points: {len(time)}\")\nprint(f\"Final temperature: {trajectory[-1, 0]:.2f}\")\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#adaptive-time-step-simulation-recommended","title":"Adaptive Time Step Simulation (Recommended)","text":"<pre><code># Adaptive simulation (automatically adjusts dt)\ntime, trajectory = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 10),\n    adaptive=True,              # Enable adaptive stepping\n    dt=0.1,                     # Initial step size\n    tolerance=1e-4,             # Error tolerance\n    dt_min=1e-5,                # Minimum step size\n    dt_max=1.0,                 # Maximum step size\n    verbose=True                # Print statistics\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#simulation-parameters","title":"Simulation Parameters","text":"<p>Basic Parameters: - <code>x0</code>: Initial condition (dict, list, or array) - <code>t_span</code>: Tuple <code>(t_start, t_end)</code> defining time interval - <code>dt</code>: Time step size (default: 0.05 for fixed, 0.1 for adaptive) - <code>verbose</code>: Print progress information</p> <p>Adaptive Parameters: - <code>adaptive</code>: Enable adaptive time stepping (default: <code>False</code>) - <code>tolerance</code>: Local error tolerance (default: 1e-4)   - Smaller = more accurate, more steps   - Larger = less accurate, fewer steps - <code>dt_min</code>: Minimum allowed step size (default: 1e-5) - <code>dt_max</code>: Maximum allowed step size (default: 1.0) - <code>max_steps</code>: Maximum number of steps (safety limit, default: 100000)</p> <p>Returns: - <code>time</code>: Array of time points (variable length if adaptive) - <code>trajectory</code>: Array of shape <code>(n_points, n_vars)</code> with states</p>"},{"location":"quick_start/pfuzzy_continuous/#4-fixed-vs-adaptive-stepping","title":"4. Fixed vs Adaptive Stepping","text":""},{"location":"quick_start/pfuzzy_continuous/#when-to-use-fixed-stepping","title":"When to Use Fixed Stepping","text":"<pre><code>time, traj = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 10),\n    dt=0.01,\n    adaptive=False\n)\n</code></pre> <p>Best for: - Simple systems with smooth behavior - When you need regular time intervals - Debugging and understanding system behavior - Fast simulations with known dynamics</p> <p>Considerations: - Choose <code>dt</code> carefully (too large = inaccurate, too small = slow) - RK4 allows larger <code>dt</code> than Euler</p>"},{"location":"quick_start/pfuzzy_continuous/#when-to-use-adaptive-stepping-recommended","title":"When to Use Adaptive Stepping (Recommended)","text":"<pre><code>time, traj = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 10),\n    adaptive=True,\n    tolerance=1e-4\n)\n</code></pre> <p>Best for: - Systems with regions of rapid change - When accuracy is critical - Long simulations - Unknown system behavior</p> <p>Advantages: - Automatically finds optimal step size - Faster than fixed stepping with same accuracy - Fewer total steps in smooth regions - Smaller steps only where needed</p> <p>Statistics Output (verbose=True): <pre><code>M\u00e9todo: RK4\nPassos aceitos: 245\nPassos rejeitados: 12\nTaxa de aceita\u00e7\u00e3o: 95.3%\ndt m\u00e9dio: 0.04892\ndt m\u00ednimo: 0.00234\ndt m\u00e1ximo: 0.15000\n</code></pre></p>"},{"location":"quick_start/pfuzzy_continuous/#5-initial-conditions-multiple-formats","title":"5. Initial Conditions - Multiple Formats","text":"<pre><code># Format 1: Dictionary (recommended)\nx0 = {'temperature': 80.0}\n\n# Format 2: List\nx0 = [80.0]\n\n# Format 3: Tuple\nx0 = (80.0,)\n\n# Format 4: NumPy array\nimport numpy as np\nx0 = np.array([80.0])\n\n# Multi-variable systems:\nx0_dict = {'prey': 50.0, 'predator': 30.0}\nx0_list = [50.0, 30.0]\nx0_array = np.array([50.0, 30.0])\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#6-visualization","title":"6. Visualization","text":""},{"location":"quick_start/pfuzzy_continuous/#plot-trajectory-time-series","title":"Plot Trajectory (Time Series)","text":"<pre><code># Plot all state variables over time\nfig, ax = pfuzzy.plot_trajectory(\n    variables=None,                  # None = all variables\n    figsize=(12, 6),\n    title='Temperature Cooling',\n    xlabel='Time (s)',\n    ylabel='Temperature (\u00b0C)'\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#plot-phase-space-2d-systems","title":"Plot Phase Space (2D Systems)","text":"<pre><code># Phase portrait for 2-variable systems\nfig, ax = pfuzzy.plot_phase_space(\n    var_x='prey',\n    var_y='predator',\n    figsize=(8, 8),\n    title='Predator-Prey Phase Portrait'\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#custom-plots","title":"Custom Plots","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Access stored results\ntime = pfuzzy.time\ntrajectory = pfuzzy.trajectory\n\n# Custom plot with derivatives\ndt_vals = np.diff(time)\ndx_vals = np.diff(trajectory[:, 0]) / dt_vals\n\nplt.figure(figsize=(12, 5))\n\nplt.subplot(1, 2, 1)\nplt.plot(time, trajectory[:, 0], 'b-', linewidth=2)\nplt.xlabel('Time')\nplt.ylabel('State')\nplt.title('State vs Time')\nplt.grid(True)\n\nplt.subplot(1, 2, 2)\nplt.plot(time[:-1], dx_vals, 'r-', linewidth=2)\nplt.xlabel('Time')\nplt.ylabel('dx/dt')\nplt.title('Rate of Change')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#7-exporting-results","title":"7. Exporting Results","text":""},{"location":"quick_start/pfuzzy_continuous/#export-to-csv","title":"Export to CSV","text":"<pre><code># Standard format\npfuzzy.to_csv('results.csv')\n\n# European/Brazilian format\npfuzzy.to_csv(\n    'results.csv',\n    sep=';',\n    decimal=','\n)\n</code></pre> <p>CSV Format: <pre><code>time,temperature\n0.000000,80.000000\n0.100000,78.542100\n0.200000,77.143521\n...\n</code></pre></p>"},{"location":"quick_start/pfuzzy_continuous/#8-complete-example-newtons-law-of-cooling","title":"8. Complete Example: Newton's Law of Cooling","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport fuzzy_systems as fs\nfrom fuzzy_systems.dynamics import PFuzzyContinuous\n\n# ============================================================================\n# Newton's Law of Cooling: dT/dt = -k(T - T_ambient)\n# Fuzzy version: cooling rate determined by rules\n# ============================================================================\n\n# Create FIS\nfis = fs.MamdaniSystem(name=\"Newton Cooling\")\n\n# Input: temperature difference from ambient (20\u00b0C)\nfis.add_input('temperature', (0, 100))\nfis.add_term('temperature', 'ambient', 'gaussian', (20, 5))\nfis.add_term('temperature', 'warm', 'gaussian', (50, 10))\nfis.add_term('temperature', 'hot', 'gaussian', (80, 10))\n\n# Output: cooling rate\nfis.add_output('cooling_rate', (-15, 0))\nfis.add_term('cooling_rate', 'fast', 'triangular', (-15, -15, -8))\nfis.add_term('cooling_rate', 'medium', 'triangular', (-12, -6, -2))\nfis.add_term('cooling_rate', 'slow', 'triangular', (-4, 0, 0))\n\n# Rules: hotter \u2192 cools faster\nfis.add_rules([\n    {'temperature': 'hot', 'cooling_rate': 'fast'},\n    {'temperature': 'warm', 'cooling_rate': 'medium'},\n    {'temperature': 'ambient', 'cooling_rate': 'slow'}\n])\n\n# Create p-Fuzzy system\npfuzzy = PFuzzyContinuous(\n    fis=fis,\n    mode='absolute',\n    state_vars=['temperature'],\n    method='rk4'\n)\n\n# Simulate\nx0 = {'temperature': 95.0}\ntime, trajectory = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 20),\n    adaptive=True,\n    tolerance=1e-4,\n    verbose=True\n)\n\n# Visualize\npfuzzy.plot_trajectory(\n    title=\"Newton's Law of Cooling (Fuzzy)\",\n    xlabel='Time (minutes)',\n    ylabel='Temperature (\u00b0C)'\n)\n\n# Export\npfuzzy.to_csv('cooling_curve.csv')\nprint(f\"\u2705 Final temperature: {trajectory[-1, 0]:.2f}\u00b0C\")\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#9-complete-example-lotka-volterra-predator-prey","title":"9. Complete Example: Lotka-Volterra Predator-Prey","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport fuzzy_systems as fs\nfrom fuzzy_systems.dynamics import PFuzzyContinuous\n\n# ============================================================================\n# Lotka-Volterra Predator-Prey Model (Fuzzy version)\n# ============================================================================\n\nfis = fs.MamdaniSystem(name=\"Lotka-Volterra Fuzzy\")\n\n# Inputs: prey and predator populations\nfis.add_input('prey', (0, 100))\nfis.add_input('predator', (0, 100))\n\n# Membership functions (4 levels each)\nfor var in ['prey', 'predator']:\n    fis.add_term(var, 'low', 'gaussian', (10, 8))\n    fis.add_term(var, 'medium_low', 'gaussian', (35, 8))\n    fis.add_term(var, 'medium_high', 'gaussian', (65, 8))\n    fis.add_term(var, 'high', 'gaussian', (90, 8))\n\n# Outputs: growth/decline rates\nfis.add_output('prey_rate', (-3, 3))\nfis.add_output('predator_rate', (-3, 3))\n\nfor var in ['prey_rate', 'predator_rate']:\n    fis.add_term(var, 'large_decrease', 'triangular', (-3, -3, -1.5))\n    fis.add_term(var, 'small_decrease', 'triangular', (-2, -1, 0))\n    fis.add_term(var, 'small_increase', 'triangular', (0, 1, 2))\n    fis.add_term(var, 'large_increase', 'triangular', (1.5, 3, 3))\n\n# Rules (example subset - add more for complete model)\nfis.add_rules([\n    # Many prey, few predators \u2192 prey increase, predators increase\n    {'prey': 'high', 'predator': 'low',\n     'prey_rate': 'small_increase', 'predator_rate': 'large_increase'},\n\n    # Few prey, many predators \u2192 prey decrease, predators decrease\n    {'prey': 'low', 'predator': 'high',\n     'prey_rate': 'large_decrease', 'predator_rate': 'large_decrease'},\n\n    # Balanced populations\n    {'prey': 'medium_high', 'predator': 'medium_low',\n     'prey_rate': 'small_increase', 'predator_rate': 'small_increase'},\n\n    {'prey': 'medium_low', 'predator': 'medium_high',\n     'prey_rate': 'small_decrease', 'predator_rate': 'small_decrease'},\n\n    # Add more rules for complete coverage...\n])\n\n# Create p-Fuzzy system\npfuzzy = PFuzzyContinuous(\n    fis=fis,\n    mode='absolute',\n    state_vars=['prey', 'predator'],\n    method='rk4'\n)\n\n# Simulate multiple initial conditions\ninitial_conditions = [\n    {'prey': 60, 'predator': 30},\n    {'prey': 40, 'predator': 50},\n    {'prey': 70, 'predator': 20}\n]\n\nplt.figure(figsize=(14, 6))\n\n# Time series\nplt.subplot(1, 2, 1)\nfor i, x0 in enumerate(initial_conditions):\n    time, traj = pfuzzy.simulate(\n        x0=x0,\n        t_span=(0, 50),\n        adaptive=True,\n        tolerance=1e-4\n    )\n    plt.plot(time, traj[:, 0], '--', label=f'Prey IC{i+1}', alpha=0.7)\n    plt.plot(time, traj[:, 1], '-', label=f'Predator IC{i+1}', alpha=0.7)\n\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.title('Lotka-Volterra Dynamics')\nplt.legend()\nplt.grid(True)\n\n# Phase portrait\nplt.subplot(1, 2, 2)\nfor i, x0 in enumerate(initial_conditions):\n    time, traj = pfuzzy.simulate(x0=x0, t_span=(0, 50), adaptive=True)\n    plt.plot(traj[:, 0], traj[:, 1], linewidth=2, label=f'IC{i+1}')\n    plt.plot(traj[0, 0], traj[0, 1], 'go', markersize=8)\n    plt.plot(traj[-1, 0], traj[-1, 1], 'ro', markersize=8)\n\nplt.xlabel('Prey Population')\nplt.ylabel('Predator Population')\nplt.title('Phase Portrait')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# Export last simulation\npfuzzy.to_csv('lotka_volterra.csv')\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#10-tips-and-best-practices","title":"10. Tips and Best Practices","text":""},{"location":"quick_start/pfuzzy_continuous/#choosing-integration-method","title":"Choosing Integration Method","text":"Method Accuracy Speed When to Use Euler Low (O(h\u00b2)) Fast Quick tests, simple systems RK4 High (O(h\u2075)) Slower Production, accurate results <p>Recommendation: Always use RK4 unless speed is critical.</p>"},{"location":"quick_start/pfuzzy_continuous/#choosing-time-step-fixed-stepping","title":"Choosing Time Step (Fixed Stepping)","text":"<pre><code># Too large: inaccurate, unstable\ndt = 1.0  # \u274c May miss dynamics\n\n# Good balance\ndt = 0.01  # \u2705 Typical choice\n\n# Too small: slow, unnecessary\ndt = 1e-6  # \u274c Wasteful\n</code></pre> <p>Rule of thumb: - Euler: dt \u2248 0.001 - 0.01 - RK4: dt \u2248 0.01 - 0.1</p>"},{"location":"quick_start/pfuzzy_continuous/#using-adaptive-stepping-effectively","title":"Using Adaptive Stepping Effectively","text":"<pre><code># High accuracy: scientific computing\npfuzzy.simulate(x0=x0, t_span=(0, 10), adaptive=True, tolerance=1e-6)\n\n# Standard accuracy: most applications\npfuzzy.simulate(x0=x0, t_span=(0, 10), adaptive=True, tolerance=1e-4)\n\n# Fast approximation: visualization\npfuzzy.simulate(x0=x0, t_span=(0, 10), adaptive=True, tolerance=1e-2)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#system-design","title":"System Design","text":"<ol> <li> <p>Output ranges must match dynamics scale: <pre><code># Temperature cooling: expect changes of ~10\u00b0C/min\nfis.add_output('cooling_rate', (-15, 5))  # \u2705\n\n# Not: (-100, 100)  # \u274c Too large\n</code></pre></p> </li> <li> <p>Absolute vs Relative mode:</p> </li> <li>Absolute (<code>dx/dt = f(x)</code>): Most common, natural interpretation</li> <li> <p>Relative (<code>dx/dt = x\u00b7f(x)</code>): Use when rate proportional to state</p> </li> <li> <p>Domain boundaries:</p> </li> <li>System stops if state exits input universe</li> <li>Make universes large enough for expected trajectories</li> </ol>"},{"location":"quick_start/pfuzzy_continuous/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Long simulations: use adaptive with relaxed tolerance\ntime, traj = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 1000),\n    adaptive=True,\n    tolerance=1e-3,  # Relaxed\n    dt_max=0.5       # Allow larger steps\n)\n\n# Short, accurate simulations: fixed step with RK4\ntime, traj = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 10),\n    dt=0.01,\n    adaptive=False,\n    method='rk4'\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#11-common-patterns","title":"11. Common Patterns","text":""},{"location":"quick_start/pfuzzy_continuous/#pattern-1-exponential-decay","title":"Pattern 1: Exponential Decay","text":"<pre><code># dx/dt = -k\u00b7x  (k &gt; 0)\nfis.add_rules([\n    {'state': 'high', 'rate': 'large_negative'},\n    {'state': 'medium', 'rate': 'medium_negative'},\n    {'state': 'low', 'rate': 'small_negative'}\n])\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#pattern-2-logistic-growth","title":"Pattern 2: Logistic Growth","text":"<pre><code># dx/dt = r\u00b7x\u00b7(1 - x/K)\nfis.add_rules([\n    {'state': 'low', 'rate': 'positive'},     # Below capacity: grow\n    {'state': 'medium', 'rate': 'positive'},  # Near capacity: slow growth\n    {'state': 'high', 'rate': 'negative'}     # Above capacity: decline\n])\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#pattern-3-oscillator-limit-cycle","title":"Pattern 3: Oscillator (Limit Cycle)","text":"<pre><code># Two variables: dx/dt = f(x,y), dy/dt = g(x,y)\nfis.add_rules([\n    {'x': 'positive', 'y': 'low', 'x_rate': 'positive', 'y_rate': 'positive'},\n    {'x': 'high', 'y': 'positive', 'x_rate': 'negative', 'y_rate': 'positive'},\n    {'x': 'negative', 'y': 'high', 'x_rate': 'negative', 'y_rate': 'negative'},\n    {'x': 'low', 'y': 'negative', 'x_rate': 'positive', 'y_rate': 'negative'}\n])\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#12-common-issues-and-solutions","title":"12. Common Issues and Solutions","text":"Problem Cause Solution Simulation stops early State exits domain Increase input universe range Oscillations/instability dt too large (Euler) Use RK4 or smaller dt Slow simulation dt too small Use adaptive stepping or increase dt Flat trajectory Output ranges too small Scale up output universe Inaccurate results Tolerance too large Decrease tolerance (adaptive) dt hits minimum Stiff system or tolerance too tight Relax tolerance or check FIS"},{"location":"quick_start/pfuzzy_continuous/#debugging-unstable-simulations","title":"Debugging Unstable Simulations","text":"<pre><code># Check FIS behavior at test points\ntest_state = {'temperature': 50}\noutput = fis.evaluate(test_state)\nprint(f\"At T=50: dT/dt = {output['cooling_rate']}\")\n\n# Use verbose mode\ntime, traj = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 10),\n    adaptive=True,\n    verbose=True  # Shows step acceptance/rejection\n)\n\n# Try smaller time step\ntime, traj = pfuzzy.simulate(\n    x0=x0,\n    t_span=(0, 10),\n    dt=0.001,  # Very small\n    adaptive=False\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#13-absolute-vs-relative-mode","title":"13. Absolute vs Relative Mode","text":""},{"location":"quick_start/pfuzzy_continuous/#absolute-mode-dxdt-fx","title":"Absolute Mode: dx/dt = f(x)","text":"<pre><code>mode='absolute'\n</code></pre> <p>Characteristics: - Rate of change independent of current value - Most intuitive and common - Natural for: cooling, chemical reactions, oscillators</p> <p>Example: Cooling <pre><code>dT/dt = -5  # Temperature decreases by 5\u00b0C/min regardless of T\n</code></pre></p>"},{"location":"quick_start/pfuzzy_continuous/#relative-mode-dxdt-x-fx","title":"Relative Mode: dx/dt = x \u00d7 f(x)","text":"<pre><code>mode='relative'\n</code></pre> <p>Characteristics: - Rate proportional to current state - Natural for growth processes - Output interpreted as relative rate</p> <p>Example: Population Growth <pre><code>dN/dt = N \u00d7 0.1  # Population grows at 10% per unit time\n</code></pre></p> <p>Output Guidelines: - <code>f(x) = 0</code>: No change - <code>f(x) &gt; 0</code>: Growth - <code>f(x) &lt; 0</code>: Decline - Typical range: (-1, 1) for \u00b1100% rates</p>"},{"location":"quick_start/pfuzzy_continuous/#14-comparison-discrete-vs-continuous","title":"14. Comparison: Discrete vs Continuous","text":"Aspect Discrete Continuous Time Integer steps (n) Real time (t\u2208\u211d) Equation x_{n+1} = x_n + f(x_n) dx/dt = f(x) Simulation Simple iteration Numerical integration Smoothness Discrete jumps Smooth curves Speed Faster Slower (integration) Accuracy Exact (per iteration) Depends on dt, method Best for Generations, events Physical processes"},{"location":"quick_start/pfuzzy_continuous/#15-advanced-vector-field-analysis","title":"15. Advanced: Vector Field Analysis","text":"<p>Visualize the system dynamics with vector fields:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Create grid\nx_grid = np.linspace(0, 100, 20)\ny_grid = np.linspace(0, 100, 20)\nX, Y = np.meshgrid(x_grid, y_grid)\n\n# Compute vector field\nDX = np.zeros_like(X)\nDY = np.zeros_like(Y)\n\nfor i in range(len(x_grid)):\n    for j in range(len(y_grid)):\n        state = {'prey': X[j, i], 'predator': Y[j, i]}\n        output = fis.evaluate(state)\n        DX[j, i] = output['prey_rate']\n        DY[j, i] = output['predator_rate']\n\n# Plot vector field + trajectory\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Vector field\nax.quiver(X, Y, DX, DY, alpha=0.5, color='gray')\n\n# Simulate and overlay trajectory\ntime, traj = pfuzzy.simulate(\n    x0={'prey': 60, 'predator': 30},\n    t_span=(0, 50),\n    adaptive=True\n)\nax.plot(traj[:, 0], traj[:, 1], 'b-', linewidth=3, label='Trajectory')\nax.plot(traj[0, 0], traj[0, 1], 'go', markersize=12, label='Start')\nax.plot(traj[-1, 0], traj[-1, 1], 'ro', markersize=12, label='End')\n\nax.set_xlabel('Prey')\nax.set_ylabel('Predator')\nax.set_title('Phase Portrait with Vector Field')\nax.legend()\nax.grid(True)\nplt.show()\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#16-advanced-comparing-methods","title":"16. Advanced: Comparing Methods","text":"<pre><code>import time as timer\n\nmethods = ['euler', 'rk4']\nresults = {}\n\nfor method in methods:\n    pfuzzy = PFuzzyContinuous(fis=fis, mode='absolute', method=method)\n\n    # Time the simulation\n    start = timer.time()\n    t, traj = pfuzzy.simulate(x0=x0, t_span=(0, 10), dt=0.01)\n    elapsed = timer.time() - start\n\n    results[method] = {\n        'time': elapsed,\n        'final_state': traj[-1],\n        'trajectory': traj\n    }\n\n    print(f\"{method.upper()}: {elapsed:.4f}s, final={traj[-1]}\")\n\n# Plot comparison\nplt.figure(figsize=(12, 5))\nfor method, data in results.items():\n    plt.plot(pfuzzy.time, data['trajectory'], linewidth=2, label=method.upper())\n\nplt.xlabel('Time')\nplt.ylabel('State')\nplt.title('Euler vs RK4 Comparison')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#17-advanced-stiff-systems","title":"17. Advanced: Stiff Systems","text":"<p>For stiff systems (very different time scales), adaptive stepping helps:</p> <pre><code># Fast and slow dynamics\nfis = fs.MamdaniSystem()\nfis.add_input('fast', (0, 10))\nfis.add_input('slow', (0, 10))\nfis.add_output('fast_rate', (-100, 100))  # Fast dynamics\nfis.add_output('slow_rate', (-1, 1))       # Slow dynamics\n\n# ... add terms and rules ...\n\npfuzzy = PFuzzyContinuous(fis=fis, method='rk4')\n\n# Adaptive stepping handles different scales automatically\ntime, traj = pfuzzy.simulate(\n    x0=[5, 5],\n    t_span=(0, 10),\n    adaptive=True,\n    tolerance=1e-4,\n    verbose=True\n)\n\n# Check step size variation\nimport matplotlib.pyplot as plt\ndt_vals = np.diff(time)\nplt.semilogy(time[:-1], dt_vals)\nplt.xlabel('Time')\nplt.ylabel('Step Size (log scale)')\nplt.title('Adaptive Step Size')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"quick_start/pfuzzy_continuous/#references","title":"References","text":"<ul> <li>Barros, L. C., Bassanezi, R. C., &amp; Lodwick, W. A. (2017). A First Course in Fuzzy Logic, Fuzzy Dynamical Systems, and Biomathematics. Springer.</li> <li>Butcher, J. C. (2016). Numerical Methods for Ordinary Differential Equations. John Wiley &amp; Sons.</li> <li>Hairer, E., N\u00f8rsett, S. P., &amp; Wanner, G. (1993). Solving Ordinary Differential Equations I: Nonstiff Problems. Springer.</li> </ul>"},{"location":"quick_start/pfuzzy_discrete/","title":"p-Fuzzy Discrete System Quick Start Guide","text":""},{"location":"quick_start/pfuzzy_discrete/#overview","title":"Overview","text":"<p>p-Fuzzy Discrete systems are discrete-time dynamical systems where the evolution function is defined by fuzzy inference rules instead of explicit mathematical equations.</p> <p>Key Concept: <pre><code>x_{n+1} = x_n + f(x_n)     [absolute mode]\nx_{n+1} = x_n \u00d7 f(x_n)     [relative mode]\n</code></pre></p> <p>Where <code>f(x_n)</code> is determined by a Fuzzy Inference System (FIS).</p> <p>Applications: - Population dynamics (predator-prey, epidemiology) - Economic models with qualitative rules - Discrete control systems - Time-series modeling with expert knowledge</p> <p>Advantages: - Model complex dynamics using linguistic rules - Incorporate expert knowledge without mathematical equations - Natural representation of qualitative relationships - Interpretable system behavior</p>"},{"location":"quick_start/pfuzzy_discrete/#1-basic-concepts","title":"1. Basic Concepts","text":""},{"location":"quick_start/pfuzzy_discrete/#what-is-a-p-fuzzy-system","title":"What is a p-Fuzzy System?","text":"<p>A p-Fuzzy system combines: 1. State variables (x\u2081, x\u2082, ..., x\u2099): System states that evolve over time 2. Fuzzy Inference System: Maps current state to rate of change 3. Evolution mode: How changes are applied (absolute or relative)</p>"},{"location":"quick_start/pfuzzy_discrete/#evolution-modes","title":"Evolution Modes","text":"<p>Absolute Mode (additive change): <pre><code>x_{n+1} = x_n + f(x_n)\n</code></pre> - Change is added to current state - Example: population growth = current + birth_rate</p> <p>Relative Mode (multiplicative change): <pre><code>x_{n+1} = x_n \u00d7 f(x_n)\n</code></pre> - Change is proportional to current state - Example: population growth = current \u00d7 growth_factor</p>"},{"location":"quick_start/pfuzzy_discrete/#2-creating-a-p-fuzzy-discrete-system","title":"2. Creating a p-Fuzzy Discrete System","text":""},{"location":"quick_start/pfuzzy_discrete/#step-1-create-the-fuzzy-inference-system-fis","title":"Step 1: Create the Fuzzy Inference System (FIS)","text":"<p>The FIS defines how state variables evolve based on fuzzy rules.</p> <p>Important: - Inputs: Current state variables - Outputs: Rate of change for each state variable (same order as inputs)</p> <pre><code>import fuzzy_systems as fs\n\n# Create Mamdani or Sugeno FIS\nfis = fs.MamdaniSystem(name=\"Population Growth\")\n\n# Add input: current population\nfis.add_input('population', (0, 100))\nfis.add_term('population', 'low', 'triangular', (0, 0, 50))\nfis.add_term('population', 'medium', 'triangular', (0, 50, 100))\nfis.add_term('population', 'high', 'triangular', (50, 100, 100))\n\n# Add output: population change rate\nfis.add_output('growth_rate', (-10, 10))\nfis.add_term('growth_rate', 'negative', 'triangular', (-10, -10, 0))\nfis.add_term('growth_rate', 'zero', 'triangular', (-5, 0, 5))\nfis.add_term('growth_rate', 'positive', 'triangular', (0, 10, 10))\n\n# Add rules\nfis.add_rules([\n    {'population': 'low', 'growth_rate': 'positive'},     # Low pop \u2192 grow\n    {'population': 'medium', 'growth_rate': 'zero'},      # Medium \u2192 stable\n    {'population': 'high', 'growth_rate': 'negative'}     # High \u2192 decline\n])\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#step-2-create-p-fuzzy-discrete-system","title":"Step 2: Create p-Fuzzy Discrete System","text":"<pre><code>from fuzzy_systems.dynamics import PFuzzyDiscrete\n\npfuzzy = PFuzzyDiscrete(\n    fis=fis,                          # Fuzzy inference system\n    mode='absolute',                  # 'absolute' or 'relative'\n    state_vars=['population']         # State variable names (optional)\n)\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>fis</code>: Fuzzy inference system (Mamdani or Sugeno)</li> <li><code>mode</code>: Evolution mode</li> <li><code>'absolute'</code>: Additive change (x_{n+1} = x_n + f(x_n))</li> <li><code>'relative'</code>: Multiplicative change (x_{n+1} = x_n \u00d7 f(x_n))</li> <li><code>state_vars</code>: List of state variable names (optional)</li> <li>If <code>None</code>, uses all FIS input variables as state variables</li> <li>Must match FIS input variable names</li> </ul> <p>Important: Number of FIS outputs must equal number of state variables!</p>"},{"location":"quick_start/pfuzzy_discrete/#3-simulating-the-system","title":"3. Simulating the System","text":""},{"location":"quick_start/pfuzzy_discrete/#basic-simulation","title":"Basic Simulation","text":"<pre><code># Define initial conditions\nx0 = {'population': 10.0}\n\n# Simulate for 100 time steps\ntime, trajectory = pfuzzy.simulate(\n    x0=x0,\n    n_steps=100,\n    verbose=False\n)\n\n# Access results\nprint(f\"Time points: {time}\")          # [0, 1, 2, ..., 100]\nprint(f\"Trajectory shape: {trajectory.shape}\")  # (101, n_vars)\nprint(f\"Final state: {trajectory[-1]}\")\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#simulation-parameters","title":"Simulation Parameters","text":"<pre><code>time, trajectory = pfuzzy.simulate(\n    x0=x0,              # Initial condition (dict, list, or array)\n    n_steps=100,        # Number of iterations\n    verbose=True        # Print progress information\n)\n</code></pre> <p>Parameters: - <code>x0</code>: Initial condition (multiple formats):   - Dictionary: <code>{'pop': 10.0, 'resource': 50.0}</code>   - List/Tuple: <code>[10.0, 50.0]</code> (order matches state_vars)   - NumPy array: <code>np.array([10.0, 50.0])</code> - <code>n_steps</code>: Number of discrete time steps to simulate - <code>verbose</code>: If <code>True</code>, prints simulation progress</p> <p>Returns: - <code>time</code>: Array of iteration numbers <code>[0, 1, 2, ..., n_steps]</code> - <code>trajectory</code>: Array of shape <code>(n_steps+1, n_vars)</code> with state history</p>"},{"location":"quick_start/pfuzzy_discrete/#4-initial-conditions-multiple-formats","title":"4. Initial Conditions - Multiple Formats","text":"<pre><code># Format 1: Dictionary (recommended - most readable)\nx0 = {'population': 10.0}\n\n# Format 2: List (order must match state_vars)\nx0 = [10.0]\n\n# Format 3: Tuple\nx0 = (10.0,)\n\n# Format 4: NumPy array\nimport numpy as np\nx0 = np.array([10.0])\n\n# For multi-variable systems:\nx0_dict = {'prey': 50.0, 'predator': 30.0}\nx0_list = [50.0, 30.0]  # Order: prey, predator\nx0_array = np.array([50.0, 30.0])\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#5-visualization","title":"5. Visualization","text":""},{"location":"quick_start/pfuzzy_discrete/#plot-trajectory-time-series","title":"Plot Trajectory (Time Series)","text":"<pre><code># Plot all state variables over time\nfig, ax = pfuzzy.plot_trajectory(\n    variables=None,              # None = all variables\n    figsize=(12, 6),\n    title='Population Dynamics',\n    xlabel='Time (steps)',\n    ylabel='Population'\n)\n</code></pre> <p>Parameters: - <code>variables</code>: List of variables to plot (None = all)   - Example: <code>['population']</code> or <code>['prey', 'predator']</code> - <code>figsize</code>: Figure size (width, height) - <code>title</code>: Plot title - <code>xlabel</code>, <code>ylabel</code>: Axis labels</p>"},{"location":"quick_start/pfuzzy_discrete/#plot-phase-space-2d-systems","title":"Plot Phase Space (2D Systems)","text":"<pre><code># Phase space plot for 2-variable systems\nfig, ax = pfuzzy.plot_phase_space(\n    var_x='prey',\n    var_y='predator',\n    figsize=(8, 8),\n    title='Predator-Prey Phase Space'\n)\n</code></pre> <p>Shows trajectory in state space with initial (green) and final (red) points.</p>"},{"location":"quick_start/pfuzzy_discrete/#custom-plots","title":"Custom Plots","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Access stored results\ntime = pfuzzy.time\ntrajectory = pfuzzy.trajectory\n\n# Custom plot\nplt.figure(figsize=(10, 6))\nplt.plot(time, trajectory[:, 0], 'b-', linewidth=2, label='Prey')\nplt.plot(time, trajectory[:, 1], 'r-', linewidth=2, label='Predator')\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#6-exporting-results","title":"6. Exporting Results","text":""},{"location":"quick_start/pfuzzy_discrete/#export-to-csv","title":"Export to CSV","text":"<pre><code># Export trajectory to CSV file\npfuzzy.to_csv('results.csv')\n\n# Custom format (Brazilian/European style)\npfuzzy.to_csv(\n    'results.csv',\n    sep=';',        # Semicolon separator\n    decimal=','     # Comma as decimal separator\n)\n</code></pre> <p>Parameters: - <code>filename</code>: Output file path - <code>sep</code>: Column separator (default: <code>,</code>) - <code>decimal</code>: Decimal separator (default: <code>.</code>)   - Use <code>','</code> for European/Brazilian format</p> <p>CSV Format: <pre><code>time,population\n0.000000,10.000000\n1.000000,12.500000\n2.000000,14.800000\n...\n</code></pre></p>"},{"location":"quick_start/pfuzzy_discrete/#7-single-step-execution","title":"7. Single Step Execution","text":""},{"location":"quick_start/pfuzzy_discrete/#manual-stepping","title":"Manual Stepping","text":"<p>Useful for debugging or custom integration:</p> <pre><code># Execute one iteration manually\nx_current = np.array([10.0])\nx_next = pfuzzy.step(x_current)\n\nprint(f\"Current: {x_current}\")\nprint(f\"Next: {x_next}\")\n\n# Chain multiple steps\nx0 = np.array([10.0])\nx1 = pfuzzy.step(x0)\nx2 = pfuzzy.step(x1)\nx3 = pfuzzy.step(x2)\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#8-complete-example-simple-population","title":"8. Complete Example: Simple Population","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport fuzzy_systems as fs\nfrom fuzzy_systems.dynamics import PFuzzyDiscrete\n\n# ============================================================================\n# Step 1: Create FIS\n# ============================================================================\nfis = fs.MamdaniSystem(name=\"Logistic Growth\")\n\n# Input: current population\nfis.add_input('population', (0, 100))\nfis.add_term('population', 'low', 'gaussian', (10, 10))\nfis.add_term('population', 'medium', 'gaussian', (50, 10))\nfis.add_term('population', 'high', 'gaussian', (90, 10))\n\n# Output: growth rate\nfis.add_output('growth_rate', (-5, 5))\nfis.add_term('growth_rate', 'negative', 'triangular', (-5, -5, 0))\nfis.add_term('growth_rate', 'zero', 'triangular', (-2, 0, 2))\nfis.add_term('growth_rate', 'positive', 'triangular', (0, 5, 5))\n\n# Rules: logistic-like behavior\nfis.add_rules([\n    {'population': 'low', 'growth_rate': 'positive'},     # Low \u2192 grow fast\n    {'population': 'medium', 'growth_rate': 'zero'},      # Medium \u2192 stable\n    {'population': 'high', 'growth_rate': 'negative'}     # High \u2192 decline\n])\n\n# ============================================================================\n# Step 2: Create p-Fuzzy System\n# ============================================================================\npfuzzy = PFuzzyDiscrete(\n    fis=fis,\n    mode='absolute',\n    state_vars=['population']\n)\n\n# ============================================================================\n# Step 3: Simulate\n# ============================================================================\n# Initial condition\nx0 = {'population': 5.0}\n\n# Run simulation\ntime, trajectory = pfuzzy.simulate(\n    x0=x0,\n    n_steps=100,\n    verbose=True\n)\n\n# ============================================================================\n# Step 4: Visualize\n# ============================================================================\npfuzzy.plot_trajectory(\n    title='Logistic Population Growth',\n    xlabel='Time (generations)',\n    ylabel='Population'\n)\n\n# ============================================================================\n# Step 5: Export Results\n# ============================================================================\npfuzzy.to_csv('population_growth.csv')\nprint(\"\u2705 Results saved to population_growth.csv\")\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#9-complete-example-predator-prey-system","title":"9. Complete Example: Predator-Prey System","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport fuzzy_systems as fs\nfrom fuzzy_systems.dynamics import PFuzzyDiscrete\n\n# ============================================================================\n# Step 1: Create FIS for Predator-Prey\n# ============================================================================\nfis = fs.MamdaniSystem(name=\"Predator-Prey\")\n\n# Inputs: prey and predator populations\nfis.add_input('prey', (0, 100))\nfis.add_input('predator', (0, 100))\n\n# Add terms for both variables (4 levels: Low, Medium-Low, Medium-High, High)\nfor var in ['prey', 'predator']:\n    fis.add_term(var, 'low', 'gaussian', (0, 12))\n    fis.add_term(var, 'med_low', 'gaussian', (33, 12))\n    fis.add_term(var, 'med_high', 'gaussian', (67, 12))\n    fis.add_term(var, 'high', 'gaussian', (100, 12))\n\n# Outputs: change rates\nfis.add_output('prey_change', (-10, 10))\nfis.add_output('predator_change', (-10, 10))\n\n# Add terms for outputs\nfor var in ['prey_change', 'predator_change']:\n    fis.add_term(var, 'large_decrease', 'triangular', (-10, -10, -5))\n    fis.add_term(var, 'small_decrease', 'triangular', (-7, -3, 0))\n    fis.add_term(var, 'small_increase', 'triangular', (0, 3, 7))\n    fis.add_term(var, 'large_increase', 'triangular', (5, 10, 10))\n\n# Rules (simplified example - add more for realistic behavior)\nfis.add_rules([\n    # Few predators, many prey \u2192 prey increase, predators increase\n    {'prey': 'high', 'predator': 'low',\n     'prey_change': 'small_increase', 'predator_change': 'large_increase'},\n\n    # Many predators, few prey \u2192 prey decrease, predators decrease\n    {'prey': 'low', 'predator': 'high',\n     'prey_change': 'large_decrease', 'predator_change': 'large_decrease'},\n\n    # Balanced populations \u2192 small changes\n    {'prey': 'med_high', 'predator': 'med_low',\n     'prey_change': 'small_increase', 'predator_change': 'small_increase'},\n\n    # Add more rules for complete coverage...\n])\n\n# ============================================================================\n# Step 2: Create p-Fuzzy System\n# ============================================================================\npfuzzy = PFuzzyDiscrete(\n    fis=fis,\n    mode='absolute',\n    state_vars=['prey', 'predator']\n)\n\n# ============================================================================\n# Step 3: Simulate Multiple Initial Conditions\n# ============================================================================\ninitial_conditions = [\n    {'prey': 60, 'predator': 30},\n    {'prey': 40, 'predator': 50},\n    {'prey': 70, 'predator': 20}\n]\n\nplt.figure(figsize=(14, 6))\n\n# Time series plot\nplt.subplot(1, 2, 1)\nfor i, x0 in enumerate(initial_conditions):\n    time, traj = pfuzzy.simulate(x0=x0, n_steps=200)\n    plt.plot(time, traj[:, 0], '--', label=f'Prey IC{i+1}', alpha=0.7)\n    plt.plot(time, traj[:, 1], '-', label=f'Predator IC{i+1}', alpha=0.7)\n\nplt.xlabel('Time (steps)')\nplt.ylabel('Population')\nplt.title('Predator-Prey Dynamics')\nplt.legend()\nplt.grid(True)\n\n# Phase space plot\nplt.subplot(1, 2, 2)\nfor i, x0 in enumerate(initial_conditions):\n    time, traj = pfuzzy.simulate(x0=x0, n_steps=200)\n    plt.plot(traj[:, 0], traj[:, 1], linewidth=2, label=f'IC{i+1}')\n    plt.plot(traj[0, 0], traj[0, 1], 'go', markersize=8)  # Start\n    plt.plot(traj[-1, 0], traj[-1, 1], 'ro', markersize=8)  # End\n\nplt.xlabel('Prey Population')\nplt.ylabel('Predator Population')\nplt.title('Phase Space')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# ============================================================================\n# Step 4: Export\n# ============================================================================\npfuzzy.to_csv('predator_prey.csv')\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#10-tips-and-best-practices","title":"10. Tips and Best Practices","text":""},{"location":"quick_start/pfuzzy_discrete/#system-design","title":"System Design","text":"<ol> <li>Choose appropriate universe of discourse:</li> <li>Must contain all reachable states</li> <li> <p>Simulation stops if state exits domain</p> </li> <li> <p>Select evolution mode carefully:</p> </li> <li>Absolute: Natural for additive processes (birth/death)</li> <li> <p>Relative: Natural for multiplicative processes (growth rates)</p> </li> <li> <p>Output ranges:</p> </li> <li>Absolute mode: output = change magnitude</li> <li> <p>Relative mode: output = multiplication factor (1.0 = no change)</p> </li> <li> <p>Rule coverage:</p> </li> <li>Ensure rules cover expected state space</li> <li>Missing rules \u2192 unexpected behavior</li> </ol>"},{"location":"quick_start/pfuzzy_discrete/#performance-optimization","title":"Performance Optimization","text":"<pre><code># For long simulations, monitor memory\nimport sys\ntime, traj = pfuzzy.simulate(x0=x0, n_steps=10000)\nprint(f\"Memory: {sys.getsizeof(traj) / 1e6:.2f} MB\")\n\n# For very long simulations, consider periodic saving\nfor i in range(0, 10000, 1000):\n    t, tr = pfuzzy.simulate(x0=x0, n_steps=1000)\n    pfuzzy.to_csv(f'results_batch_{i}.csv')\n    x0 = tr[-1]  # Continue from last state\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#debugging","title":"Debugging","text":"<pre><code># Check FIS behavior at specific states\ntest_state = {'prey': 50, 'predator': 30}\noutput = fis.evaluate(test_state)\nprint(f\"State: {test_state}\")\nprint(f\"Change rates: {output}\")\n\n# Manually verify first step\nx0 = np.array([50.0, 30.0])\nx1_manual = x0 + np.array([output['prey_change'], output['predator_change']])\nx1_auto = pfuzzy.step(x0)\nprint(f\"Manual: {x1_manual}\")\nprint(f\"Auto: {x1_auto}\")\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#11-common-patterns","title":"11. Common Patterns","text":""},{"location":"quick_start/pfuzzy_discrete/#pattern-1-carrying-capacity-logistic-growth","title":"Pattern 1: Carrying Capacity (Logistic Growth)","text":"<pre><code># Rules for logistic growth\nrules = [\n    {'population': 'low', 'growth_rate': 'high_positive'},\n    {'population': 'medium', 'growth_rate': 'low_positive'},\n    {'population': 'high', 'growth_rate': 'negative'}\n]\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#pattern-2-allee-effect-minimum-viable-population","title":"Pattern 2: Allee Effect (Minimum Viable Population)","text":"<pre><code># Population declines if too small\nrules = [\n    {'population': 'very_low', 'growth_rate': 'negative'},  # Extinction\n    {'population': 'low', 'growth_rate': 'positive'},       # Recovery\n    {'population': 'high', 'growth_rate': 'negative'}       # Overpopulation\n]\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#pattern-3-oscillatory-behavior-predator-prey","title":"Pattern 3: Oscillatory Behavior (Predator-Prey)","text":"<pre><code># Creates cycles\nrules = [\n    {'prey': 'high', 'predator': 'low',\n     'prey_change': 'positive', 'predator_change': 'positive'},\n    {'prey': 'low', 'predator': 'high',\n     'prey_change': 'negative', 'predator_change': 'negative'}\n]\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#12-common-issues-and-solutions","title":"12. Common Issues and Solutions","text":"Problem Cause Solution Simulation stops early State exits domain Increase input universe range No dynamics (flat line) All rules output zero Check rule consequents Explosive growth Output ranges too large Reduce output universe Unexpected behavior Sparse rule coverage Add more rules Oscillations too large Output ranges too large Scale down outputs"},{"location":"quick_start/pfuzzy_discrete/#domain-exit-handling","title":"Domain Exit Handling","text":"<pre><code># System warns and stops when state exits domain\ntry:\n    time, traj = pfuzzy.simulate(x0={'pop': 95}, n_steps=100)\nexcept Exception as e:\n    print(f\"Simulation error: {e}\")\n\n# Check if simulation completed\nif len(time) &lt; 101:\n    print(f\"\u26a0\ufe0f Stopped at step {len(time)-1}\")\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#13-absolute-vs-relative-mode","title":"13. Absolute vs Relative Mode","text":""},{"location":"quick_start/pfuzzy_discrete/#when-to-use-absolute-mode","title":"When to Use Absolute Mode","text":"<pre><code>mode='absolute'  # x_{n+1} = x_n + f(x_n)\n</code></pre> <p>Best for: - Additive processes (birth - death) - Fixed changes (add/subtract constants) - When change doesn't depend on current value</p> <p>Example: Population with constant birth/death rates <pre><code>population_next = population_current + (births - deaths)\n</code></pre></p>"},{"location":"quick_start/pfuzzy_discrete/#when-to-use-relative-mode","title":"When to Use Relative Mode","text":"<pre><code>mode='relative'  # x_{n+1} = x_n \u00d7 f(x_n)\n</code></pre> <p>Best for: - Multiplicative processes (growth factors) - Percentage changes - When change is proportional to current state</p> <p>Example: Population with growth rate <pre><code>population_next = population_current \u00d7 (1 + growth_rate)\n</code></pre></p> <p>Important: In relative mode, outputs should be around 1.0: - Output = 1.0 \u2192 no change - Output = 1.1 \u2192 10% increase - Output = 0.9 \u2192 10% decrease</p>"},{"location":"quick_start/pfuzzy_discrete/#14-comparison-discrete-vs-continuous","title":"14. Comparison: Discrete vs Continuous","text":"Aspect Discrete Continuous Time Integer steps (n=0,1,2,...) Real time (t\u2208\u211d) Evolution x_{n+1} = F(x_n) dx/dt = f(x) Simulation Iteration Numerical integration Speed Fast Slower Best for Generations, cycles Physical processes"},{"location":"quick_start/pfuzzy_discrete/#15-advanced-multi-variable-systems","title":"15. Advanced: Multi-Variable Systems","text":"<pre><code># 3-variable system: SIR epidemic model\nfis = fs.MamdaniSystem(name=\"SIR Model\")\n\n# Inputs\nfis.add_input('susceptible', (0, 1000))\nfis.add_input('infected', (0, 1000))\nfis.add_input('recovered', (0, 1000))\n\n# Outputs (changes)\nfis.add_output('susceptible_change', (-50, 50))\nfis.add_output('infected_change', (-50, 50))\nfis.add_output('recovered_change', (-50, 50))\n\n# ... add terms and rules ...\n\n# Create p-fuzzy system\npfuzzy = PFuzzyDiscrete(\n    fis=fis,\n    mode='absolute',\n    state_vars=['susceptible', 'infected', 'recovered']\n)\n\n# Simulate\nx0 = {'susceptible': 990, 'infected': 10, 'recovered': 0}\ntime, traj = pfuzzy.simulate(x0=x0, n_steps=100)\n\n# Plot all variables\npfuzzy.plot_trajectory(title='SIR Epidemic Model')\n</code></pre>"},{"location":"quick_start/pfuzzy_discrete/#references","title":"References","text":"<ul> <li>Barros, L. C., Bassanezi, R. C., &amp; Lodwick, W. A. (2017). A First Course in Fuzzy Logic, Fuzzy Dynamical Systems, and Biomathematics. Springer.</li> <li>Bassanezi, R. C., &amp; Barros, L. C. (2015). T\u00f3picos de L\u00f3gica Fuzzy e Biomatem\u00e1tica. UNICAMP.</li> </ul>"},{"location":"quick_start/quickstart_index/","title":"pyfuzzy-toolbox Quick Start Guides","text":"<p>Complete collection of quick start guides for all modules in the pyfuzzy-toolbox library.</p>"},{"location":"quick_start/quickstart_index/#available-guides","title":"\ud83d\udcda Available Guides","text":""},{"location":"quick_start/quickstart_index/#learning-algorithms","title":"\ud83e\udde0 Learning Algorithms","text":"<p>Learn fuzzy systems from data using various learning techniques.</p>"},{"location":"quick_start/quickstart_index/#1-anfis-adaptive-neuro-fuzzy-inference-system","title":"1. ANFIS - Adaptive Neuro-Fuzzy Inference System","text":"<p>Hybrid learning combining neural networks and fuzzy logic</p> <ul> <li>\u2705 Supervised learning for regression/classification</li> <li>\u2705 Two training methods: <code>fit()</code> (gradient descent) and <code>fit_metaheuristic()</code> (PSO/DE/GA)</li> <li>\u2705 Automatic parameter optimization</li> <li>\ud83d\udcd3 Notebooks: <code>03_learning/01_anfis_regression.ipynb</code>, <code>03_learning/02_anfis_classification.ipynb</code></li> </ul> <p>Key Features: - Gaussian, Bell, and Sigmoid membership functions - Hybrid learning: LSE for consequents + gradient descent for premises - Metaheuristic optimization: PSO, DE, GA - Early stopping and adaptive learning rate</p> <p>When to use: Complex nonlinear regression/classification with automatic rule extraction.</p>"},{"location":"quick_start/quickstart_index/#2-wang-mendel-learning","title":"2. Wang-Mendel Learning","text":"<p>Single-pass fuzzy rule extraction from data</p> <ul> <li>\u2705 Fast rule generation from training data</li> <li>\u2705 Automatic task detection (regression/classification)</li> <li>\u2705 No iterative optimization needed</li> <li>\ud83d\udcd3 Notebooks: <code>03_learning/03_wang_mendel_regression.ipynb</code>, <code>03_learning/04_wang_mendel_classification.ipynb</code></li> </ul> <p>Key Features: - One-pass algorithm (very fast) - Automatic membership function generation - Rule conflict resolution - Handles multi-output systems</p> <p>When to use: Quick fuzzy model from data, interpretable rules, baseline models.</p>"},{"location":"quick_start/quickstart_index/#3-mamdani-learning","title":"3. Mamdani Learning","text":"<p>Optimize Mamdani fuzzy system consequents with metaheuristics</p> <ul> <li>\u2705 Optimize rule consequents for existing Mamdani FIS</li> <li>\u2705 Four metaheuristic algorithms: SA, GA, PSO, DE</li> <li>\u2705 Preserves linguistic interpretability</li> <li>\ud83d\udcd3 Notebooks: <code>03_learning/05_mamdani_learning_optimization.ipynb</code></li> </ul> <p>Key Features: - Simulated Annealing (SA): local search with probabilistic acceptance - Genetic Algorithm (GA): population-based with crossover/mutation - Particle Swarm Optimization (PSO): swarm intelligence - Differential Evolution (DE): mutation-based evolution</p> <p>When to use: Fine-tune existing Mamdani systems, optimize rule consequents while keeping antecedents.</p>"},{"location":"quick_start/quickstart_index/#fuzzy-inference-systems","title":"\ud83c\udf9b\ufe0f Fuzzy Inference Systems","text":"<p>Build and use fuzzy inference systems for control and decision-making.</p>"},{"location":"quick_start/quickstart_index/#4-mamdani-system","title":"4. Mamdani System","text":"<p>Linguistic fuzzy inference with fuzzy outputs</p> <ul> <li>\u2705 Manual or automatic membership function generation</li> <li>\u2705 Intuitive rule creation (dictionaries, lists, indices)</li> <li>\u2705 Multiple defuzzification methods</li> <li>\ud83d\udcd3 Notebooks: <code>02_inference/01_mamdani_tipping.ipynb</code>, <code>02_inference/02_voting_prediction.ipynb</code></li> </ul> <p>Key Features: - <code>add_auto_mfs()</code>: automatic MF generation with linguistic labels - Multiple rule formats: dict, list, tuple - Visualization: <code>plot_variables()</code>, <code>plot_output()</code>, <code>plot_rule_matrix()</code> - Save/load: <code>save()</code>, <code>load()</code>, <code>export_rules()</code>, <code>import_rules()</code></p> <p>When to use: Human-interpretable control systems, linguistic rules, fuzzy decision-making.</p>"},{"location":"quick_start/quickstart_index/#5-sugeno-system","title":"5. Sugeno System","text":"<p>Efficient fuzzy inference with mathematical consequents</p> <ul> <li>\u2705 Order 0 (constant) or Order 1 (linear) consequents</li> <li>\u2705 No defuzzification needed (weighted average)</li> <li>\u2705 Ideal for ANFIS and optimization</li> <li>\ud83d\udcd3 Notebooks: <code>02_inference/03_sugeno_zero_order.ipynb</code>, <code>02_inference/04_sugeno_first_order.ipynb</code></li> </ul> <p>Key Features: - Order 0: IF-THEN rules with constant outputs (singletons) - Order 1: IF-THEN rules with linear functions of inputs - Faster computation than Mamdani - Better for learning algorithms (ANFIS compatible)</p> <p>When to use: Optimization tasks, ANFIS learning, smooth approximations, computational efficiency.</p>"},{"location":"quick_start/quickstart_index/#dynamical-systems","title":"\ud83d\udd04 Dynamical Systems","text":"<p>Model temporal evolution with fuzzy rules.</p>"},{"location":"quick_start/quickstart_index/#6-p-fuzzy-discrete","title":"6. p-Fuzzy Discrete","text":"<p>Discrete-time fuzzy dynamical systems</p> <ul> <li>\u2705 Model discrete-time evolution: x_{n+1} = x_n + f(x_n)</li> <li>\u2705 Absolute or relative modes</li> <li>\u2705 Single-step execution for analysis</li> <li>\ud83d\udcd3 Notebooks: <code>04_dynamics/pfuzzy_discrete_predator_prey.ipynb</code>, <code>04_dynamics/pfuzzy_population.ipynb</code></li> </ul> <p>Key Features: - Absolute mode: x_{n+1} = x_n + f(x_n) (additive change) - Relative mode: x_{n+1} = x_n \u00d7 f(x_n) (multiplicative change) - <code>simulate()</code>: run n_steps iterations - <code>step()</code>: single iteration for manual control - Export: <code>to_csv()</code> with international/Brazilian formats</p> <p>When to use: Population dynamics (generations), discrete events, time-series with discrete steps.</p>"},{"location":"quick_start/quickstart_index/#7-p-fuzzy-continuous","title":"7. p-Fuzzy Continuous","text":"<p>Continuous-time fuzzy dynamical systems with ODEs</p> <ul> <li>\u2705 Model continuous evolution: dx/dt = f(x)</li> <li>\u2705 Euler or RK4 integration methods</li> <li>\u2705 Fixed or adaptive time stepping</li> <li>\ud83d\udcd3 Notebooks: <code>04_dynamics/pfuzzy_continuous_predator_prey.ipynb</code></li> </ul> <p>Key Features: - Absolute mode: dx/dt = f(x) (rate independent of state) - Relative mode: dx/dt = x\u00b7f(x) (rate proportional to state) - Integration methods: <code>'euler'</code> (fast), <code>'rk4'</code> (accurate) - Adaptive stepping: automatically adjusts dt for accuracy - Verbose mode: prints statistics (accepted/rejected steps, dt range)</p> <p>When to use: Physical processes, continuous growth, temperature/cooling systems, smooth dynamics.</p>"},{"location":"quick_start/quickstart_index/#8-fuzzy-ode-solver","title":"8. Fuzzy ODE Solver","text":"<p>Solve ODEs with fuzzy initial conditions and parameters</p> <ul> <li>\u2705 Propagate uncertainty through differential equations</li> <li>\u2705 Fuzzy numbers for initial conditions and parameters</li> <li>\u2705 Three solution methods: standard, Monte Carlo, hierarchical</li> <li>\ud83d\udcd3 Notebooks: <code>04_dynamics/fuzzy_ode_logistic.ipynb</code>, <code>04_dynamics/fuzzy_ode_holling_tanner.ipynb</code></li> </ul> <p>Key Features: - Fuzzy numbers: triangular, gaussian, trapezoidal - \u03b1-cuts: confidence levels for uncertainty quantification - Solution methods:   - <code>'standard'</code>: full grid (most accurate)   - <code>'monte_carlo'</code>: sampling (10-400x faster for high dimensions)   - <code>'hierarchical'</code>: optimization (3-5x faster) - Visualization: plot \u03b1-level envelopes - Export: <code>to_csv()</code>, <code>to_dataframe()</code></p> <p>When to use: Uncertain initial conditions, imprecise parameters, possibilistic uncertainty (vs probabilistic).</p>"},{"location":"quick_start/quickstart_index/#quick-reference-table","title":"\ud83d\uddc2\ufe0f Quick Reference Table","text":"Module Type Input Output Best For Notebooks ANFIS Learning Data (X, y) Sugeno FIS Regression, classification 01, 02 Wang-Mendel Learning Data (X, y) Mamdani FIS Fast rule extraction 03, 04 Mamdani Learning Learning FIS + Data Optimized FIS Fine-tuning consequents 05 Mamdani System Inference Variables + Rules FIS Linguistic control 01, 04 Sugeno System Inference Variables + Rules FIS Efficient inference 02, 03 p-Fuzzy Discrete Dynamics FIS + x\u2080 Trajectory Discrete-time evolution 01, 03 p-Fuzzy Continuous Dynamics FIS + x\u2080 Trajectory Continuous-time evolution 02 Fuzzy ODE Dynamics ODE + Fuzzy params Fuzzy trajectory Uncertainty propagation 04, 05"},{"location":"quick_start/quickstart_index/#notebook-organization","title":"\ud83d\udcc2 Notebook Organization","text":"<p>All notebooks are available in the <code>notebooks_colab/</code> directory:</p> <pre><code>notebooks_colab/\n\u251c\u2500\u2500 01_fundamentals/          # Fuzzy logic basics\n\u2502   \u251c\u2500\u2500 01_membership_functions.ipynb\n\u2502   \u2514\u2500\u2500 02_thermal_comfort.ipynb\n\u2502\n\u251c\u2500\u2500 02_inference/              # Inference systems\n\u2502   \u251c\u2500\u2500 01_mamdani_tipping.ipynb\n\u2502   \u251c\u2500\u2500 02_voting_prediction.ipynb\n\u2502   \u251c\u2500\u2500 03_sugeno_zero_order.ipynb\n\u2502   \u2514\u2500\u2500 04_sugeno_first_order.ipynb\n\u2502\n\u251c\u2500\u2500 03_learning/               # Learning algorithms\n\u2502   \u251c\u2500\u2500 anfis_iris.ipynb\n\u2502   \u251c\u2500\u2500 anfis_regression.ipynb\n\u2502   \u251c\u2500\u2500 rules_optimization.ipynb\n\u2502   \u251c\u2500\u2500 rules_optimization_iris.ipynb\n\u2502   \u251c\u2500\u2500 wang_mendel_iris.ipynb\n\u2502   \u251c\u2500\u2500 wang_mendel_linear.ipynb\n\u2502   \u2514\u2500\u2500 wang_mendel_nonlinear.ipynb\n\u2502\n\u2514\u2500\u2500 04_dynamics/               # Dynamical systems\n    \u251c\u2500\u2500 fuzzy_ode_holling_tanner.ipynb\n    \u251c\u2500\u2500 fuzzy_ode_logistic.ipynb\n    \u251c\u2500\u2500 pfuzzy_continuous_predator_prey.ipynb\n    \u251c\u2500\u2500 pfuzzy_discrete_predator_prey.ipynb\n    \u2514\u2500\u2500 pfuzzy_population.ipynb\n</code></pre>"},{"location":"quick_start/quickstart_index/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"quick_start/quickstart_index/#installation","title":"Installation","text":"<pre><code>pip install pyfuzzy-toolbox\n</code></pre>"},{"location":"quick_start/quickstart_index/#choose-your-path","title":"Choose Your Path","text":""},{"location":"quick_start/quickstart_index/#1-i-want-to-learn-from-data","title":"1\ufe0f\u20e3 I want to learn from data","text":"<p>\u2192 Start with Wang-Mendel for quick rules, or ANFIS for accurate models</p>"},{"location":"quick_start/quickstart_index/#2-i-want-to-build-a-control-system","title":"2\ufe0f\u20e3 I want to build a control system","text":"<p>\u2192 Start with Mamdani System for interpretability, or Sugeno System for efficiency</p>"},{"location":"quick_start/quickstart_index/#3-i-want-to-model-temporal-dynamics","title":"3\ufe0f\u20e3 I want to model temporal dynamics","text":"<p>\u2192 Start with p-Fuzzy Discrete for discrete-time, or p-Fuzzy Continuous for continuous-time</p>"},{"location":"quick_start/quickstart_index/#4-i-have-uncertain-parameters","title":"4\ufe0f\u20e3 I have uncertain parameters","text":"<p>\u2192 Start with Fuzzy ODE Solver</p>"},{"location":"quick_start/quickstart_index/#learning-path","title":"\ud83d\udcd6 Learning Path","text":""},{"location":"quick_start/quickstart_index/#beginner-path","title":"Beginner Path","text":"<ol> <li>Fundamentals \u2192 Notebooks <code>01_fundamentals/</code></li> <li>Inference \u2192 Mamdani System</li> <li>Learning \u2192 Wang-Mendel</li> </ol>"},{"location":"quick_start/quickstart_index/#intermediate-path","title":"Intermediate Path","text":"<ol> <li>Advanced Inference \u2192 Sugeno System</li> <li>Learning \u2192 ANFIS</li> <li>Dynamics \u2192 p-Fuzzy Discrete</li> </ol>"},{"location":"quick_start/quickstart_index/#advanced-path","title":"Advanced Path","text":"<ol> <li>Optimization \u2192 Mamdani Learning</li> <li>Continuous Dynamics \u2192 p-Fuzzy Continuous</li> <li>Uncertainty \u2192 Fuzzy ODE Solver</li> </ol>"},{"location":"quick_start/quickstart_index/#common-use-cases","title":"\ud83d\udca1 Common Use Cases","text":""},{"location":"quick_start/quickstart_index/#control-systems","title":"Control Systems","text":"<ul> <li>Tipping problem: Mamdani System \u2192 Notebook <code>02_inference/01_mamdani_tipping.ipynb</code></li> <li>Temperature control: Sugeno System \u2192 Notebook <code>02_inference/03_sugeno_zero_order.ipynb</code></li> </ul>"},{"location":"quick_start/quickstart_index/#machine-learning","title":"Machine Learning","text":"<ul> <li>Regression: ANFIS \u2192 Notebook <code>03_learning/anfis_regression.ipynb</code></li> <li>Classification: Wang-Mendel \u2192 Notebook <code>03_learning/wang_mendel_iris.ipynb</code></li> </ul>"},{"location":"quick_start/quickstart_index/#population-dynamics","title":"Population Dynamics","text":"<ul> <li>Predator-prey (discrete): p-Fuzzy Discrete \u2192 Notebook <code>04_dynamics/pfuzzy_discrete_predator_prey.ipynb</code></li> <li>Predator-prey (continuous): p-Fuzzy Continuous \u2192 Notebook <code>04_dynamics/pfuzzy_continuous_predator_prey.ipynb</code></li> </ul>"},{"location":"quick_start/quickstart_index/#uncertainty-modeling","title":"Uncertainty Modeling","text":"<ul> <li>Logistic growth with fuzzy parameters: Fuzzy ODE Solver \u2192 Notebook <code>04_dynamics/fuzzy_ode_logistic.ipynb</code></li> <li>Epidemic model with uncertain transmission: Fuzzy ODE Solver \u2192 Notebook <code>04_dynamics/fuzzy_ode_holling_tanner.ipynb</code></li> </ul>"},{"location":"quick_start/quickstart_index/#additional-resources","title":"\ud83d\udd17 Additional Resources","text":"<ul> <li>Main Documentation: https://1moi6.github.io/pyfuzzy-toolbox/</li> <li>GitHub Repository: https://github.com/1moi6/pyfuzzy-toolbox</li> <li>PyPI Package: https://pypi.org/project/pyfuzzy-toolbox/</li> <li>Issue Tracker: https://github.com/1moi6/pyfuzzy-toolbox/issues</li> </ul>"},{"location":"quick_start/quickstart_index/#document-structure","title":"\ud83d\udcdd Document Structure","text":"<p>Each quickstart guide follows the same structure:</p> <ol> <li>Overview - What is it and why use it</li> <li>Basic Concepts - Key ideas and terminology</li> <li>Getting Started - Minimal working example</li> <li>Parameters - Detailed parameter descriptions</li> <li>Methods - Available methods and their uses</li> <li>Visualization - How to plot results</li> <li>Export - Saving results</li> <li>Complete Examples - Real-world applications</li> <li>Tips &amp; Best Practices - Expert recommendations</li> <li>Common Issues - Troubleshooting guide</li> <li>Advanced Features - Power-user techniques</li> <li>References - Academic citations</li> </ol>"},{"location":"quick_start/quickstart_index/#quick-navigation","title":"\ud83c\udfaf Quick Navigation","text":"<ul> <li>ANFIS | Wang-Mendel | Mamdani Learning</li> <li>Mamdani System | Sugeno System</li> <li>p-Fuzzy Discrete | p-Fuzzy Continuous | Fuzzy ODE</li> </ul> <p>Generated with pyfuzzy-toolbox documentation system</p>"},{"location":"quick_start/sugeno_system/","title":"Sugeno FIS Quick Start Guide","text":""},{"location":"quick_start/sugeno_system/#overview","title":"Overview","text":"<p>SugenoSystem (Takagi-Sugeno-Kang) is a fuzzy inference system that uses fuzzy antecedents with mathematical consequents (constants or linear functions) for efficient modeling and control.</p> <p>Key Features: - Fuzzy inputs with crisp mathematical outputs - Two orders: 0 (constant) and 1 (linear functions) - No defuzzification needed (weighted average) - Computationally efficient - Ideal for optimization and learning - Rule export/import and system persistence</p> <p>Advantages over Mamdani: - Faster computation (no defuzzification) - Easier to optimize (linear consequents) - Better for ANFIS and learning algorithms - More compact representation</p>"},{"location":"quick_start/sugeno_system/#1-creating-a-sugeno-fis","title":"1. Creating a Sugeno FIS","text":""},{"location":"quick_start/sugeno_system/#basic-instantiation","title":"Basic Instantiation","text":"<pre><code>from fuzzy_systems import SugenoSystem\nfrom fuzzy_systems.core.membership_functions import TNorm, SNorm\n\n# Create Sugeno system\nfis = SugenoSystem(\n    name=\"My Sugeno FIS\",\n    and_method=TNorm.MIN,      # T-norm for AND operator\n    or_method=SNorm.MAX,       # S-norm for OR operator\n    order=0                    # 0=constant, 1=linear\n)\n</code></pre>"},{"location":"quick_start/sugeno_system/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>name</code>: System identifier</li> <li><code>and_method</code>: T-norm for AND operations</li> <li><code>TNorm.MIN</code>: Minimum (default, most common)</li> <li><code>TNorm.PRODUCT</code>: Product</li> <li><code>TNorm.LUKASIEWICZ</code>: Lukasiewicz</li> <li><code>or_method</code>: S-norm for OR operations</li> <li><code>SNorm.MAX</code>: Maximum (default)</li> <li><code>SNorm.PROBOR</code>: Probabilistic OR</li> <li><code>SNorm.LUKASIEWICZ</code>: Lukasiewicz</li> <li><code>order</code>: System order (determines output type)</li> <li><code>0</code>: Zero-order (singleton/constant outputs)</li> <li><code>1</code>: First-order (linear function outputs)</li> </ul>"},{"location":"quick_start/sugeno_system/#2-system-orders-explained","title":"2. System Orders Explained","text":""},{"location":"quick_start/sugeno_system/#order-0-zero-order-sugeno-singletons","title":"Order 0: Zero-Order Sugeno (Singletons)","text":"<p>Consequents are constants:</p> <pre><code>IF temperature is cold THEN output = 2.5\nIF temperature is hot THEN output = 8.0\n</code></pre> <p>Output calculation: <pre><code>y = (w1 \u00d7 c1 + w2 \u00d7 c2 + ...) / (w1 + w2 + ...)\n</code></pre></p> <p>Where: - <code>wi</code> = firing strength of rule i - <code>ci</code> = constant output of rule i</p> <p>Best for: - Classification tasks - Simple control systems - Fast computation needs</p>"},{"location":"quick_start/sugeno_system/#order-1-first-order-sugeno-linear-functions","title":"Order 1: First-Order Sugeno (Linear Functions)","text":"<p>Consequents are linear equations:</p> <pre><code>IF temperature is cold THEN output = 0.5\u00d7temp + 1.0\nIF temperature is hot THEN output = 0.8\u00d7temp + 2.0\n</code></pre> <p>Output calculation: <pre><code>y = (w1 \u00d7 f1(x) + w2 \u00d7 f2(x) + ...) / (w1 + w2 + ...)\n</code></pre></p> <p>Where: - <code>wi</code> = firing strength of rule i - <code>fi(x)</code> = linear function of inputs for rule i - For 2 inputs: <code>f(x1, x2) = p1\u00d7x1 + p2\u00d7x2 + p0</code></p> <p>Best for: - Regression and approximation - ANFIS learning - Complex nonlinear systems - Smooth control surfaces</p>"},{"location":"quick_start/sugeno_system/#3-adding-variables","title":"3. Adding Variables","text":""},{"location":"quick_start/sugeno_system/#input-variables","title":"Input Variables","text":"<pre><code># Add input variables with universe of discourse\nfis.add_input('temperature', (0, 100))\nfis.add_input('humidity', (0, 100))\n</code></pre>"},{"location":"quick_start/sugeno_system/#output-variables","title":"Output Variables","text":"<pre><code># Add output variable (no terms needed for Sugeno)\nfis.add_output('fan_speed')\n\n# Can optionally specify range for visualization\nfis.add_output('fan_speed', (0, 100))\n</code></pre> <p>Note: Unlike Mamdani, Sugeno outputs don't need membership functions since outputs are computed mathematically.</p>"},{"location":"quick_start/sugeno_system/#4-adding-membership-functions-inputs-only","title":"4. Adding Membership Functions (Inputs Only)","text":""},{"location":"quick_start/sugeno_system/#manual-mf-definition","title":"Manual MF Definition","text":"<pre><code># Temperature MFs\nfis.add_term('temperature', 'cold', 'trapezoidal', (0, 0, 20, 40))\nfis.add_term('temperature', 'warm', 'triangular', (20, 50, 80))\nfis.add_term('temperature', 'hot', 'trapezoidal', (60, 80, 100, 100))\n\n# Humidity MFs\nfis.add_term('humidity', 'dry', 'triangular', (0, 0, 50))\nfis.add_term('humidity', 'humid', 'triangular', (0, 50, 100))\nfis.add_term('humidity', 'wet', 'triangular', (50, 100, 100))\n</code></pre>"},{"location":"quick_start/sugeno_system/#automatic-mf-generation","title":"Automatic MF Generation","text":"<pre><code># Generate evenly spaced MFs automatically\nfis.add_auto_mfs('temperature', n_mfs=3, mf_type='triangular')\nfis.add_auto_mfs('humidity', n_mfs=3, mf_type='gaussian')\n\n# This creates:\n# temperature: very low, medium, very high\n# humidity: very low, medium, very high\n</code></pre>"},{"location":"quick_start/sugeno_system/#available-mf-types","title":"Available MF Types","text":"Type Parameters Example <code>'triangular'</code> (a, b, c) <code>(0, 50, 100)</code> <code>'trapezoidal'</code> (a, b, c, d) <code>(0, 20, 80, 100)</code> <code>'gaussian'</code> (center, sigma) <code>(50, 15)</code> <code>'bell'</code> (center, width, slope) <code>(50, 20, 2)</code>"},{"location":"quick_start/sugeno_system/#5-adding-rules","title":"5. Adding Rules","text":""},{"location":"quick_start/sugeno_system/#order-0-rules-with-constants","title":"Order 0: Rules with Constants","text":"<pre><code># Method 1: Tuples (term_name, constant_value)\nfis.add_rules([\n    ('cold', 20.0),      # IF temp is cold THEN fan = 20\n    ('warm', 50.0),      # IF temp is warm THEN fan = 50\n    ('hot', 80.0)        # IF temp is hot THEN fan = 80\n])\n\n# Method 2: Dictionary format\nfis.add_rule({\n    'temperature': 'cold',\n    'humidity': 'dry',\n    'fan_speed': 25.0,\n    'operator': 'AND'\n})\n\n# Method 3: List format (by variable order)\nfis.add_rule(['cold', 'dry', 25.0])\n</code></pre>"},{"location":"quick_start/sugeno_system/#order-1-rules-with-linear-functions","title":"Order 1: Rules with Linear Functions","text":"<p>For order 1, consequent is a list of coefficients: <code>[p1, p2, ..., pn, p0]</code></p> <p>Output function: <code>y = p1\u00d7x1 + p2\u00d7x2 + ... + pn\u00d7xn + p0</code></p> <pre><code># Single input example\n# y = p1\u00d7x + p0\nfis.add_rules([\n    ('cold', [0.2, 10.0]),    # y = 0.2\u00d7temp + 10.0\n    ('warm', [0.5, 20.0]),    # y = 0.5\u00d7temp + 20.0\n    ('hot', [0.8, 30.0])      # y = 0.8\u00d7temp + 30.0\n])\n\n# Two inputs example\n# y = p1\u00d7x1 + p2\u00d7x2 + p0\nfis.add_rules([\n    ['cold', 'dry', [0.2, 0.1, 10.0]],      # y = 0.2\u00d7temp + 0.1\u00d7hum + 10\n    ['warm', 'humid', [0.5, 0.3, 30.0]],    # y = 0.5\u00d7temp + 0.3\u00d7hum + 30\n    ['hot', 'wet', [0.8, 0.5, 50.0]]        # y = 0.8\u00d7temp + 0.5\u00d7hum + 50\n])\n\n# Dictionary format (order 1)\nfis.add_rule({\n    'temperature': 'cold',\n    'humidity': 'dry',\n    'fan_speed': [0.2, 0.1, 10.0],  # Linear function\n    'operator': 'AND'\n})\n</code></pre>"},{"location":"quick_start/sugeno_system/#rule-parameters","title":"Rule Parameters","text":"<ul> <li><code>operator</code>: Rule connector</li> <li><code>'AND'</code>: All antecedents must be true (default)</li> <li><code>'OR'</code>: At least one antecedent must be true</li> <li><code>weight</code>: Rule importance (0.0 to 1.0, default: 1.0)</li> </ul>"},{"location":"quick_start/sugeno_system/#6-evaluating-the-system","title":"6. Evaluating the System","text":""},{"location":"quick_start/sugeno_system/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code># Dictionary input\noutput = fis.evaluate({'temperature': 75, 'humidity': 60})\nprint(f\"Fan speed: {output['fan_speed']:.2f}\")\n\n# Keyword arguments\noutput = fis.evaluate(temperature=75, humidity=60)\n\n# Positional arguments (follows variable order)\noutput = fis.evaluate(75, 60)\n</code></pre>"},{"location":"quick_start/sugeno_system/#detailed-evaluation","title":"Detailed Evaluation","text":"<pre><code># Get detailed inference information\nresult = fis.evaluate_detailed(temperature=75, humidity=60)\n\nprint(f\"Inputs: {result['inputs']}\")\nprint(f\"Fuzzified: {result['fuzzified']}\")\nprint(f\"Outputs: {result['outputs']}\")\nprint(f\"Rule weights: {result['rule_weights']}\")\nprint(f\"Rule outputs: {result['rule_outputs']}\")\n</code></pre>"},{"location":"quick_start/sugeno_system/#7-visualization","title":"7. Visualization","text":""},{"location":"quick_start/sugeno_system/#plot-input-variables","title":"Plot Input Variables","text":"<pre><code># Plot all input membership functions\nfis.plot_variables()\n\n# Plot specific variables\nfis.plot_variables(variables=['temperature', 'humidity'])\n</code></pre>"},{"location":"quick_start/sugeno_system/#plot-output-surface-2d-input-systems","title":"Plot Output Surface (2D Input Systems)","text":"<pre><code># 3D surface plot (requires 2 inputs, 1 output)\nfis.plot_output(\n    output_var='fan_speed',\n    resolution=50,              # Grid resolution\n    figsize=(10, 8),\n    colormap='viridis'\n)\n</code></pre>"},{"location":"quick_start/sugeno_system/#plot-system-response-1d-input","title":"Plot System Response (1D Input)","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate response curve\nx_vals = np.linspace(0, 100, 100)\ny_vals = [fis.evaluate({'temperature': x})['fan_speed'] for x in x_vals]\n\nplt.plot(x_vals, y_vals, linewidth=2)\nplt.xlabel('Temperature')\nplt.ylabel('Fan Speed')\nplt.title('System Response')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"quick_start/sugeno_system/#8-rule-management","title":"8. Rule Management","text":""},{"location":"quick_start/sugeno_system/#export-rules","title":"Export Rules","text":"<pre><code># Export rules to JSON\nrules_json = fis.export_rules()\n\n# Save to file\nimport json\nwith open('sugeno_rules.json', 'w') as f:\n    json.dump(rules_json, f, indent=2)\n</code></pre>"},{"location":"quick_start/sugeno_system/#import-rules","title":"Import Rules","text":"<pre><code># Order 0 rules\nrules_order0 = [\n    {\n        \"antecedents\": {\"temperature\": \"cold\"},\n        \"consequents\": {\"fan_speed\": 20.0},\n        \"operator\": \"AND\",\n        \"weight\": 1.0\n    }\n]\n\n# Order 1 rules\nrules_order1 = [\n    {\n        \"antecedents\": {\"temperature\": \"cold\", \"humidity\": \"dry\"},\n        \"consequents\": {\"fan_speed\": [0.2, 0.1, 10.0]},\n        \"operator\": \"AND\",\n        \"weight\": 1.0\n    }\n]\n\n# Import rules\nfis.import_rules(rules_order0)  # or rules_order1\n</code></pre>"},{"location":"quick_start/sugeno_system/#clear-rules","title":"Clear Rules","text":"<pre><code># Remove all rules\nfis.rule_base.rules.clear()\n</code></pre>"},{"location":"quick_start/sugeno_system/#9-system-persistence","title":"9. System Persistence","text":""},{"location":"quick_start/sugeno_system/#save-system","title":"Save System","text":"<pre><code># Save complete system (variables, MFs, rules, order)\nfis.save('sugeno_controller.fis')\n</code></pre>"},{"location":"quick_start/sugeno_system/#load-system","title":"Load System","text":"<pre><code>from fuzzy_systems import SugenoSystem\n\n# Load saved system\nfis = SugenoSystem.load('sugeno_controller.fis')\n\n# Use immediately\noutput = fis.evaluate(temperature=75, humidity=60)\n</code></pre>"},{"location":"quick_start/sugeno_system/#export-to-json","title":"Export to JSON","text":"<pre><code># Export to JSON format\nfis_json = fis.to_json()\n\nwith open('sugeno_fis.json', 'w') as f:\n    json.dump(fis_json, f, indent=2)\n</code></pre>"},{"location":"quick_start/sugeno_system/#import-from-json","title":"Import from JSON","text":"<pre><code># Load from JSON\nwith open('sugeno_fis.json', 'r') as f:\n    fis_json = json.load(f)\n\nfis = SugenoSystem.from_json(fis_json)\n</code></pre>"},{"location":"quick_start/sugeno_system/#10-complete-examples","title":"10. Complete Examples","text":""},{"location":"quick_start/sugeno_system/#example-1-order-0-system-student-grading","title":"Example 1: Order 0 System (Student Grading)","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems import SugenoSystem\n\n# ============================================================================\n# Create Order 0 Sugeno System\n# ============================================================================\nfis = SugenoSystem(name=\"Student Grading\", order=0)\n\n# Add input\nfis.add_input('grade', (0, 10))\nfis.add_term('grade', 'low', 'triangular', (0, 0, 5))\nfis.add_term('grade', 'medium', 'triangular', (0, 5, 10))\nfis.add_term('grade', 'high', 'triangular', (5, 10, 10))\n\n# Add output\nfis.add_output('performance', (0, 10))\n\n# Add rules with constant outputs\nfis.add_rules([\n    ('low', 2.0),      # IF grade is low THEN performance = 2.0\n    ('medium', 6.0),   # IF grade is medium THEN performance = 6.0\n    ('high', 9.0)      # IF grade is high THEN performance = 9.0\n])\n\n# Evaluate\nresult = fis.evaluate({'grade': 6.5})\nprint(f\"Grade: 6.5 \u2192 Performance: {result['performance']:.2f}\")\n\n# Plot response curve\ngrades = np.linspace(0, 10, 100)\nperformances = [fis.evaluate({'grade': g})['performance'] for g in grades]\n\nplt.figure(figsize=(10, 6))\nplt.plot(grades, performances, 'b-', linewidth=3)\nplt.xlabel('Grade')\nplt.ylabel('Performance')\nplt.title('Order 0 Sugeno: Student Grading')\nplt.grid(True)\nplt.show()\n\n# Save system\nfis.save('grading_system.fis')\n</code></pre>"},{"location":"quick_start/sugeno_system/#example-2-order-1-system-temperature-control","title":"Example 2: Order 1 System (Temperature Control)","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom fuzzy_systems import SugenoSystem\n\n# ============================================================================\n# Create Order 1 Sugeno System\n# ============================================================================\nfis = SugenoSystem(name=\"Temperature Controller\", order=1)\n\n# Add inputs\nfis.add_input('temperature', (0, 100))\nfis.add_input('humidity', (0, 100))\n\n# Generate MFs automatically\nfis.add_auto_mfs('temperature', n_mfs=3, mf_type='triangular')\nfis.add_auto_mfs('humidity', n_mfs=3, mf_type='triangular')\n\n# Add output\nfis.add_output('fan_speed', (0, 100))\n\n# Add rules with linear functions\n# Format: [coef_temp, coef_humidity, constant]\nfis.add_rules([\n    ['very low', 'very low', [0.1, 0.05, 10.0]],    # y = 0.1\u00d7T + 0.05\u00d7H + 10\n    ['very low', 'medium', [0.2, 0.1, 15.0]],\n    ['very low', 'very high', [0.3, 0.15, 20.0]],\n    ['medium', 'very low', [0.3, 0.1, 25.0]],\n    ['medium', 'medium', [0.4, 0.2, 35.0]],\n    ['medium', 'very high', [0.5, 0.3, 45.0]],\n    ['very high', 'very low', [0.5, 0.2, 40.0]],\n    ['very high', 'medium', [0.6, 0.3, 55.0]],\n    ['very high', 'very high', [0.7, 0.4, 65.0]]     # y = 0.7\u00d7T + 0.4\u00d7H + 65\n])\n\n# Evaluate single point\noutput = fis.evaluate(temperature=75, humidity=60)\nprint(f\"Temperature: 75, Humidity: 60 \u2192 Fan Speed: {output['fan_speed']:.2f}%\")\n\n# Create control surface\ntemp_range = np.linspace(0, 100, 40)\nhum_range = np.linspace(0, 100, 40)\nT, H = np.meshgrid(temp_range, hum_range)\n\nSPEED = np.zeros_like(T)\nfor i in range(T.shape[0]):\n    for j in range(T.shape[1]):\n        result = fis.evaluate({'temperature': T[i, j], 'humidity': H[i, j]})\n        SPEED[i, j] = result['fan_speed']\n\n# Plot 3D surface\nfig = plt.figure(figsize=(14, 6))\n\nax1 = fig.add_subplot(121, projection='3d')\nsurf = ax1.plot_surface(T, H, SPEED, cmap='viridis', alpha=0.9)\nax1.set_xlabel('Temperature (\u00b0C)')\nax1.set_ylabel('Humidity (%)')\nax1.set_zlabel('Fan Speed (%)')\nax1.set_title('Order 1 Sugeno Control Surface')\nax1.view_init(elev=25, azim=135)\nfig.colorbar(surf, ax=ax1, shrink=0.5)\n\n# Plot contour\nax2 = fig.add_subplot(122)\ncontour = ax2.contourf(T, H, SPEED, levels=15, cmap='viridis')\nax2.set_xlabel('Temperature (\u00b0C)')\nax2.set_ylabel('Humidity (%)')\nax2.set_title('Control Surface (Contour)')\nfig.colorbar(contour, ax=ax2)\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n# Save system\nfis.save('temperature_controller.fis')\n\n# Export rules\nrules = fis.export_rules()\nwith open('temp_rules.json', 'w') as f:\n    json.dump(rules, f, indent=2)\n</code></pre>"},{"location":"quick_start/sugeno_system/#11-order-0-vs-order-1-comparison","title":"11. Order 0 vs Order 1 Comparison","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems import SugenoSystem\n\n# ============================================================================\n# Order 0 System\n# ============================================================================\nfis_o0 = SugenoSystem(order=0)\nfis_o0.add_input('x', (0, 10))\nfis_o0.add_term('x', 'low', 'trapezoidal', (0, 0, 3, 5))\nfis_o0.add_term('x', 'medium', 'triangular', (3, 5, 7))\nfis_o0.add_term('x', 'high', 'trapezoidal', (5, 7, 10, 10))\nfis_o0.add_output('y')\nfis_o0.add_rules([\n    ('low', 2.0),\n    ('medium', 5.0),\n    ('high', 8.0)\n])\n\n# ============================================================================\n# Order 1 System\n# ============================================================================\nfis_o1 = SugenoSystem(order=1)\nfis_o1.add_input('x', (0, 10))\nfis_o1.add_term('x', 'low', 'trapezoidal', (0, 0, 3, 5))\nfis_o1.add_term('x', 'medium', 'triangular', (3, 5, 7))\nfis_o1.add_term('x', 'high', 'trapezoidal', (5, 7, 10, 10))\nfis_o1.add_output('y')\nfis_o1.add_rules([\n    ('low', [0.3, 1.0]),      # y = 0.3x + 1.0\n    ('medium', [0.5, 2.5]),   # y = 0.5x + 2.5\n    ('high', [0.7, 4.0])      # y = 0.7x + 4.0\n])\n\n# Compare outputs\nx_vals = np.linspace(0, 10, 100)\ny_o0 = [fis_o0.evaluate({'x': x})['y'] for x in x_vals]\ny_o1 = [fis_o1.evaluate({'x': x})['y'] for x in x_vals]\n\nplt.figure(figsize=(12, 6))\nplt.plot(x_vals, y_o0, 'b-', linewidth=3, label='Order 0 (Constant)')\nplt.plot(x_vals, y_o1, 'r-', linewidth=3, label='Order 1 (Linear)')\nplt.xlabel('Input (x)', fontsize=12)\nplt.ylabel('Output (y)', fontsize=12)\nplt.title('Sugeno Order 0 vs Order 1', fontsize=14, fontweight='bold')\nplt.legend(fontsize=11)\nplt.grid(True, alpha=0.3)\nplt.show()\n\nprint(\"Order 0: Piecewise constant (step-like)\")\nprint(\"Order 1: Smooth, continuous (linear transitions)\")\n</code></pre>"},{"location":"quick_start/sugeno_system/#12-tips-and-best-practices","title":"12. Tips and Best Practices","text":""},{"location":"quick_start/sugeno_system/#choosing-system-order","title":"Choosing System Order","text":"Aspect Order 0 Order 1 Output Type Constants Linear functions Smoothness Step-like Continuous Complexity Simple Moderate Parameters Few (n_rules) Many (n_rules \u00d7 n_inputs) Learning Easier More powerful Best for Classification Regression, ANFIS"},{"location":"quick_start/sugeno_system/#design-guidelines","title":"Design Guidelines","text":"<ol> <li>Start with Order 0:</li> <li>Faster to design and test</li> <li>Fewer parameters to tune</li> <li> <p>Easier to interpret</p> </li> <li> <p>Use Order 1 when:</p> </li> <li>Need smooth outputs</li> <li>Using ANFIS or learning algorithms</li> <li>Modeling complex nonlinear systems</li> <li> <p>Need better approximation accuracy</p> </li> <li> <p>Input MFs:</p> </li> <li>Use 2-5 MFs per input</li> <li>Triangular or Gaussian are most common</li> <li> <p>Ensure adequate overlap between MFs</p> </li> <li> <p>Rule Design:</p> </li> <li>Cover all important input regions</li> <li>For Order 1, start with simple coefficients (0.1, 0.5, 1.0)</li> <li>Validate with test data</li> </ol>"},{"location":"quick_start/sugeno_system/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Reduce evaluation points: Not applicable (no defuzzification)</li> <li>Minimize rules: Use only necessary rules</li> <li>Use triangular MFs: Fastest computation</li> <li>Order 0 vs 1: Order 0 is ~20% faster</li> </ul>"},{"location":"quick_start/sugeno_system/#common-patterns","title":"Common Patterns","text":"<p>Order 0 - Linear approximation: <pre><code># Approximate y = 2x with 3 rules\nfis.add_rules([\n    ('low', 2.0),      # x \u2248 1 \u2192 y \u2248 2\n    ('medium', 10.0),  # x \u2248 5 \u2192 y \u2248 10\n    ('high', 18.0)     # x \u2248 9 \u2192 y \u2248 18\n])\n</code></pre></p> <p>Order 1 - Exact linear function: <pre><code># Exact y = 2x\nfis.add_rules([\n    ('low', [2.0, 0.0]),\n    ('medium', [2.0, 0.0]),\n    ('high', [2.0, 0.0])\n])\n</code></pre></p>"},{"location":"quick_start/sugeno_system/#13-common-issues-and-solutions","title":"13. Common Issues and Solutions","text":"Problem Cause Solution Output always constant Single rule firing Add more rules, check MF overlap Unexpected output values Wrong consequent format Check order 0 vs 1 format Output out of expected range Consequent values too large Adjust constants/coefficients Non-smooth output Too few rules Add more rules or use Order 1 System too complex Too many parameters Use Order 0 or reduce n_rules"},{"location":"quick_start/sugeno_system/#14-mamdani-vs-sugeno","title":"14. Mamdani vs Sugeno","text":"Aspect Mamdani Sugeno Output Fuzzy sets Constants/functions Defuzzification Required Not needed Computation Slower Faster Interpretability High (linguistic) Medium (numeric) Learning Harder Easier (especially Order 1) ANFIS Compatible No Yes Smoothness Depends on MFs Order 0: step-like, Order 1: smooth Best for Control, interpretation Optimization, learning"},{"location":"quick_start/sugeno_system/#15-advanced-features","title":"15. Advanced Features","text":""},{"location":"quick_start/sugeno_system/#custom-t-norms-and-s-norms","title":"Custom T-norms and S-norms","text":"<pre><code>from fuzzy_systems.core.membership_functions import TNorm, SNorm\n\nfis = SugenoSystem(\n    and_method=TNorm.PRODUCT,\n    or_method=SNorm.PROBOR,\n    order=1\n)\n</code></pre>"},{"location":"quick_start/sugeno_system/#weighted-rules","title":"Weighted Rules","text":"<pre><code># Add rule with reduced importance\nfis.add_rule({\n    'temperature': 'medium',\n    'humidity': 'medium',\n    'fan_speed': [0.4, 0.2, 30.0],\n    'weight': 0.5  # Half importance\n})\n</code></pre>"},{"location":"quick_start/sugeno_system/#hybrid-rules-mixed-operators","title":"Hybrid Rules (Mixed Operators)","text":"<pre><code># Some rules with AND, others with OR\nfis.add_rule({'temperature': 'cold', 'humidity': 'dry', 'fan_speed': 20.0, 'operator': 'AND'})\nfis.add_rule({'temperature': 'hot', 'humidity': 'wet', 'fan_speed': 80.0, 'operator': 'OR'})\n</code></pre>"},{"location":"quick_start/sugeno_system/#16-integration-with-anfis","title":"16. Integration with ANFIS","text":"<p>Sugeno Order 1 systems are ideal for ANFIS learning:</p> <pre><code>from fuzzy_systems.learning import ANFIS\n\n# Create ANFIS with Sugeno structure\nanfis = ANFIS(\n    n_inputs=2,\n    n_mfs=[3, 3],\n    mf_type='gaussian',\n    learning_rate=0.01\n)\n\n# Train on data (automatically uses Sugeno Order 1)\nanfis.fit(X_train, y_train, epochs=100)\n\n# Convert to SugenoSystem for inference\n# (ANFIS internally uses Sugeno Order 1 structure)\n</code></pre>"},{"location":"quick_start/sugeno_system/#references","title":"References","text":"<ul> <li>Takagi, T., &amp; Sugeno, M. (1985). \"Fuzzy identification of systems and its applications to modeling and control.\" IEEE Transactions on Systems, Man, and Cybernetics, (1), 116-132.</li> <li>Sugeno, M., &amp; Kang, G. T. (1988). \"Structure identification of fuzzy model.\" Fuzzy Sets and Systems, 28(1), 15-33.</li> <li>Jang, J. S. (1993). \"ANFIS: adaptive-network-based fuzzy inference system.\" IEEE Transactions on Systems, Man, and Cybernetics, 23(3), 665-685.</li> </ul>"},{"location":"quick_start/wang_mendel/","title":"Wang-Mendel Learning Quick Start Guide","text":""},{"location":"quick_start/wang_mendel/#overview","title":"Overview","text":"<p>The Wang-Mendel algorithm (1992) is a method for automatically generating fuzzy rules from data. It extracts fuzzy IF-THEN rules directly from input-output pairs without requiring domain expert knowledge.</p> <p>Key Features: - Automatic rule extraction from data - Conflict resolution mechanism - Supports both regression and classification - Fast and interpretable - No gradient descent or iterative optimization</p>"},{"location":"quick_start/wang_mendel/#algorithm-steps-background","title":"Algorithm Steps (Background)","text":"<p>The Wang-Mendel method consists of 5 steps:</p> <ol> <li>Partition variable domains - Define membership functions for each variable</li> <li>Generate candidate rules - Create rules from each data sample</li> <li>Assign degree to each rule - Calculate rule strength based on membership degrees</li> <li>Resolve conflicts - Keep only the rule with highest degree when antecedents match</li> <li>Create final fuzzy system - Build the rule base with conflict-free rules</li> </ol>"},{"location":"quick_start/wang_mendel/#1-setup-create-and-configure-mamdani-system","title":"1. Setup: Create and Configure Mamdani System","text":"<p>Important: Before using Wang-Mendel, you must first create a Mamdani system with all variables and membership functions defined.</p> <pre><code>from fuzzy_systems.inference import MamdaniSystem\nfrom fuzzy_systems.learning import WangMendelLearning\nimport numpy as np\n\n# Step 1: Create Mamdani system\nsystem = MamdaniSystem()\n\n# Step 2: Add input variables with their ranges\nsystem.add_input('temperature', (0, 40))\nsystem.add_input('humidity', (0, 100))\n\n# Step 3: Add output variable(s)\nsystem.add_output('comfort', (0, 10))\n\n# Step 4: Define membership functions for INPUTS\n# Temperature\nsystem.add_term('temperature', 'cold', 'trapezoidal', (0, 0, 10, 20))\nsystem.add_term('temperature', 'warm', 'triangular', (15, 25, 35))\nsystem.add_term('temperature', 'hot', 'trapezoidal', (30, 35, 40, 40))\n\n# Humidity\nsystem.add_term('humidity', 'dry', 'trapezoidal', (0, 0, 20, 40))\nsystem.add_term('humidity', 'normal', 'triangular', (30, 50, 70))\nsystem.add_term('humidity', 'wet', 'trapezoidal', (60, 80, 100, 100))\n\n# Step 5: Define membership functions for OUTPUT\nsystem.add_term('comfort', 'low', 'triangular', (0, 0, 5))\nsystem.add_term('comfort', 'medium', 'triangular', (2, 5, 8))\nsystem.add_term('comfort', 'high', 'triangular', (5, 10, 10))\n</code></pre>"},{"location":"quick_start/wang_mendel/#key-points","title":"Key Points","text":"<ul> <li>All variables must be configured before Wang-Mendel</li> <li>Membership functions define the linguistic terms used in rules</li> <li>The algorithm will automatically select which terms to use in rules</li> <li>Number of MFs per variable determines rule space size</li> </ul>"},{"location":"quick_start/wang_mendel/#2-instantiate-wangmendellearning-class","title":"2. Instantiate WangMendelLearning Class","text":"<pre><code># Prepare data\nX_train = ...  # shape: (n_samples, n_inputs)\ny_train = ...  # shape: (n_samples, n_outputs) or (n_samples,)\n\n# Create Wang-Mendel learner\nwm = WangMendelLearning(\n    system=system,              # Pre-configured Mamdani system\n    X=X_train,                  # Training input data\n    y=y_train,                  # Training output data\n    task='auto',                # Task type: 'auto', 'regression', or 'classification'\n    scale_classification=True,  # Scale classification outputs to [0,1] (structure-based)\n    verbose_init=False          # Print output range info during initialization\n)\n</code></pre>"},{"location":"quick_start/wang_mendel/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>system</code>: Pre-configured MamdaniSystem with all variables and terms defined</li> <li><code>X</code>: Training input data (n_samples, n_features)</li> <li>Must match number of input variables in system</li> <li><code>y</code>: Training output data</li> <li>Regression: (n_samples, n_outputs) or (n_samples,)</li> <li>Classification: (n_samples, n_classes) one-hot encoded</li> <li><code>task</code>: Task type detection</li> <li><code>'auto'</code>: Automatically detect (one-hot \u2192 classification, else \u2192 regression)</li> <li><code>'regression'</code>: Force regression mode</li> <li><code>'classification'</code>: Force classification mode</li> <li><code>scale_classification</code>: If True, scales classification outputs based on MF structure (not data-dependent)</li> <li><code>verbose_init</code>: Print achievable output ranges during initialization</li> </ul>"},{"location":"quick_start/wang_mendel/#task-detection","title":"Task Detection","text":"<p>The algorithm automatically detects the task type when <code>task='auto'</code>:</p> <pre><code># Regression (single output or multi-output continuous)\ny_regression = np.random.randn(100, 1)\nwm_reg = WangMendelLearning(system, X, y_regression, task='auto')\n# \u2192 Detected: regression\n\n# Classification (one-hot encoded)\nfrom sklearn.preprocessing import OneHotEncoder\ny_classes = np.random.randint(0, 3, 100)\ny_onehot = OneHotEncoder().fit_transform(y_classes.reshape(-1, 1)).toarray()\nwm_clf = WangMendelLearning(system, X, y_onehot, task='auto')\n# \u2192 Detected: classification\n</code></pre>"},{"location":"quick_start/wang_mendel/#3-training-with-fit","title":"3. Training with <code>fit()</code>","text":"<p>The <code>fit()</code> method executes the complete Wang-Mendel algorithm:</p> <pre><code># Train the system\nwm.fit(verbose=True)\n\n# The trained system is now ready\ntrained_system = wm.system\n</code></pre>"},{"location":"quick_start/wang_mendel/#parameters","title":"Parameters","text":"<ul> <li><code>verbose</code>: If True, prints progress information</li> <li>Task type</li> <li>Data dimensions</li> <li>Number of candidate rules generated</li> <li>Number of conflicts resolved</li> <li>Final rule count</li> </ul>"},{"location":"quick_start/wang_mendel/#what-happens-during-fit","title":"What Happens During <code>fit()</code>","text":"<ol> <li>Generate candidate rules from each training sample</li> <li>For each sample, find the most activated fuzzy term for each variable</li> <li>Create IF-THEN rule using these terms</li> <li> <p>Calculate rule degree (product of all membership degrees)</p> </li> <li> <p>Resolve conflicts</p> </li> <li>Group rules with same antecedents</li> <li>Keep only the rule with highest degree</li> <li> <p>Discard conflicting rules</p> </li> <li> <p>Create final system</p> </li> <li>Add conflict-free rules to the Mamdani system</li> <li>System is now ready for prediction</li> </ol>"},{"location":"quick_start/wang_mendel/#training-output-example","title":"Training Output Example","text":"<pre><code>\ud83d\udd04 Starting Wang-Mendel Algorithm...\n   Task: REGRESSION\n   Data: 500 samples, 2 inputs, 1 outputs\n\n\ud83d\udcca Step 2: Generating candidate rules...\n   Candidate rules: 127\n\n\ud83d\udd0d Step 4: Resolving conflicts...\n   Conflicts: 32\n\n\u2705 Training completed!\n   Rules generated: 95\n   Conflicts resolved: 32\n</code></pre>"},{"location":"quick_start/wang_mendel/#4-making-predictions","title":"4. Making Predictions","text":""},{"location":"quick_start/wang_mendel/#41-basic-prediction-predict","title":"4.1 Basic Prediction: <code>predict()</code>","text":"<pre><code># Make predictions\nX_test = ...  # shape: (n_samples, n_features)\npredictions = wm.predict(X_test)\n</code></pre> <p>Returns: - Regression: Array of continuous values (n_samples, n_outputs) - Classification: Array of predicted class indices (n_samples,)</p>"},{"location":"quick_start/wang_mendel/#42-classification-probabilities-predict_proba","title":"4.2 Classification Probabilities: <code>predict_proba()</code>","text":"<p>For classification tasks, get class probabilities:</p> <pre><code># Get class probabilities (only for classification)\nprobabilities = wm.predict_proba(X_test)\n# Returns: (n_samples, n_classes) with rows summing to 1\n</code></pre> <p>Raises ValueError if called on regression task.</p>"},{"location":"quick_start/wang_mendel/#43-membership-degrees-predict_membership","title":"4.3 Membership Degrees: <code>predict_membership()</code>","text":"<p>Get membership degrees for each output term:</p> <pre><code># Get membership degrees for output terms\nmembership_dict = wm.predict_membership(X_test)\n\n# Returns dictionary: {output_variable: {term_name: degrees_array}}\n# Example:\n# {\n#   'comfort': {\n#     'low': array([0.2, 0.7, ...]),\n#     'medium': array([0.6, 0.3, ...]),\n#     'high': array([0.1, 0.0, ...])\n#   }\n# }\n</code></pre> <p>Useful for interpretability - see which linguistic terms are activated.</p>"},{"location":"quick_start/wang_mendel/#44-detailed-membership-predict_membership_detailed","title":"4.4 Detailed Membership: <code>predict_membership_detailed()</code>","text":"<p>Get per-sample detailed membership information:</p> <pre><code># Get detailed membership for each sample\ndetails = wm.predict_membership_detailed(X_test)\n\n# Returns list of dicts (one per sample):\n# [\n#   {\n#     'sample_idx': 0,\n#     'outputs': {'comfort': 6.5},\n#     'membership': {\n#       'comfort': {\n#         'low': 0.2,\n#         'medium': 0.6,\n#         'high': 0.1\n#       }\n#     }\n#   },\n#   ...\n# ]\n</code></pre>"},{"location":"quick_start/wang_mendel/#5-training-statistics","title":"5. Training Statistics","text":"<p>Get comprehensive training statistics:</p> <pre><code>stats = wm.get_training_stats()\nprint(stats)\n</code></pre> <p>Returns dictionary with: <pre><code>{\n    'task': 'regression' or 'classification',\n    'n_samples': int,\n    'n_features': int,\n    'n_outputs': int,\n    'candidate_rules': int,  # Total rules before conflict resolution\n    'final_rules': int,      # Rules after conflict resolution\n    'conflicts_resolved': int,\n    # For classification only:\n    'n_classes': int,\n    'classes': list,\n    'output_ranges': dict    # Achievable ranges per output variable\n}\n</code></pre></p>"},{"location":"quick_start/wang_mendel/#6-complete-examples","title":"6. Complete Examples","text":""},{"location":"quick_start/wang_mendel/#61-regression-example","title":"6.1 Regression Example","text":"<pre><code>import numpy as np\nfrom fuzzy_systems.inference import MamdaniSystem\nfrom fuzzy_systems.learning import WangMendelLearning\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# Generate synthetic data\nnp.random.seed(42)\nX = np.random.uniform(0, 10, (500, 2))\ny = np.sin(X[:, 0]) + np.cos(X[:, 1]) + np.random.normal(0, 0.1, 500)\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Create and configure system\nsystem = MamdaniSystem()\n\n# Configure inputs\nsystem.add_input('x1', (0, 10))\nsystem.add_input('x2', (0, 10))\n\n# Add terms (3 per input)\nfor var in ['x1', 'x2']:\n    system.add_term(var, 'low', 'triangular', (0, 0, 5))\n    system.add_term(var, 'medium', 'triangular', (2.5, 5, 7.5))\n    system.add_term(var, 'high', 'triangular', (5, 10, 10))\n\n# Configure output\nsystem.add_output('y', (-2, 2))\nsystem.add_term('y', 'negative', 'triangular', (-2, -2, 0))\nsystem.add_term('y', 'zero', 'triangular', (-1, 0, 1))\nsystem.add_term('y', 'positive', 'triangular', (0, 2, 2))\n\n# Train with Wang-Mendel\nwm = WangMendelLearning(system, X_train, y_train, task='regression')\nwm.fit(verbose=True)\n\n# Evaluate\ny_pred = wm.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)\nr2 = r2_score(y_test, y_pred)\n\nprint(f\"\\nTest MSE: {mse:.4f}\")\nprint(f\"Test R\u00b2: {r2:.4f}\")\n\n# Get statistics\nstats = wm.get_training_stats()\nprint(f\"Rules generated: {stats['final_rules']}\")\n</code></pre>"},{"location":"quick_start/wang_mendel/#62-classification-example","title":"6.2 Classification Example","text":"<pre><code>import numpy as np\nfrom fuzzy_systems.inference import MamdaniSystem\nfrom fuzzy_systems.learning import WangMendelLearning\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.metrics import accuracy_score, classification_report\n\n# Load Iris dataset\niris = load_iris()\nX = iris.data[:, :2]  # Use only 2 features for simplicity\ny = iris.target\n\n# One-hot encode targets\nencoder = OneHotEncoder(sparse_output=False)\ny_onehot = encoder.fit_transform(y.reshape(-1, 1))\n\n# Split data\nX_train, X_test, y_train, y_test, y_train_onehot, y_test_onehot = train_test_split(\n    X, y, y_onehot, test_size=0.3, random_state=42\n)\n\n# Create system\nsystem = MamdaniSystem()\n\n# Configure inputs (sepal length and width)\nsystem.add_input('sepal_length', (4, 8))\nsystem.add_input('sepal_width', (2, 5))\n\n# Add terms\nfor var in ['sepal_length', 'sepal_width']:\n    system.add_term(var, 'small', 'triangular', (4, 4, 5.5))\n    system.add_term(var, 'medium', 'triangular', (4.5, 6, 7))\n    system.add_term(var, 'large', 'triangular', (6, 8, 8))\n\n# Configure outputs (one per class)\nfor i in range(3):\n    system.add_output(f'class_{i}', (0, 1))\n    system.add_term(f'class_{i}', 'no', 'triangular', (0, 0, 0.5))\n    system.add_term(f'class_{i}', 'yes', 'triangular', (0.5, 1, 1))\n\n# Train with Wang-Mendel\nwm = WangMendelLearning(system, X_train, y_train_onehot, task='classification')\nwm.fit(verbose=True)\n\n# Predict classes\ny_pred = wm.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\n\n# Get probabilities\ny_proba = wm.predict_proba(X_test)\n\nprint(f\"\\nTest Accuracy: {accuracy:.4f}\")\nprint(\"\\nClassification Report:\")\nprint(classification_report(y_test, y_pred, target_names=iris.target_names))\n\n# Show sample predictions with probabilities\nprint(\"\\nSample predictions:\")\nfor i in range(5):\n    print(f\"Sample {i}: True={y_test[i]}, Pred={y_pred[i]}, \"\n          f\"Proba={y_proba[i]}\")\n</code></pre>"},{"location":"quick_start/wang_mendel/#7-comparing-wang-mendel-vs-other-methods","title":"7. Comparing Wang-Mendel vs Other Methods","text":"Aspect Wang-Mendel ANFIS Manual Rules Rule Generation Automatic from data Optimized via learning Manual expert knowledge Training Speed Very fast (single pass) Slow (iterative) N/A Interpretability High (linguistic rules) Medium (can inspect MFs) High Accuracy Good baseline Best (optimized) Depends on expert Requires Data + MF definitions Data only Domain expertise Overfitting Risk Low (conflict resolution) Medium (can overfit) Low Best For Quick baseline, interpretable systems High accuracy requirements Known domain rules"},{"location":"quick_start/wang_mendel/#8-tips-and-best-practices","title":"8. Tips and Best Practices","text":""},{"location":"quick_start/wang_mendel/#membership-function-design","title":"Membership Function Design","text":"<ul> <li>Use 3-5 MFs per variable for good coverage without explosion</li> <li>Overlap MFs to ensure smooth transitions (typically 50% overlap)</li> <li>Cover the entire universe to avoid undefined regions</li> <li>Use triangular/trapezoidal for simplicity and interpretability</li> </ul>"},{"location":"quick_start/wang_mendel/#data-preparation","title":"Data Preparation","text":"<ul> <li>Normalize/scale inputs to match MF universes</li> <li>Remove outliers before defining MF ranges</li> <li>Ensure balanced classes for classification (or use weighted sampling)</li> </ul>"},{"location":"quick_start/wang_mendel/#rule-optimization","title":"Rule Optimization","text":"<pre><code># Check rule statistics\nstats = wm.get_training_stats()\nprint(f\"Rule efficiency: {stats['final_rules']} / {stats['candidate_rules']} \"\n      f\"({100*stats['final_rules']/stats['candidate_rules']:.1f}%)\")\n\n# Many conflicts = overlapping/redundant patterns\nif stats['conflicts_resolved'] &gt; stats['final_rules']:\n    print(\"\u26a0\ufe0f High conflict rate - consider:\")\n    print(\"  - Reducing number of MFs\")\n    print(\"  - Adjusting MF overlap\")\n    print(\"  - Checking for noisy data\")\n</code></pre>"},{"location":"quick_start/wang_mendel/#classification-setup","title":"Classification Setup","text":"<ul> <li>Use one output per class (one-hot encoding)</li> <li>Define binary MFs for each output: 'no' and 'yes'</li> <li>Enable scaling for better probability calibration: <code>scale_classification=True</code></li> <li>Check achievable ranges with <code>verbose_init=True</code></li> </ul>"},{"location":"quick_start/wang_mendel/#troubleshooting","title":"Troubleshooting","text":"Problem Solution Too many rules Reduce number of MFs per variable Too few rules Increase MF overlap, check data coverage Poor predictions Add more MFs, adjust MF shapes/positions Rules not interpretable Use simpler MF shapes (triangular) Conflicts &gt; 50% Reduce MFs or adjust overlap"},{"location":"quick_start/wang_mendel/#9-advantages-and-limitations","title":"9. Advantages and Limitations","text":""},{"location":"quick_start/wang_mendel/#advantages","title":"\u2705 Advantages","text":"<ol> <li>Fast: Single-pass through data (no iterative optimization)</li> <li>Interpretable: Generates readable IF-THEN rules</li> <li>No hyperparameters: No learning rate, epochs, etc.</li> <li>Automatic: No manual rule crafting needed</li> <li>Robust: Conflict resolution handles contradictions</li> <li>Baseline: Good starting point before trying complex methods</li> </ol>"},{"location":"quick_start/wang_mendel/#limitations","title":"\u26a0\ufe0f Limitations","text":"<ol> <li>Depends on MF design: Requires good initial MF placement</li> <li>No optimization: Rules not fine-tuned for accuracy</li> <li>Discrete selection: Uses only most-activated terms (not fuzzy combination)</li> <li>Fixed structure: Cannot adjust MF parameters during training</li> <li>Scalability: Rule count grows exponentially with inputs/MFs</li> </ol>"},{"location":"quick_start/wang_mendel/#when-to-use-wang-mendel","title":"When to Use Wang-Mendel","text":"<p>\u2705 Good for: - Quick prototyping and baseline modeling - Interpretable systems (medical, finance, control) - Small-to-medium datasets - When domain knowledge can guide MF design - Systems requiring explainability</p> <p>\u274c Not ideal for: - Maximum accuracy requirements (use ANFIS or deep learning) - Very high-dimensional inputs (curse of dimensionality) - When MF design is difficult - Real-time learning/adaptation needed</p>"},{"location":"quick_start/wang_mendel/#10-integration-with-other-methods","title":"10. Integration with Other Methods","text":"<p>Wang-Mendel can be combined with other techniques:</p>"},{"location":"quick_start/wang_mendel/#sequential-training","title":"Sequential Training","text":"<pre><code># Step 1: Get initial rules with Wang-Mendel\nwm = WangMendelLearning(system, X_train, y_train)\nwm.fit(verbose=True)\n\n# Step 2: Fine-tune with gradient-based learning\nfrom fuzzy_systems.learning import MamdaniLearning\nml = MamdaniLearning(wm.system, X_train, y_train)\nml.fit(epochs=50, optimizer='adam')\n\n# Now system has good initial rules + optimized parameters\n</code></pre>"},{"location":"quick_start/wang_mendel/#ensemble-methods","title":"Ensemble Methods","text":"<pre><code># Create multiple Wang-Mendel models with different MF configurations\nmodels = []\nfor n_mfs in [3, 4, 5]:\n    system = create_system(n_mfs)  # Create with different MF counts\n    wm = WangMendelLearning(system, X_train, y_train)\n    wm.fit()\n    models.append(wm)\n\n# Ensemble prediction (average)\npredictions = [model.predict(X_test) for model in models]\ny_pred = np.mean(predictions, axis=0)\n</code></pre>"},{"location":"quick_start/wang_mendel/#11-accessing-generated-rules","title":"11. Accessing Generated Rules","text":"<pre><code># Access final rules\nprint(f\"Total rules: {len(wm.final_rules)}\")\n\n# Print first 5 rules\nfor i, rule in enumerate(wm.final_rules[:5]):\n    print(f\"\\nRule {i+1}:\")\n    print(f\"  IF {rule['antecedents']}\")\n    print(f\"  THEN {rule['consequents']}\")\n    print(f\"  Degree: {rule['degree']:.3f}\")\n\n# Rules are also in the system\nwm.system.print_rules()\n</code></pre>"},{"location":"quick_start/wang_mendel/#references","title":"References","text":"<ul> <li>Wang, L. X., &amp; Mendel, J. M. (1992). \"Generating fuzzy rules by learning from examples.\" IEEE Transactions on Systems, Man, and Cybernetics, 22(6), 1414-1427.</li> </ul>"},{"location":"user_guide/dynamics/","title":"User Guide: Fuzzy Dynamical Systems","text":"<p>This guide covers how to model and solve dynamical systems with fuzzy parameters and initial conditions.</p>"},{"location":"user_guide/dynamics/#what-are-fuzzy-dynamical-systems","title":"What are Fuzzy Dynamical Systems?","text":"<p>Classical dynamical systems: - Crisp parameters (r = 0.5) - Crisp initial conditions (y\u2080 = 10) - Deterministic evolution</p> <p>Fuzzy dynamical systems: - Uncertain parameters (r \u2248 \"around 0.5\") - Uncertain initial conditions (y\u2080 \u2248 \"approximately 10\") - Prediction bands instead of single trajectories</p> <p>Why use fuzzy dynamics: - \ud83d\udcca Model parameter uncertainty - \ud83d\udd2c Handle measurement errors - \ud83c\udfaf Propagate uncertainty through time - \ud83c\udf10 Capture expert knowledge about ranges</p>"},{"location":"user_guide/dynamics/#overview-of-methods","title":"Overview of Methods","text":"Method Type Best For Output Fuzzy ODE Continuous-time ODEs with fuzzy IVPs \u03b1-level trajectories p-Fuzzy (Discrete) Discrete-time Difference equations Fuzzy number sequences p-Fuzzy (Continuous) Continuous-time Continuous dynamics Fuzzy trajectories <p>Quick decision: - Have a differential equation? \u2192 Fuzzy ODE - Have a difference equation? \u2192 p-Fuzzy Discrete - Need interactive dynamics? \u2192 p-Fuzzy Continuous</p>"},{"location":"user_guide/dynamics/#fuzzy-numbers","title":"Fuzzy Numbers","text":"<p>Before solving fuzzy dynamical systems, we need to represent uncertainty.</p>"},{"location":"user_guide/dynamics/#creating-fuzzy-numbers","title":"Creating Fuzzy Numbers","text":"<pre><code>from fuzzy_systems.dynamics import FuzzyNumber\nimport matplotlib.pyplot as plt\n\n# Triangular fuzzy number: \"approximately 10\"\ny0 = FuzzyNumber.triangular(center=10, spread=2)\n\n# Trapezoidal: \"between 8 and 12, most likely 9-11\"\ny0 = FuzzyNumber.trapezoidal(a=8, b=9, c=11, d=12)\n\n# Gaussian: \"around 10 with standard deviation 1\"\ny0 = FuzzyNumber.gaussian(center=10, sigma=1)\n\n# Plot\ny0.plot()\nplt.xlabel('Value')\nplt.ylabel('Membership')\nplt.title('Fuzzy Initial Condition')\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#operations-with-fuzzy-numbers","title":"Operations with Fuzzy Numbers","text":"<p>Fuzzy numbers support arithmetic operations:</p> <pre><code># Create fuzzy numbers\na = FuzzyNumber.triangular(center=5, spread=1)\nb = FuzzyNumber.triangular(center=3, spread=0.5)\n\n# Addition\nc = a + b  # Approximately 8 \u00b1 1.5\n\n# Subtraction\nd = a - b  # Approximately 2 \u00b1 1.5\n\n# Multiplication\ne = a * b  # Approximately 15 \u00b1 ...\n\n# Scalar operations\nf = 2 * a  # Approximately 10 \u00b1 2\ng = a + 5  # Approximately 10 \u00b1 1\n\n# Plot results\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(2, 3, figsize=(12, 6))\na.plot(ax=axes[0, 0], title='a')\nb.plot(ax=axes[0, 1], title='b')\nc.plot(ax=axes[0, 2], title='a + b')\nd.plot(ax=axes[1, 0], title='a - b')\ne.plot(ax=axes[1, 1], title='a * b')\nf.plot(ax=axes[1, 2], title='2 * a')\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Operations use \u03b1-level arithmetic: - Addition: [a, b] + [c, d] = [a+c, b+d] - Multiplication: [a, b] \u00d7 [c, d] = [min(ac, ad, bc, bd), max(ac, ad, bc, bd)]</p>"},{"location":"user_guide/dynamics/#-levels","title":"\u03b1-levels","text":"<p>Access specific confidence intervals:</p> <pre><code>y0 = FuzzyNumber.triangular(center=10, spread=2)\n\n# Get 0.5-level (50% confidence)\nlower, upper = y0.alpha_cut(alpha=0.5)\nprint(f\"0.5-level: [{lower:.2f}, {upper:.2f}]\")  # [9.0, 11.0]\n\n# Get support (0-level)\nlower, upper = y0.alpha_cut(alpha=0)\nprint(f\"Support: [{lower:.2f}, {upper:.2f}]\")  # [8.0, 12.0]\n\n# Get core (1-level)\nlower, upper = y0.alpha_cut(alpha=1)\nprint(f\"Core: [{lower:.2f}, {upper:.2f}]\")  # [10.0, 10.0]\n</code></pre>"},{"location":"user_guide/dynamics/#fuzzy-ode-solver","title":"Fuzzy ODE Solver","text":"<p>Solve ordinary differential equations with fuzzy initial conditions using the \u03b1-level method.</p>"},{"location":"user_guide/dynamics/#how-it-works","title":"How It Works","text":"<ol> <li>Choose \u03b1-levels: 0, 0.25, 0.5, 0.75, 1.0</li> <li>For each \u03b1:</li> <li>Extract interval [y_lower(\u03b1), y_upper(\u03b1)]</li> <li>Solve ODE twice: once with y_lower, once with y_upper</li> <li>Reconstruct fuzzy solution from intervals at each time point</li> </ol>"},{"location":"user_guide/dynamics/#example-1-logistic-growth","title":"Example 1: Logistic Growth","text":"<p>Model population growth with uncertain initial population:</p> \\[\\frac{dy}{dt} = r \\cdot y \\cdot \\left(1 - \\frac{y}{K}\\right)\\] <pre><code>from fuzzy_systems.dynamics import FuzzyODESolver, FuzzyNumber\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define logistic equation\ndef logistic(t, y, r, K):\n    \"\"\"\n    y: list of fuzzy numbers [y(t)]\n    Returns: dy/dt\n    \"\"\"\n    return r * y[0] * (1 - y[0] / K)\n\n# Fuzzy initial condition: \"approximately 10\"\ny0 = FuzzyNumber.triangular(center=10, spread=2)\n\n# Solve\nsolver = FuzzyODESolver(\n    f=logistic,\n    t_span=(0, 20),\n    y0_fuzzy=[y0],\n    params={'r': 0.3, 'K': 100},\n    n_alpha=11  # 11 \u03b1-levels\n)\n\nsolution = solver.solve()\n\n# Plot\nsolver.plot()\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.title('Logistic Growth with Fuzzy Initial Condition')\nplt.show()\n</code></pre> <p>Interpretation: - Dark region: High confidence (\u03b1 = 1.0) - Light region: Low confidence (\u03b1 = 0.0) - Uncertainty increases over time (characteristic of fuzzy ODEs)</p>"},{"location":"user_guide/dynamics/#example-2-predator-prey-lotka-volterra","title":"Example 2: Predator-Prey (Lotka-Volterra)","text":"<p>Two-dimensional system with fuzzy initial conditions:</p> \\[\\begin{aligned} \\frac{dx}{dt} &amp;= \\alpha x - \\beta x y \\\\ \\frac{dy}{dt} &amp;= \\delta x y - \\gamma y \\end{aligned}\\] <pre><code>def predator_prey(t, y, alpha, beta, delta, gamma):\n    \"\"\"\n    y[0]: prey population\n    y[1]: predator population\n    \"\"\"\n    x, y_pred = y\n    dx_dt = alpha * x - beta * x * y_pred\n    dy_dt = delta * x * y_pred - gamma * y_pred\n    return [dx_dt, dy_dt]\n\n# Fuzzy initial conditions\nx0 = FuzzyNumber.triangular(center=40, spread=5)   # Prey\ny0 = FuzzyNumber.triangular(center=9, spread=1)    # Predator\n\n# Solve\nsolver = FuzzyODESolver(\n    f=predator_prey,\n    t_span=(0, 30),\n    y0_fuzzy=[x0, y0],\n    params={'alpha': 0.1, 'beta': 0.02, 'delta': 0.01, 'gamma': 0.1},\n    n_alpha=11\n)\n\nsolution = solver.solve()\n\n# Plot both populations\nfig, axes = plt.subplots(1, 2, figsize=(12, 4))\n\nsolver.plot(variable_index=0, ax=axes[0])\naxes[0].set_ylabel('Prey Population')\naxes[0].set_title('Prey')\n\nsolver.plot(variable_index=1, ax=axes[1])\naxes[1].set_ylabel('Predator Population')\naxes[1].set_title('Predator')\n\nplt.tight_layout()\nplt.show()\n\n# Phase portrait\nsolver.plot_phase(variable_indices=(0, 1))\nplt.xlabel('Prey')\nplt.ylabel('Predator')\nplt.title('Phase Portrait')\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#solver-parameters","title":"Solver Parameters","text":"<pre><code>solver = FuzzyODESolver(\n    f=equation,\n    t_span=(t_start, t_end),\n    y0_fuzzy=[y0_1, y0_2, ...],  # List of FuzzyNumber\n    params={...},                 # Dictionary of crisp parameters\n    n_alpha=11,                   # Number of \u03b1-levels (odd number)\n    method='RK45',                # Integration method\n    rtol=1e-6,                    # Relative tolerance\n    atol=1e-9                     # Absolute tolerance\n)\n</code></pre> <p>Integration methods: - <code>'RK45'</code>: Runge-Kutta 4(5) (default, good balance) - <code>'RK23'</code>: Runge-Kutta 2(3) (faster, less accurate) - <code>'DOP853'</code>: Runge-Kutta 8 (slower, very accurate) - <code>'BDF'</code>: Backward differentiation (for stiff problems)</p> <p>Number of \u03b1-levels: - 5-7: Fast, coarse uncertainty bands - 11-21: Good balance (recommended) - 51+: Slow, smooth bands</p>"},{"location":"user_guide/dynamics/#accessing-solutions","title":"Accessing Solutions","text":"<pre><code>solution = solver.solve()\n\n# Time points\nt = solution['t']\n\n# Fuzzy solution at each time point\ny_fuzzy = solution['y']  # List of lists of FuzzyNumber\n\n# Get specific \u03b1-level trajectory\nalpha = 0.5\ny_lower, y_upper = solver.get_alpha_trajectory(alpha, variable_index=0)\n\n# Plot custom \u03b1-levels\nfig, ax = plt.subplots()\nfor alpha in [0, 0.25, 0.5, 0.75, 1.0]:\n    lower, upper = solver.get_alpha_trajectory(alpha, 0)\n    ax.fill_between(t, lower, upper, alpha=0.3, label=f'\u03b1={alpha}')\nax.legend()\nax.set_xlabel('Time')\nax.set_ylabel('y(t)')\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#fuzzy-parameters","title":"Fuzzy Parameters","text":"<p>Parameters can also be fuzzy:</p> <pre><code># Fuzzy growth rate: \"approximately 0.3\"\nr_fuzzy = FuzzyNumber.triangular(center=0.3, spread=0.05)\n\n# Convert to crisp samples for Monte Carlo\nn_samples = 100\nr_samples = [r_fuzzy.sample() for _ in range(n_samples)]\n\n# Solve for each sample\ntrajectories = []\nfor r_val in r_samples:\n    solver = FuzzyODESolver(\n        f=logistic,\n        t_span=(0, 20),\n        y0_fuzzy=[y0],\n        params={'r': r_val, 'K': 100},\n        n_alpha=5  # Fewer \u03b1-levels for speed\n    )\n    solution = solver.solve()\n    trajectories.append(solution['y'][0])  # First variable\n\n# Plot envelope\nimport numpy as np\nt = solution['t']\ny_array = np.array([traj for traj in trajectories])\ny_mean = y_array.mean(axis=0)\ny_std = y_array.std(axis=0)\n\nplt.fill_between(t, y_mean - 2*y_std, y_mean + 2*y_std, alpha=0.3)\nplt.plot(t, y_mean, 'r-', linewidth=2)\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.title('Logistic Growth with Fuzzy Parameter')\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#p-fuzzy-systems-discrete-time","title":"p-Fuzzy Systems (Discrete-Time)","text":"<p>p-Fuzzy systems use fuzzy rules to define dynamical systems.</p>"},{"location":"user_guide/dynamics/#basic-concept","title":"Basic Concept","text":"<p>Instead of equations, use linguistic rules:</p> <pre><code>IF x is LOW THEN x_next is MEDIUM\nIF x is MEDIUM THEN x_next is HIGH\nIF x is HIGH THEN x_next is LOW\n</code></pre>"},{"location":"user_guide/dynamics/#example-population-dynamics","title":"Example: Population Dynamics","text":"<pre><code>from fuzzy_systems.dynamics import PFuzzyDiscrete\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create discrete p-fuzzy system\nsystem = PFuzzyDiscrete(n_variables=1)\n\n# Add input (current state)\nsystem.add_input('x', (0, 100))\nsystem.add_term('x', 'low', 'trapezoidal', (0, 0, 20, 40))\nsystem.add_term('x', 'medium', 'triangular', (30, 50, 70))\nsystem.add_term('x', 'high', 'trapezoidal', (60, 80, 100, 100))\n\n# Add output (next state)\nsystem.add_output('x_next', (0, 100))\nsystem.add_term('x_next', 'low', 'trapezoidal', (0, 0, 20, 40))\nsystem.add_term('x_next', 'medium', 'triangular', (30, 50, 70))\nsystem.add_term('x_next', 'high', 'trapezoidal', (60, 80, 100, 100))\n\n# Add rules (discrete map)\nsystem.add_rules([\n    {'x': 'low', 'x_next': 'medium'},      # Low pop \u2192 grows to medium\n    {'x': 'medium', 'x_next': 'high'},     # Medium \u2192 grows to high\n    {'x': 'high', 'x_next': 'low'}         # High \u2192 collapses to low\n])\n\n# Simulate\nx0 = 10  # Initial population\ntrajectory = system.simulate(x0=x0, n_steps=20)\n\n# Plot\nplt.plot(trajectory['x'], 'o-')\nplt.xlabel('Time Step')\nplt.ylabel('Population')\nplt.title('Discrete p-Fuzzy Population Dynamics')\nplt.grid(True)\nplt.show()\n\n# Phase diagram (x_t vs x_{t+1})\nplt.plot(trajectory['x'][:-1], trajectory['x'][1:], 'o-')\nplt.plot([0, 100], [0, 100], 'k--', alpha=0.3)  # Identity line\nplt.xlabel('x(t)')\nplt.ylabel('x(t+1)')\nplt.title('Discrete Map')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#example-predator-prey-discrete","title":"Example: Predator-Prey (Discrete)","text":"<p>Two-variable system:</p> <pre><code>system = PFuzzyDiscrete(n_variables=2)\n\n# Prey (x)\nsystem.add_input('x', (0, 100))\nsystem.add_term('x', 'low', 'triangular', (0, 0, 50))\nsystem.add_term('x', 'high', 'triangular', (50, 100, 100))\n\nsystem.add_output('x_next', (0, 100))\nsystem.add_term('x_next', 'low', 'triangular', (0, 0, 50))\nsystem.add_term('x_next', 'medium', 'triangular', (25, 50, 75))\nsystem.add_term('x_next', 'high', 'triangular', (50, 100, 100))\n\n# Predator (y)\nsystem.add_input('y', (0, 50))\nsystem.add_term('y', 'low', 'triangular', (0, 0, 25))\nsystem.add_term('y', 'high', 'triangular', (25, 50, 50))\n\nsystem.add_output('y_next', (0, 50))\nsystem.add_term('y_next', 'low', 'triangular', (0, 0, 25))\nsystem.add_term('y_next', 'medium', 'triangular', (12.5, 25, 37.5))\nsystem.add_term('y_next', 'high', 'triangular', (25, 50, 50))\n\n# Rules\nsystem.add_rules([\n    # When prey low, predator low \u2192 both grow\n    {'x': 'low', 'y': 'low', 'x_next': 'medium', 'y_next': 'low'},\n\n    # When prey low, predator high \u2192 prey recovers, predator declines\n    {'x': 'low', 'y': 'high', 'x_next': 'medium', 'y_next': 'medium'},\n\n    # When prey high, predator low \u2192 prey stays high, predator grows\n    {'x': 'high', 'y': 'low', 'x_next': 'high', 'y_next': 'medium'},\n\n    # When prey high, predator high \u2192 prey declines, predator stays high\n    {'x': 'high', 'y': 'high', 'x_next': 'medium', 'y_next': 'high'},\n])\n\n# Simulate\ntrajectory = system.simulate(x0={'x': 40, 'y': 9}, n_steps=50)\n\n# Plot time series\nfig, axes = plt.subplots(2, 1, figsize=(10, 6), sharex=True)\n\naxes[0].plot(trajectory['x'], 'b-o', label='Prey')\naxes[0].set_ylabel('Prey')\naxes[0].legend()\naxes[0].grid(True)\n\naxes[1].plot(trajectory['y'], 'r-o', label='Predator')\naxes[1].set_ylabel('Predator')\naxes[1].set_xlabel('Time Step')\naxes[1].legend()\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# Phase portrait\nplt.plot(trajectory['x'], trajectory['y'], 'o-')\nplt.plot(trajectory['x'][0], trajectory['y'][0], 'go', markersize=10, label='Start')\nplt.plot(trajectory['x'][-1], trajectory['y'][-1], 'ro', markersize=10, label='End')\nplt.xlabel('Prey')\nplt.ylabel('Predator')\nplt.title('Phase Portrait')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#multiple-initial-conditions","title":"Multiple Initial Conditions","text":"<p>Explore different starting points:</p> <pre><code>initial_conditions = [\n    {'x': 10, 'y': 5},\n    {'x': 30, 'y': 15},\n    {'x': 70, 'y': 30},\n    {'x': 90, 'y': 45}\n]\n\nplt.figure(figsize=(10, 6))\nfor x0, y0 in initial_conditions:\n    traj = system.simulate(x0={'x': x0, 'y': y0}, n_steps=30)\n    plt.plot(traj['x'], traj['y'], 'o-', alpha=0.6)\n    plt.plot(x0, y0, 'o', markersize=10)\n\nplt.xlabel('Prey')\nplt.ylabel('Predator')\nplt.title('Phase Portrait from Multiple Initial Conditions')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#p-fuzzy-systems-continuous-time","title":"p-Fuzzy Systems (Continuous-Time)","text":"<p>Continuous-time p-fuzzy systems use rules to define derivatives.</p>"},{"location":"user_guide/dynamics/#example-logistic-growth","title":"Example: Logistic Growth","text":"<pre><code>from fuzzy_systems.dynamics import PFuzzyContinuous\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create continuous p-fuzzy system\nsystem = PFuzzyContinuous(n_variables=1)\n\n# Add input (current population)\nsystem.add_input('x', (0, 100))\nsystem.add_term('x', 'low', 'trapezoidal', (0, 0, 20, 40))\nsystem.add_term('x', 'medium', 'triangular', (30, 50, 70))\nsystem.add_term('x', 'high', 'trapezoidal', (60, 80, 100, 100))\n\n# Add output (growth rate dx/dt)\nsystem.add_output('dx_dt', (-10, 10))\nsystem.add_term('dx_dt', 'negative', 'trapezoidal', (-10, -10, -5, 0))\nsystem.add_term('dx_dt', 'zero', 'triangular', (-2, 0, 2))\nsystem.add_term('dx_dt', 'positive', 'trapezoidal', (0, 5, 10, 10))\n\n# Add rules\nsystem.add_rules([\n    {'x': 'low', 'dx_dt': 'positive'},      # Low pop \u2192 grows\n    {'x': 'medium', 'dx_dt': 'positive'},   # Medium \u2192 still grows\n    {'x': 'high', 'dx_dt': 'negative'}      # High \u2192 declines (carrying capacity)\n])\n\n# Simulate\nt_span = (0, 20)\nx0 = 10\nsolution = system.simulate(x0=x0, t_span=t_span, method='RK45')\n\n# Plot\nplt.plot(solution['t'], solution['x'])\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.title('Continuous p-Fuzzy Logistic Growth')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#example-predator-prey-continuous","title":"Example: Predator-Prey (Continuous)","text":"<pre><code>system = PFuzzyContinuous(n_variables=2)\n\n# Prey (x)\nsystem.add_input('x', (0, 100))\nsystem.add_term('x', 'low', 'triangular', (0, 0, 50))\nsystem.add_term('x', 'medium', 'triangular', (25, 50, 75))\nsystem.add_term('x', 'high', 'triangular', (50, 100, 100))\n\nsystem.add_output('dx_dt', (-20, 20))\nsystem.add_term('dx_dt', 'decrease', 'triangular', (-20, -20, 0))\nsystem.add_term('dx_dt', 'stable', 'triangular', (-5, 0, 5))\nsystem.add_term('dx_dt', 'increase', 'triangular', (0, 20, 20))\n\n# Predator (y)\nsystem.add_input('y', (0, 50))\nsystem.add_term('y', 'low', 'triangular', (0, 0, 25))\nsystem.add_term('y', 'medium', 'triangular', (12.5, 25, 37.5))\nsystem.add_term('y', 'high', 'triangular', (25, 50, 50))\n\nsystem.add_output('dy_dt', (-10, 10))\nsystem.add_term('dy_dt', 'decrease', 'triangular', (-10, -10, 0))\nsystem.add_term('dy_dt', 'stable', 'triangular', (-2, 0, 2))\nsystem.add_term('dy_dt', 'increase', 'triangular', (0, 10, 10))\n\n# Rules based on ecology\nsystem.add_rules([\n    # Low prey \u2192 prey can grow, predator declines\n    {'x': 'low', 'y': 'low', 'dx_dt': 'increase', 'dy_dt': 'stable'},\n    {'x': 'low', 'y': 'high', 'dx_dt': 'decrease', 'dy_dt': 'decrease'},\n\n    # Medium prey \u2192 balanced\n    {'x': 'medium', 'y': 'low', 'dx_dt': 'increase', 'dy_dt': 'increase'},\n    {'x': 'medium', 'y': 'medium', 'dx_dt': 'stable', 'dy_dt': 'stable'},\n    {'x': 'medium', 'y': 'high', 'dx_dt': 'decrease', 'dy_dt': 'increase'},\n\n    # High prey \u2192 prey declines, predator grows\n    {'x': 'high', 'y': 'low', 'dx_dt': 'stable', 'dy_dt': 'increase'},\n    {'x': 'high', 'y': 'high', 'dx_dt': 'decrease', 'dy_dt': 'stable'},\n])\n\n# Simulate\nsolution = system.simulate(\n    x0={'x': 40, 'y': 9},\n    t_span=(0, 50),\n    method='RK45'\n)\n\n# Plot time series\nfig, axes = plt.subplots(2, 1, figsize=(10, 6), sharex=True)\n\naxes[0].plot(solution['t'], solution['x'], 'b-')\naxes[0].set_ylabel('Prey')\naxes[0].grid(True)\n\naxes[1].plot(solution['t'], solution['y'], 'r-')\naxes[1].set_ylabel('Predator')\naxes[1].set_xlabel('Time')\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# Phase portrait\nplt.plot(solution['x'], solution['y'])\nplt.plot(solution['x'][0], solution['y'][0], 'go', markersize=10, label='Start')\nplt.xlabel('Prey')\nplt.ylabel('Predator')\nplt.title('Continuous p-Fuzzy Phase Portrait')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#comparing-methods","title":"Comparing Methods","text":"<p>Let's compare all three methods on the same problem (logistic growth):</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom fuzzy_systems.dynamics import (\n    FuzzyODESolver, FuzzyNumber,\n    PFuzzyDiscrete, PFuzzyContinuous\n)\n\n# Parameters\nr, K = 0.3, 100\ny0_value = 10\nt_max = 20\n\n# Method 1: Fuzzy ODE\ndef logistic_ode(t, y, r, K):\n    return r * y[0] * (1 - y[0] / K)\n\ny0_fuzzy = FuzzyNumber.triangular(center=y0_value, spread=2)\nsolver_ode = FuzzyODESolver(\n    f=logistic_ode,\n    t_span=(0, t_max),\n    y0_fuzzy=[y0_fuzzy],\n    params={'r': r, 'K': K},\n    n_alpha=11\n)\nsolution_ode = solver_ode.solve()\n\n# Method 2: p-Fuzzy Discrete\nsystem_discrete = PFuzzyDiscrete(n_variables=1)\nsystem_discrete.add_input('x', (0, K))\nsystem_discrete.add_term('x', 'low', 'trapezoidal', (0, 0, K*0.3, K*0.5))\nsystem_discrete.add_term('x', 'medium', 'triangular', (K*0.4, K*0.6, K*0.8))\nsystem_discrete.add_term('x', 'high', 'trapezoidal', (K*0.7, K*0.9, K, K))\n\nsystem_discrete.add_output('x_next', (0, K))\nsystem_discrete.add_term('x_next', 'low', 'trapezoidal', (0, 0, K*0.3, K*0.5))\nsystem_discrete.add_term('x_next', 'medium', 'triangular', (K*0.4, K*0.6, K*0.8))\nsystem_discrete.add_term('x_next', 'high', 'trapezoidal', (K*0.7, K*0.9, K, K))\n\n# Approximating continuous dynamics with discrete map\nsystem_discrete.add_rules([\n    {'x': 'low', 'x_next': 'medium'},\n    {'x': 'medium', 'x_next': 'high'},\n    {'x': 'high', 'x_next': 'high'}\n])\n\ntraj_discrete = system_discrete.simulate(x0=y0_value, n_steps=int(t_max))\n\n# Method 3: p-Fuzzy Continuous\nsystem_continuous = PFuzzyContinuous(n_variables=1)\nsystem_continuous.add_input('x', (0, K))\nsystem_continuous.add_term('x', 'low', 'trapezoidal', (0, 0, K*0.3, K*0.5))\nsystem_continuous.add_term('x', 'medium', 'triangular', (K*0.4, K*0.6, K*0.8))\nsystem_continuous.add_term('x', 'high', 'trapezoidal', (K*0.7, K*0.9, K, K))\n\nsystem_continuous.add_output('dx_dt', (-K, K))\nsystem_continuous.add_term('dx_dt', 'negative', 'triangular', (-K, -K, 0))\nsystem_continuous.add_term('dx_dt', 'zero', 'triangular', (-K*0.1, 0, K*0.1))\nsystem_continuous.add_term('dx_dt', 'positive', 'triangular', (0, K, K))\n\nsystem_continuous.add_rules([\n    {'x': 'low', 'dx_dt': 'positive'},\n    {'x': 'medium', 'dx_dt': 'positive'},\n    {'x': 'high', 'dx_dt': 'zero'}\n])\n\nsolution_continuous = system_continuous.simulate(\n    x0=y0_value,\n    t_span=(0, t_max),\n    method='RK45'\n)\n\n# Compare\nfig, axes = plt.subplots(1, 3, figsize=(15, 4))\n\n# Fuzzy ODE\nsolver_ode.plot(ax=axes[0])\naxes[0].set_title('Fuzzy ODE (\u03b1-levels)')\naxes[0].set_ylabel('Population')\n\n# p-Fuzzy Discrete\naxes[1].plot(range(len(traj_discrete['x'])), traj_discrete['x'], 'o-')\naxes[1].set_title('p-Fuzzy Discrete')\naxes[1].set_xlabel('Time Step')\naxes[1].grid(True)\n\n# p-Fuzzy Continuous\naxes[2].plot(solution_continuous['t'], solution_continuous['x'])\naxes[2].set_title('p-Fuzzy Continuous')\naxes[2].set_xlabel('Time')\naxes[2].grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Observations: - Fuzzy ODE: Shows uncertainty bands growing over time - p-Fuzzy Discrete: Step-wise evolution, good for discrete events - p-Fuzzy Continuous: Smooth trajectories, rule-based dynamics</p>"},{"location":"user_guide/dynamics/#design-guidelines","title":"Design Guidelines","text":""},{"location":"user_guide/dynamics/#1-choosing-levels","title":"1. Choosing \u03b1-levels","text":"<p>Trade-off: accuracy vs speed</p> <pre><code># Fast (3-5 levels)\nsolver = FuzzyODESolver(..., n_alpha=5)\n\n# Balanced (11-21 levels)\nsolver = FuzzyODESolver(..., n_alpha=11)  # Recommended\n\n# Smooth (51+ levels)\nsolver = FuzzyODESolver(..., n_alpha=51)  # Slow\n</code></pre> <p>Use fewer \u03b1-levels when: - Prototyping or exploring - Computational budget is limited - Rough uncertainty estimates are sufficient</p> <p>Use more \u03b1-levels when: - Creating publication-quality figures - Precise uncertainty quantification needed - Computational resources available</p>"},{"location":"user_guide/dynamics/#2-fuzzy-number-shapes","title":"2. Fuzzy Number Shapes","text":"<p>Triangular vs Trapezoidal vs Gaussian:</p> <pre><code># Triangular: \"approximately X\"\ny0 = FuzzyNumber.triangular(center=10, spread=2)\n\n# Trapezoidal: \"between A and B\"\ny0 = FuzzyNumber.trapezoidal(a=8, b=9, c=11, d=12)\n\n# Gaussian: \"normally distributed\"\ny0 = FuzzyNumber.gaussian(center=10, sigma=1)\n</code></pre> <p>Guidelines: - Use triangular for symmetric uncertainty - Use trapezoidal for ranges with plateaus - Use gaussian for measurement errors</p>"},{"location":"user_guide/dynamics/#3-rule-design-for-p-fuzzy","title":"3. Rule Design for p-Fuzzy","text":"<p>Principle: Rules should reflect domain knowledge</p> <p>Good rules (ecologically sound): <pre><code>system.add_rules([\n    {'prey': 'low', 'predator': 'high', 'dprey_dt': 'decrease'},\n    {'prey': 'high', 'predator': 'low', 'dprey_dt': 'increase'}\n])\n</code></pre></p> <p>Bad rules (contradictory): <pre><code>system.add_rules([\n    {'prey': 'low', 'dprey_dt': 'increase'},\n    {'prey': 'low', 'dprey_dt': 'decrease'}  # Conflict!\n])\n</code></pre></p> <p>Check rule coverage: <pre><code># Visualize rule activation\nsystem.plot_rule_matrix()  # For 2D systems\n</code></pre></p>"},{"location":"user_guide/dynamics/#4-integration-method-selection","title":"4. Integration Method Selection","text":"Method Speed Accuracy Best For <code>'RK23'</code> \u26a1\u26a1\u26a1 \u2b50\u2b50 Fast prototyping, smooth problems <code>'RK45'</code> \u26a1\u26a1 \u2b50\u2b50\u2b50 Default, most problems <code>'DOP853'</code> \u26a1 \u2b50\u2b50\u2b50\u2b50\u2b50 High precision needed <code>'BDF'</code> \u26a1\u26a1 \u2b50\u2b50\u2b50 Stiff equations <p>Stiff equations? Try <code>'BDF'</code> or <code>'Radau'</code>: <pre><code>solver = FuzzyODESolver(..., method='BDF')\n</code></pre></p>"},{"location":"user_guide/dynamics/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user_guide/dynamics/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>How sensitive is the solution to initial conditions?</p> <pre><code>from fuzzy_systems.dynamics import FuzzyODESolver, FuzzyNumber\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef logistic(t, y, r, K):\n    return r * y[0] * (1 - y[0] / K)\n\n# Test different spreads\nspreads = [1, 2, 5, 10]\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor spread in spreads:\n    y0 = FuzzyNumber.triangular(center=10, spread=spread)\n    solver = FuzzyODESolver(\n        f=logistic,\n        t_span=(0, 20),\n        y0_fuzzy=[y0],\n        params={'r': 0.3, 'K': 100},\n        n_alpha=11\n    )\n    solution = solver.solve()\n\n    # Plot envelope\n    t = solution['t']\n    y_lower, y_upper = solver.get_alpha_trajectory(alpha=0, variable_index=0)\n    ax.fill_between(t, y_lower, y_upper, alpha=0.3, label=f'spread={spread}')\n\nax.set_xlabel('Time')\nax.set_ylabel('Population')\nax.set_title('Sensitivity to Initial Uncertainty')\nax.legend()\nax.grid(True)\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#lyapunov-exponents-p-fuzzy-discrete","title":"Lyapunov Exponents (p-Fuzzy Discrete)","text":"<p>Measure chaos in discrete systems:</p> <pre><code>def lyapunov_exponent(system, x0, n_steps=1000, epsilon=1e-8):\n    \"\"\"Estimate largest Lyapunov exponent.\"\"\"\n    traj1 = system.simulate(x0=x0, n_steps=n_steps)['x']\n\n    # Perturbed trajectory\n    x0_perturbed = x0 + epsilon\n    traj2 = system.simulate(x0=x0_perturbed, n_steps=n_steps)['x']\n\n    # Compute divergence\n    divergence = [np.log(abs(traj2[i] - traj1[i]) / epsilon)\n                  for i in range(1, n_steps)]\n\n    lyapunov = np.mean(divergence)\n    return lyapunov\n\n# Test\nsystem = PFuzzyDiscrete(n_variables=1)\n# ... configure system ...\n\nlambda_max = lyapunov_exponent(system, x0=10)\nprint(f\"Lyapunov exponent: {lambda_max:.4f}\")\n\nif lambda_max &gt; 0:\n    print(\"System is chaotic!\")\nelif lambda_max &lt; 0:\n    print(\"System is stable.\")\nelse:\n    print(\"System is at the edge of chaos.\")\n</code></pre>"},{"location":"user_guide/dynamics/#bifurcation-diagrams-p-fuzzy","title":"Bifurcation Diagrams (p-Fuzzy)","text":"<p>Explore parameter space:</p> <pre><code># Vary a parameter and observe long-term behavior\nparameters = np.linspace(0.1, 0.5, 50)\nfinal_states = []\n\nfor param in parameters:\n    # Modify rule or parameter\n    system = create_system_with_param(param)\n\n    # Simulate and discard transient\n    traj = system.simulate(x0=10, n_steps=500)\n    final_states.append(traj['x'][-100:])  # Last 100 steps\n\n# Plot bifurcation diagram\nfor i, param in enumerate(parameters):\n    plt.plot([param]*len(final_states[i]), final_states[i],\n             'k,', alpha=0.5)\n\nplt.xlabel('Parameter')\nplt.ylabel('Long-term Population')\nplt.title('Bifurcation Diagram')\nplt.show()\n</code></pre>"},{"location":"user_guide/dynamics/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/dynamics/#problem-fuzzy-ode-solution-explodes","title":"Problem: Fuzzy ODE solution \"explodes\"","text":"<p>Symptoms: - Solution bands become extremely wide - Values go to infinity</p> <p>Causes: - Unstable dynamics - Tolerance too loose</p> <p>Solutions:</p> <pre><code># Tighten tolerances\nsolver = FuzzyODESolver(..., rtol=1e-9, atol=1e-12)\n\n# Use more stable integrator\nsolver = FuzzyODESolver(..., method='BDF')\n\n# Check classical solution first\ndef check_stability(f, t_span, y0, params):\n    from scipy.integrate import solve_ivp\n    sol = solve_ivp(lambda t, y: f(t, [y[0]], **params),\n                    t_span, [y0], method='RK45')\n    plt.plot(sol.t, sol.y[0])\n    plt.show()\n\ncheck_stability(logistic, (0, 20), 10, {'r': 0.3, 'K': 100})\n</code></pre>"},{"location":"user_guide/dynamics/#problem-p-fuzzy-system-has-no-output","title":"Problem: p-Fuzzy system has no output","text":"<p>Symptoms: - <code>simulate()</code> returns NaN or constant values - No rules are activating</p> <p>Solutions:</p> <pre><code># Debug: check fuzzification\nx_test = 50\ninput_degrees = system.inputs['x'].fuzzify(x_test)\nprint(f\"Input memberships at x={x_test}: {input_degrees}\")\n# Should be non-zero for at least one term\n\n# Debug: check rule activations\ndetails = system.evaluate_detailed(x=x_test)\nprint(f\"Rule activations: {details['rule_activations']}\")\n# Should have at least one non-zero activation\n\n# Fix: adjust term coverage\nsystem.plot_variables()  # Visual check\n</code></pre>"},{"location":"user_guide/dynamics/#problem-discrete-p-fuzzy-is-stuck-in-a-loop","title":"Problem: Discrete p-Fuzzy is stuck in a loop","text":"<p>Symptoms: - Trajectory oscillates between same values - Phase portrait shows closed loop</p> <p>Explanation: - This may be intentional (limit cycle) - Or rules create an attractor</p> <p>To verify: <pre><code># Test multiple initial conditions\nfor x0 in [10, 30, 50, 70, 90]:\n    traj = system.simulate(x0=x0, n_steps=50)\n    plt.plot(traj['x'], alpha=0.6)\nplt.xlabel('Time Step')\nplt.ylabel('x')\nplt.title('Trajectories from Different ICs')\nplt.show()\n\n# If all converge to same cycle \u2192 it's an attractor\n</code></pre></p>"},{"location":"user_guide/dynamics/#problem-continuous-p-fuzzy-doesnt-reach-equilibrium","title":"Problem: Continuous p-Fuzzy doesn't reach equilibrium","text":"<p>Causes: - Rules don't allow convergence - No \"zero growth\" rules</p> <p>Solutions:</p> <pre><code># Add equilibrium rules\nsystem.add_rules([\n    {'x': 'medium', 'dx_dt': 'zero'},  # Equilibrium at medium\n])\n\n# Or increase tolerance\nsolution = system.simulate(..., method='RK45', rtol=1e-3)\n</code></pre>"},{"location":"user_guide/dynamics/#next-steps","title":"Next Steps","text":"<ul> <li>Fundamentals: Review fuzzy logic basics</li> <li>API Reference: Dynamics: Complete method documentation</li> <li>Examples: Dynamics: Interactive notebooks</li> </ul>"},{"location":"user_guide/dynamics/#further-reading","title":"Further Reading","text":"<ul> <li>Puri, M. L., &amp; Ralescu, D. A. (1983): \"Differentials of fuzzy functions\". Journal of Mathematical Analysis and Applications, 91(2), 552-558.</li> <li>Buckley, J. J., &amp; Feuring, T. (2000): \"Fuzzy differential equations\". Fuzzy Sets and Systems, 110(1), 43-54.</li> <li>Barros, L. C., Bassanezi, R. C., &amp; Lodwick, W. A. (2017): A First Course in Fuzzy Logic, Fuzzy Dynamical Systems, and Biomathematics. Springer.</li> <li>Jafelice, R. M., et al. (2015): \"Fuzzy parameter in a prey-predator model\". Nonlinear Analysis: Real World Applications, 16, 59-71.</li> </ul>"},{"location":"user_guide/fundamentals/","title":"User Guide: Fundamentals","text":"<p>This guide introduces the fundamental concepts of fuzzy logic and how to use the <code>fuzzy_systems.core</code> module.</p>"},{"location":"user_guide/fundamentals/#what-is-fuzzy-logic","title":"What is Fuzzy Logic?","text":"<p>Classical logic uses binary values: True or False (1 or 0). Fuzzy logic extends this to handle partial truth: values between 0 and 1.</p> <p>Example: - Classical: \"Is 18\u00b0C cold?\" \u2192 Yes (1) or No (0) - Fuzzy: \"Is 18\u00b0C cold?\" \u2192 0.4 (somewhat cold)</p> <p>This allows systems to handle uncertainty and gradual transitions, making them more human-like.</p>"},{"location":"user_guide/fundamentals/#membership-functions","title":"Membership Functions","text":"<p>Membership functions (MFs) define how much an input belongs to a fuzzy set.</p>"},{"location":"user_guide/fundamentals/#types-of-membership-functions","title":"Types of Membership Functions","text":""},{"location":"user_guide/fundamentals/#1-triangular","title":"1. Triangular","text":"<p>Most common for its simplicity.</p> <p>Parameters: <code>(a, b, c)</code> where <code>b</code> is the peak</p> <pre><code>from fuzzy_systems.core import triangular\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10, 100)\nmu = triangular(x, (2, 5, 8))\n\nplt.plot(x, mu)\nplt.title('Triangular MF')\nplt.xlabel('x')\nplt.ylabel('\u03bc(x)')\nplt.show()\n</code></pre> <p>When to use: - Simple concepts with clear peaks - Fast computation needed - Educational purposes</p>"},{"location":"user_guide/fundamentals/#2-trapezoidal","title":"2. Trapezoidal","text":"<p>Has a plateau where \u03bc = 1.</p> <p>Parameters: <code>(a, b, c, d)</code> where <code>[b, c]</code> is the plateau</p> <pre><code>from fuzzy_systems.core import trapezoidal\n\nmu = trapezoidal(x, (1, 3, 7, 9))\n</code></pre> <p>When to use: - Ranges that are \"fully true\" (e.g., \"room temperature\" = 20-24\u00b0C) - Modeling endpoints (e.g., \"very low\" includes everything below 5)</p>"},{"location":"user_guide/fundamentals/#3-gaussian","title":"3. Gaussian","text":"<p>Smooth, bell-shaped curve.</p> <p>Parameters: <code>(mean, sigma)</code> where sigma controls width</p> <pre><code>from fuzzy_systems.core import gaussian\n\nmu = gaussian(x, (5, 1.5))\n</code></pre> <p>When to use: - Natural phenomena (measurements, sensors) - Smooth transitions needed - Mathematical modeling</p>"},{"location":"user_guide/fundamentals/#4-sigmoid","title":"4. Sigmoid","text":"<p>S-shaped curve, asymmetric.</p> <p>Parameters: <code>(slope, inflection_point)</code></p> <pre><code>from fuzzy_systems.core import sigmoid\n\nmu = sigmoid(x, (1, 5))\n</code></pre> <p>When to use: - Asymmetric concepts (e.g., \"increasing\", \"above threshold\") - Modeling saturation effects</p>"},{"location":"user_guide/fundamentals/#choosing-the-right-mf","title":"Choosing the Right MF","text":"Type Speed Smoothness Best For Triangular \u26a1\u26a1\u26a1 \u2b50 Simple models, fast prototyping Trapezoidal \u26a1\u26a1\u26a1 \u2b50 Ranges with plateaus Gaussian \u26a1\u26a1 \u2b50\u2b50\u2b50 Natural phenomena, smooth transitions Sigmoid \u26a1\u26a1 \u2b50\u2b50 Asymmetric concepts <p>Rule of thumb: Start with triangular, switch to gaussian if you need smoothness.</p>"},{"location":"user_guide/fundamentals/#fuzzy-sets","title":"Fuzzy Sets","text":"<p>A FuzzySet combines a name with a membership function.</p>"},{"location":"user_guide/fundamentals/#creating-fuzzy-sets","title":"Creating Fuzzy Sets","text":"<pre><code>from fuzzy_systems.core import FuzzySet\n\n# Create a fuzzy set for \"comfortable temperature\"\ncomfortable = FuzzySet(\n    name=\"comfortable\",\n    mf_type=\"triangular\",\n    params=(18, 22, 26)\n)\n\n# Calculate membership\ntemp = 20\nmu = comfortable.membership(temp)\nprint(f\"20\u00b0C is {mu:.2f} comfortable\")  # 0.50 comfortable\n</code></pre>"},{"location":"user_guide/fundamentals/#custom-membership-functions","title":"Custom Membership Functions","text":"<pre><code>def custom_mf(x):\n    \"\"\"Custom bell-shaped function.\"\"\"\n    return np.exp(-((x - 5)**2) / 8)\n\ncustom_set = FuzzySet(\n    name=\"custom\",\n    mf_type=\"custom\",\n    params=(),\n    mf_func=custom_mf\n)\n</code></pre>"},{"location":"user_guide/fundamentals/#linguistic-variables","title":"Linguistic Variables","text":"<p>A LinguisticVariable groups multiple fuzzy sets under one variable.</p>"},{"location":"user_guide/fundamentals/#basic-example","title":"Basic Example","text":"<pre><code>from fuzzy_systems.core import LinguisticVariable\n\n# Create variable\ntemperature = LinguisticVariable(\n    name=\"temperature\",\n    universe=(0, 40)\n)\n\n# Add fuzzy terms\ntemperature.add_term(\"cold\", \"trapezoidal\", (0, 0, 10, 18))\ntemperature.add_term(\"warm\", \"triangular\", (15, 22, 29))\ntemperature.add_term(\"hot\", \"trapezoidal\", (26, 32, 40, 40))\n</code></pre> <p>Key points: - Variable has a universe (valid range) - Each term is a fuzzy set - Terms can overlap (this is normal!)</p>"},{"location":"user_guide/fundamentals/#fuzzification","title":"Fuzzification","text":"<p>Convert a crisp value to membership degrees in all terms.</p> <pre><code># Fuzzify a value\ncurrent_temp = 24\ndegrees = temperature.fuzzify(current_temp)\n\nprint(degrees)\n# {'cold': 0.0, 'warm': 0.357, 'hot': 0.0}\n</code></pre> <p>Interpretation: 24\u00b0C is 35.7% warm and 0% cold/hot.</p>"},{"location":"user_guide/fundamentals/#visualizing-variables","title":"Visualizing Variables","text":"<pre><code>temperature.plot()\n</code></pre> <p>This creates a plot showing all terms overlapping on the same axis.</p>"},{"location":"user_guide/fundamentals/#fuzzy-operators","title":"Fuzzy Operators","text":"<p>Combine fuzzy values using AND, OR, NOT.</p>"},{"location":"user_guide/fundamentals/#and-t-norm","title":"AND (T-norm)","text":"<p>Minimum is the standard:</p> <pre><code>from fuzzy_systems.core import fuzzy_and_min\n\nmu_warm = 0.7\nmu_humid = 0.5\n\ncomfort = fuzzy_and_min(mu_warm, mu_humid)\nprint(comfort)  # 0.5 (takes minimum)\n</code></pre> <p>Alternative (Product): <pre><code>from fuzzy_systems.core import fuzzy_and_product\n\ncomfort = fuzzy_and_product(0.7, 0.5)\nprint(comfort)  # 0.35 (7 * 0.5)\n</code></pre></p> <p>When to use: - Use min for standard Mamdani systems - Use product for stricter combinations</p>"},{"location":"user_guide/fundamentals/#or-s-norm","title":"OR (S-norm)","text":"<p>Maximum is the standard:</p> <pre><code>from fuzzy_systems.core import fuzzy_or_max\n\ndiscomfort = fuzzy_or_max(0.3, 0.6)\nprint(discomfort)  # 0.6 (takes maximum)\n</code></pre> <p>Alternative (Probabilistic): <pre><code>from fuzzy_systems.core import fuzzy_or_probabilistic\n\nresult = fuzzy_or_probabilistic(0.3, 0.6)\nprint(result)  # 0.72 (= 0.3 + 0.6 - 0.3*0.6)\n</code></pre></p>"},{"location":"user_guide/fundamentals/#not-negation","title":"NOT (Negation)","text":"<p>Complement:</p> <pre><code>from fuzzy_systems.core import fuzzy_not\n\nmu_cold = 0.2\nmu_not_cold = fuzzy_not(mu_cold)\nprint(mu_not_cold)  # 0.8 (= 1 - 0.2)\n</code></pre>"},{"location":"user_guide/fundamentals/#practical-example-thermal-comfort","title":"Practical Example: Thermal Comfort","text":"<p>Let's build a complete example combining everything.</p>"},{"location":"user_guide/fundamentals/#step-1-define-variables","title":"Step 1: Define Variables","text":"<pre><code>from fuzzy_systems.core import LinguisticVariable\n\n# Temperature\ntemp_var = LinguisticVariable(\"temperature\", (0, 40))\ntemp_var.add_term(\"cold\", \"trapezoidal\", (0, 0, 12, 20))\ntemp_var.add_term(\"comfortable\", \"triangular\", (18, 24, 30))\ntemp_var.add_term(\"hot\", \"trapezoidal\", (28, 35, 40, 40))\n\n# Humidity\nhumid_var = LinguisticVariable(\"humidity\", (0, 100))\nhumid_var.add_term(\"dry\", \"trapezoidal\", (0, 0, 30, 50))\nhumid_var.add_term(\"normal\", \"triangular\", (40, 60, 80))\nhumid_var.add_term(\"humid\", \"trapezoidal\", (70, 85, 100, 100))\n</code></pre>"},{"location":"user_guide/fundamentals/#step-2-fuzzify-inputs","title":"Step 2: Fuzzify Inputs","text":"<pre><code>current_temp = 26\ncurrent_humidity = 65\n\ntemp_degrees = temp_var.fuzzify(current_temp)\nhumid_degrees = humid_var.fuzzify(current_humidity)\n\nprint(\"Temperature:\")\nfor term, degree in temp_degrees.items():\n    print(f\"  {term}: {degree:.3f}\")\n\nprint(\"\\nHumidity:\")\nfor term, degree in humid_degrees.items():\n    print(f\"  {term}: {degree:.3f}\")\n</code></pre> <p>Output: <pre><code>Temperature:\n  cold: 0.000\n  comfortable: 0.667\n  hot: 0.000\n\nHumidity:\n  dry: 0.000\n  normal: 0.750\n  humid: 0.000\n</code></pre></p>"},{"location":"user_guide/fundamentals/#step-3-apply-rules","title":"Step 3: Apply Rules","text":"<pre><code>from fuzzy_systems.core import fuzzy_and_min, fuzzy_or_max\n\n# Rule 1: IF temp is comfortable AND humidity is normal THEN very comfortable\nrule1 = fuzzy_and_min(temp_degrees['comfortable'], humid_degrees['normal'])\nprint(f\"Rule 1 (very comfortable): {rule1:.3f}\")  # 0.667\n\n# Rule 2: IF temp is hot OR humidity is humid THEN uncomfortable\nrule2 = fuzzy_or_max(temp_degrees['hot'], humid_degrees['humid'])\nprint(f\"Rule 2 (uncomfortable): {rule2:.3f}\")  # 0.000\n\n# Rule 3: IF temp is cold THEN uncomfortable\nrule3 = temp_degrees['cold']\nprint(f\"Rule 3 (cold uncomfortable): {rule3:.3f}\")  # 0.000\n</code></pre> <p>Interpretation: - 26\u00b0C with 65% humidity is 66.7% very comfortable - Not uncomfortable (0%)</p>"},{"location":"user_guide/fundamentals/#common-patterns","title":"Common Patterns","text":""},{"location":"user_guide/fundamentals/#pattern-1-three-term-variable","title":"Pattern 1: Three-Term Variable","text":"<p>Standard partition for most variables:</p> <pre><code>var = LinguisticVariable(\"variable\", (0, 100))\nvar.add_term(\"low\", \"trapezoidal\", (0, 0, 20, 40))\nvar.add_term(\"medium\", \"triangular\", (30, 50, 70))\nvar.add_term(\"high\", \"trapezoidal\", (60, 80, 100, 100))\n</code></pre>"},{"location":"user_guide/fundamentals/#pattern-2-five-term-variable","title":"Pattern 2: Five-Term Variable","text":"<p>More granular control:</p> <pre><code>var = LinguisticVariable(\"variable\", (0, 100))\nvar.add_term(\"very_low\", \"trapezoidal\", (0, 0, 10, 25))\nvar.add_term(\"low\", \"triangular\", (15, 25, 40))\nvar.add_term(\"medium\", \"triangular\", (30, 50, 70))\nvar.add_term(\"high\", \"triangular\", (60, 75, 85))\nvar.add_term(\"very_high\", \"trapezoidal\", (75, 90, 100, 100))\n</code></pre>"},{"location":"user_guide/fundamentals/#pattern-3-asymmetric-endpoints","title":"Pattern 3: Asymmetric Endpoints","text":"<p>Use trapezoidal at boundaries:</p> <pre><code>var = LinguisticVariable(\"variable\", (0, 100))\n# Left endpoint: trapezoidal with flat left side\nvar.add_term(\"very_low\", \"trapezoidal\", (0, 0, 15, 30))\n\n# Middle: triangular\nvar.add_term(\"medium\", \"triangular\", (25, 50, 75))\n\n# Right endpoint: trapezoidal with flat right side\nvar.add_term(\"very_high\", \"trapezoidal\", (70, 85, 100, 100))\n</code></pre>"},{"location":"user_guide/fundamentals/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"user_guide/fundamentals/#1-overlapping-is-good","title":"1. Overlapping is Good","text":"<p>Terms should overlap by 25-50% for smooth transitions.</p> <p>Good: <pre><code>     /\\        /\\        /\\\n    /  \\      /  \\      /  \\\n   /    \\    /    \\    /    \\\n  /      \\  /      \\  /      \\\n /________\\/________\\/________\\\n  low     medium    high\n</code></pre></p> <p>Bad (no overlap): <pre><code>  /\\       /\\       /\\\n /  \\     /  \\     /  \\\n/____\\   /____\\   /____\\\n low     medium    high\n</code></pre></p>"},{"location":"user_guide/fundamentals/#2-universe-coverage","title":"2. Universe Coverage","text":"<p>Make sure terms cover the entire universe:</p> <pre><code># Good: covers [0, 100]\nvar.add_term(\"low\", \"trapezoidal\", (0, 0, 30, 50))\nvar.add_term(\"high\", \"trapezoidal\", (50, 70, 100, 100))\n\n# Bad: gap between 50-60\nvar.add_term(\"low\", \"triangular\", (0, 25, 50))\nvar.add_term(\"high\", \"triangular\", (60, 80, 100))\n</code></pre>"},{"location":"user_guide/fundamentals/#3-symmetric-vs-asymmetric","title":"3. Symmetric vs Asymmetric","text":"<ul> <li>Symmetric (triangular/gaussian): Neutral concepts (medium, normal)</li> <li>Asymmetric (sigmoid/trapezoidal): Directional concepts (increasing, above)</li> </ul>"},{"location":"user_guide/fundamentals/#4-number-of-terms","title":"4. Number of Terms","text":"<ul> <li>3 terms: Simple, fast, interpretable</li> <li>5 terms: Good balance</li> <li>7-9 terms: Complex, precise (use with learning algorithms)</li> </ul> <p>Rule: Start with 3, add more only if needed.</p>"},{"location":"user_guide/fundamentals/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/fundamentals/#problem-value-outside-universe","title":"Problem: \"Value outside universe\"","text":"<pre><code>temperature = LinguisticVariable(\"temp\", (0, 40))\ntemp_degrees = temperature.fuzzify(50)  # \u26a0\ufe0f Warning!\n</code></pre> <p>Solution: Extend universe or clip input: <pre><code>value = min(max(value, 0), 40)  # Clip to [0, 40]\n</code></pre></p>"},{"location":"user_guide/fundamentals/#problem-all-membership-degrees-are-zero","title":"Problem: \"All membership degrees are zero\"","text":"<p>Cause: No term covers the input value.</p> <p>Solution: Check term coverage with plots: <pre><code>temperature.plot()\nplt.axvline(x=value, color='r', linestyle='--')  # Check if covered\nplt.show()\n</code></pre></p>"},{"location":"user_guide/fundamentals/#problem-membership-degree-is-always-1","title":"Problem: \"Membership degree is always 1\"","text":"<p>Cause: Terms are too wide or value is exactly at a peak.</p> <p>Solution: Adjust term parameters to reduce overlap.</p>"},{"location":"user_guide/fundamentals/#next-steps","title":"Next Steps","text":"<p>Now that you understand fuzzy logic fundamentals:</p> <ol> <li>Inference Systems - Build complete Mamdani and Sugeno systems</li> <li>API Reference: Core - Detailed API documentation</li> <li>Examples: Fundamentals - Interactive notebooks</li> </ol>"},{"location":"user_guide/fundamentals/#further-reading","title":"Further Reading","text":"<ul> <li>Zadeh, L.A. (1965): \"Fuzzy Sets\". Information and Control, 8(3), 338-353.</li> <li>Ross, T.J. (2010): Fuzzy Logic with Engineering Applications. Wiley.</li> <li>Membership Functions: Complete API reference</li> </ul>"},{"location":"user_guide/inference_systems/","title":"User Guide: Inference Systems","text":"<p>This guide covers how to build complete fuzzy inference systems using Mamdani and Sugeno methods.</p>"},{"location":"user_guide/inference_systems/#what-is-a-fuzzy-inference-system","title":"What is a Fuzzy Inference System?","text":"<p>A Fuzzy Inference System (FIS) transforms fuzzy inputs into fuzzy (or crisp) outputs through a rule base.</p> <p>Components: 1. Fuzzification: Convert crisp inputs \u2192 fuzzy degrees 2. Rule Base: IF-THEN rules 3. Inference Engine: Apply rules 4. Aggregation: Combine rule outputs 5. Defuzzification: Convert fuzzy output \u2192 crisp value</p>"},{"location":"user_guide/inference_systems/#mamdani-vs-sugeno","title":"Mamdani vs Sugeno","text":"Feature Mamdani Sugeno (TSK) Output Linguistic fuzzy sets Mathematical functions Defuzzification Centroid, MOM, etc. Weighted average Interpretability \u2b50\u2b50\u2b50 Very high \u2b50\u2b50 Moderate Computation Slower (integration) \u26a1 Faster (direct) Best for Expert systems, control Function approximation, modeling Example output \"Fan speed is FAST\" \"Fan speed = 0.8*temp + 10\" <p>When to use: - Mamdani: You need interpretable rules with linguistic outputs - Sugeno: You need precise numerical modeling or faster computation</p>"},{"location":"user_guide/inference_systems/#mamdani-systems","title":"Mamdani Systems","text":""},{"location":"user_guide/inference_systems/#the-5-steps-of-mamdani-inference","title":"The 5 Steps of Mamdani Inference","text":"<p>Let's build a temperature-controlled fan system step by step.</p>"},{"location":"user_guide/inference_systems/#step-1-fuzzification","title":"Step 1: Fuzzification","text":"<pre><code>from fuzzy_systems import MamdaniSystem\n\n# Create system\nsystem = MamdaniSystem(name=\"Fan Controller\")\n\n# Add input\nsystem.add_input('temperature', (0, 40))\nsystem.add_term('temperature', 'cold', 'triangular', (0, 0, 20))\nsystem.add_term('temperature', 'warm', 'triangular', (10, 20, 30))\nsystem.add_term('temperature', 'hot', 'triangular', (20, 40, 40))\n\n# Fuzzify (internal step when evaluating)\n# For 25\u00b0C: cold=0.25, warm=0.5, hot=0.25\n</code></pre>"},{"location":"user_guide/inference_systems/#step-2-rule-application","title":"Step 2: Rule Application","text":"<pre><code># Add output\nsystem.add_output('fan_speed', (0, 100))\nsystem.add_term('fan_speed', 'slow', 'triangular', (0, 0, 50))\nsystem.add_term('fan_speed', 'medium', 'triangular', (25, 50, 75))\nsystem.add_term('fan_speed', 'fast', 'triangular', (50, 100, 100))\n\n# Add rules\nsystem.add_rules([\n    ('cold', 'slow'),    # IF temp is cold THEN speed is slow\n    ('warm', 'medium'),  # IF temp is warm THEN speed is medium\n    ('hot', 'fast')      # IF temp is hot THEN speed is fast\n])\n</code></pre>"},{"location":"user_guide/inference_systems/#step-3-5-implication-aggregation-defuzzification","title":"Step 3-5: Implication, Aggregation, Defuzzification","text":"<p>These happen automatically in <code>.evaluate()</code>:</p> <pre><code>result = system.evaluate(temperature=25)\nprint(f\"Fan speed: {result['fan_speed']:.1f}%\")  # 50.0%\n</code></pre> <p>What happened internally: 1. Implication: Each rule \"cuts\" its output MF at the activation level 2. Aggregation: All cut MFs are combined (usually MAX) 3. Defuzzification: Center of gravity (COG) \u2192 crisp value</p>"},{"location":"user_guide/inference_systems/#building-your-first-mamdani-system","title":"Building Your First Mamdani System","text":""},{"location":"user_guide/inference_systems/#complete-example-tipping-system","title":"Complete Example: Tipping System","text":"<pre><code>from fuzzy_systems import MamdaniSystem\n\n# Step 1: Create system\nsystem = MamdaniSystem(name=\"Tipping System\")\n\n# Step 2: Add inputs\nsystem.add_input('service', (0, 10))\nsystem.add_input('food', (0, 10))\n\n# Step 3: Add input terms\nfor var in ['service', 'food']:\n    system.add_term(var, 'poor', 'triangular', (0, 0, 5))\n    system.add_term(var, 'good', 'triangular', (0, 5, 10))\n    system.add_term(var, 'excellent', 'triangular', (5, 10, 10))\n\n# Step 4: Add output\nsystem.add_output('tip', (0, 25))\n\n# Step 5: Add output terms\nsystem.add_term('tip', 'low', 'triangular', (0, 0, 13))\nsystem.add_term('tip', 'medium', 'triangular', (0, 13, 25))\nsystem.add_term('tip', 'high', 'triangular', (13, 25, 25))\n\n# Step 6: Add rules\nsystem.add_rules([\n    {'service': 'poor', 'food': 'poor', 'tip': 'low'},\n    {'service': 'good', 'food': 'good', 'tip': 'medium'},\n    {'service': 'excellent', 'food': 'excellent', 'tip': 'high'},\n])\n\n# Step 7: Evaluate\nresult = system.evaluate(service=7, food=8)\nprint(f\"Tip: {result['tip']:.1f}%\")\n</code></pre>"},{"location":"user_guide/inference_systems/#rule-formats","title":"Rule Formats","text":""},{"location":"user_guide/inference_systems/#format-1-dictionary-explicit","title":"Format 1: Dictionary (Explicit)","text":"<p>Most readable for complex rules:</p> <pre><code>system.add_rules([\n    {\n        'service': 'poor',\n        'food': 'poor',\n        'tip': 'low',\n        'operator': 'AND',  # Optional\n        'weight': 1.0       # Optional\n    }\n])\n</code></pre>"},{"location":"user_guide/inference_systems/#format-2-tuple-compact","title":"Format 2: Tuple (Compact)","text":"<p>Best for simple systems:</p> <pre><code># Order: (input1, input2, ..., output1, output2, ...)\nsystem.add_rules([\n    ('poor', 'poor', 'low'),\n    ('good', 'good', 'medium'),\n    ('excellent', 'excellent', 'high')\n])\n</code></pre>"},{"location":"user_guide/inference_systems/#format-3-indices","title":"Format 3: Indices","text":"<p>Use term index instead of name:</p> <pre><code># 0 = first term, 1 = second term, etc.\nsystem.add_rules([\n    (0, 0, 0),  # poor, poor \u2192 low\n    (1, 1, 1),  # good, good \u2192 medium\n    (2, 2, 2)   # excellent, excellent \u2192 high\n])\n</code></pre>"},{"location":"user_guide/inference_systems/#operators-in-rules","title":"Operators in Rules","text":""},{"location":"user_guide/inference_systems/#and-default","title":"AND (default)","text":"<p>Both conditions must be satisfied:</p> <pre><code>system.add_rule({\n    'temperature': 'hot',\n    'humidity': 'high',\n    'fan_speed': 'fast',\n    'operator': 'AND'  # Takes MIN of activations\n})\n</code></pre>"},{"location":"user_guide/inference_systems/#or","title":"OR","text":"<p>At least one condition must be satisfied:</p> <pre><code>system.add_rule({\n    'temperature': 'hot',\n    'humidity': 'high',\n    'fan_speed': 'fast',\n    'operator': 'OR'  # Takes MAX of activations\n})\n</code></pre>"},{"location":"user_guide/inference_systems/#rule-weights","title":"Rule Weights","text":"<p>Reduce a rule's influence:</p> <pre><code>system.add_rule({\n    'temperature': 'cold',\n    'fan_speed': 'slow',\n    'weight': 0.5  # Only 50% influence\n})\n</code></pre>"},{"location":"user_guide/inference_systems/#defuzzification-methods","title":"Defuzzification Methods","text":"<p>Choose how to convert the fuzzy output to a crisp value:</p> <pre><code>system = MamdaniSystem(defuzz_method='centroid')  # Default\n</code></pre> <p>Available methods:</p> Method Description When to use <code>'centroid'</code> (COG) Center of gravity Default, balanced <code>'bisector'</code> Divides area in half Alternative to COG <code>'mom'</code> Mean of maximum Emphasize peak values <code>'som'</code> Smallest of maximum Conservative choice <code>'lom'</code> Largest of maximum Aggressive choice <p>Example comparison:</p> <pre><code>methods = ['centroid', 'bisector', 'mom', 'som', 'lom']\n\nfor method in methods:\n    system = MamdaniSystem(defuzz_method=method)\n    # ... configure system ...\n    result = system.evaluate(temperature=25)\n    print(f\"{method}: {result['fan_speed']:.2f}%\")\n</code></pre>"},{"location":"user_guide/inference_systems/#visualization","title":"Visualization","text":""},{"location":"user_guide/inference_systems/#plot-variables","title":"Plot Variables","text":"<pre><code># Plot all variables\nsystem.plot_variables()\n\n# Plot specific variables\nsystem.plot_variables(['temperature', 'fan_speed'])\n</code></pre>"},{"location":"user_guide/inference_systems/#plot-rule-matrix","title":"Plot Rule Matrix","text":"<p>For 2-input systems, shows rules as a heatmap:</p> <pre><code>system.plot_rule_matrix()\n</code></pre>"},{"location":"user_guide/inference_systems/#saving-and-loading","title":"Saving and Loading","text":"<pre><code># Save system\nsystem.save('my_system.pkl')\n\n# Load system\nfrom fuzzy_systems import MamdaniSystem\nsystem = MamdaniSystem.load('my_system.pkl')\n\n# Export rules only\nsystem.export_rules('rules.json', format='json')\nsystem.export_rules('rules.txt', format='txt')\n\n# Import rules\nsystem.import_rules('rules.json', format='json')\n</code></pre>"},{"location":"user_guide/inference_systems/#sugeno-systems","title":"Sugeno Systems","text":""},{"location":"user_guide/inference_systems/#zero-order-sugeno","title":"Zero-Order Sugeno","text":"<p>Outputs are constants.</p> <pre><code>from fuzzy_systems import SugenoSystem\n\n# Create system\nsystem = SugenoSystem()\n\n# Add input\nsystem.add_input('x', (0, 10))\nsystem.add_term('x', 'low', 'triangular', (0, 0, 5))\nsystem.add_term('x', 'medium', 'triangular', (0, 5, 10))\nsystem.add_term('x', 'high', 'triangular', (5, 10, 10))\n\n# Add output (order 0 = constant)\nsystem.add_output('y', order=0)\n\n# Add rules with constant outputs\nsystem.add_rules([\n    ('low', 2.0),      # IF x is low THEN y = 2.0\n    ('medium', 5.0),   # IF x is medium THEN y = 5.0\n    ('high', 8.0)      # IF x is high THEN y = 8.0\n])\n\n# Evaluate\nresult = system.evaluate(x=6)\nprint(f\"y = {result['y']:.2f}\")\n</code></pre> <p>How it works: 1. Fuzzify input: x=6 \u2192 low=0, medium=0.8, high=0.2 2. Apply rules: y\u2081=2.0 (w\u2081=0), y\u2082=5.0 (w\u2082=0.8), y\u2083=8.0 (w\u2083=0.2) 3. Weighted average: y = (0\u00d72 + 0.8\u00d75 + 0.2\u00d78) / (0 + 0.8 + 0.2) = 5.6</p>"},{"location":"user_guide/inference_systems/#first-order-sugeno","title":"First-Order Sugeno","text":"<p>Outputs are linear functions of inputs.</p> <pre><code>system = SugenoSystem()\n\n# Add inputs\nsystem.add_input('x1', (0, 10))\nsystem.add_input('x2', (0, 10))\n\n# Add terms\nfor var in ['x1', 'x2']:\n    system.add_term(var, 'low', 'triangular', (0, 0, 5))\n    system.add_term(var, 'high', 'triangular', (5, 10, 10))\n\n# Add output (order 1 = linear function)\nsystem.add_output('y', order=1)\n\n# Rules: y = a*x1 + b*x2 + c\nsystem.add_rules([\n    # (input1_term, input2_term, a, b, c)\n    ('low', 'low', 1.0, 0.5, 2.0),    # y = 1.0*x1 + 0.5*x2 + 2.0\n    ('low', 'high', 2.0, 1.0, 0.0),   # y = 2.0*x1 + 1.0*x2 + 0.0\n    ('high', 'low', 0.5, 2.0, 1.0),   # y = 0.5*x1 + 2.0*x2 + 1.0\n    ('high', 'high', 1.0, 1.0, 3.0)   # y = 1.0*x1 + 1.0*x2 + 3.0\n])\n\n# Evaluate\nresult = system.evaluate(x1=7, x2=3)\nprint(f\"y = {result['y']:.2f}\")\n</code></pre> <p>How it works: 1. Fuzzify: x1=7 \u2192 low=0.6, high=0.4; x2=3 \u2192 low=0.4, high=0.6 2. Calculate rule activations (AND = MIN):    - Rule 1: min(0.6, 0.4) = 0.4 \u2192 y\u2081 = 1.0\u00d77 + 0.5\u00d73 + 2.0 = 10.5    - Rule 2: min(0.6, 0.6) = 0.6 \u2192 y\u2082 = 2.0\u00d77 + 1.0\u00d73 + 0.0 = 17.0    - Rule 3: min(0.4, 0.4) = 0.4 \u2192 y\u2083 = 0.5\u00d77 + 2.0\u00d73 + 1.0 = 10.5    - Rule 4: min(0.4, 0.6) = 0.4 \u2192 y\u2084 = 1.0\u00d77 + 1.0\u00d73 + 3.0 = 13.0 3. Weighted average: y = (0.4\u00d710.5 + 0.6\u00d717 + 0.4\u00d710.5 + 0.4\u00d713) / (0.4+0.6+0.4+0.4)</p>"},{"location":"user_guide/inference_systems/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user_guide/inference_systems/#custom-t-norms-and-s-norms","title":"Custom T-norms and S-norms","text":"<pre><code>system = MamdaniSystem(\n    t_norm='product',        # AND: a * b instead of min(a, b)\n    s_norm='probabilistic',  # OR: a + b - a*b instead of max(a, b)\n    implication='product'    # Larsen instead of Mamdani\n)\n</code></pre> <p>Options:</p> <p>T-norms (AND): - <code>'min'</code> (default): min(a, b) - <code>'product'</code>: a \u00d7 b - <code>'lukasiewicz'</code>: max(0, a + b - 1)</p> <p>S-norms (OR): - <code>'max'</code> (default): max(a, b) - <code>'probabilistic'</code>: a + b - a\u00d7b - <code>'bounded'</code>: min(1, a + b)</p>"},{"location":"user_guide/inference_systems/#detailed-evaluation","title":"Detailed Evaluation","text":"<p>Get intermediate results:</p> <pre><code>details = system.evaluate_detailed(temperature=25)\n\nprint(\"Fuzzified inputs:\")\nprint(details['inputs'])\n# {'temperature': {'cold': 0.25, 'warm': 0.5, 'hot': 0.25}}\n\nprint(\"\\nRule activations:\")\nfor i, activation in enumerate(details['rule_activations']):\n    print(f\"  Rule {i+1}: {activation:.3f}\")\n\nprint(\"\\nAggregated output MF:\")\nprint(details['aggregated'])\n\nprint(\"\\nFinal outputs:\")\nprint(details['outputs'])\n</code></pre>"},{"location":"user_guide/inference_systems/#design-guidelines","title":"Design Guidelines","text":""},{"location":"user_guide/inference_systems/#1-number-of-rules","title":"1. Number of Rules","text":"<p>For a system with n inputs and k terms per input: - Maximum rules: k^n (combinatorial explosion!) - Typical rules: 0.3 \u00d7 k^n to 0.7 \u00d7 k^n</p> <p>Example: 2 inputs, 5 terms each: - Max: 5\u00b2 = 25 rules - Typical: 8-18 rules (skip irrelevant combinations)</p>"},{"location":"user_guide/inference_systems/#2-term-overlap","title":"2. Term Overlap","text":"<p>Adjacent terms should overlap by 25-50%:</p> <pre><code># Good overlap\nsystem.add_term('temp', 'cold', 'triangular', (0, 0, 20))\nsystem.add_term('temp', 'warm', 'triangular', (15, 25, 35))  # Overlaps at 15-20\nsystem.add_term('temp', 'hot', 'triangular', (30, 40, 40))   # Overlaps at 30-35\n</code></pre>"},{"location":"user_guide/inference_systems/#3-rule-completeness","title":"3. Rule Completeness","text":"<p>Every possible input combination should activate at least one rule.</p> <p>Check coverage: <pre><code># Test grid\nimport numpy as np\ntemps = np.linspace(0, 40, 20)\nhumids = np.linspace(0, 100, 20)\n\nfor t in temps:\n    for h in humids:\n        try:\n            result = system.evaluate(temperature=t, humidity=h)\n        except:\n            print(f\"No coverage at temp={t}, humidity={h}\")\n</code></pre></p>"},{"location":"user_guide/inference_systems/#4-rule-consistency","title":"4. Rule Consistency","text":"<p>Avoid contradictory rules:</p> <p>Bad: <pre><code>system.add_rules([\n    {'temp': 'hot', 'humidity': 'high', 'comfort': 'good'},      # \u274c\n    {'temp': 'hot', 'humidity': 'high', 'comfort': 'bad'}        # \u274c Conflict!\n])\n</code></pre></p> <p>Good: <pre><code>system.add_rules([\n    {'temp': 'hot', 'humidity': 'high', 'comfort': 'bad'},       # \u2713\n    {'temp': 'hot', 'humidity': 'low', 'comfort': 'moderate'}    # \u2713 No conflict\n])\n</code></pre></p>"},{"location":"user_guide/inference_systems/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/inference_systems/#problem-output-is-always-the-same","title":"Problem: Output is always the same","text":"<p>Cause: Rules are not being activated.</p> <p>Debug: <pre><code>details = system.evaluate_detailed(temperature=25)\nprint(details['rule_activations'])  # All zeros?\n</code></pre></p> <p>Fix: Check term coverage with <code>system.plot_variables()</code>.</p>"},{"location":"user_guide/inference_systems/#problem-output-is-stuck-at-universe-boundary","title":"Problem: Output is stuck at universe boundary","text":"<p>Cause: All active rules point to extreme values.</p> <p>Fix: Add intermediate terms or adjust MF parameters.</p>"},{"location":"user_guide/inference_systems/#problem-system-is-too-slow","title":"Problem: System is too slow","text":"<p>Solutions: 1. Use Sugeno instead of Mamdani 2. Reduce number of points in universe (default: 1000) 3. Use simpler MFs (triangular instead of gaussian) 4. Cache results for repeated inputs</p>"},{"location":"user_guide/inference_systems/#next-steps","title":"Next Steps","text":"<ul> <li>Learning: Automatically generate rules from data</li> <li>API Reference: Inference: Complete method documentation</li> <li>Examples: Inference: Interactive notebooks</li> </ul>"},{"location":"user_guide/inference_systems/#further-reading","title":"Further Reading","text":"<ul> <li>Mamdani, E. H. (1974): \"Application of fuzzy algorithms for control of simple dynamic plant\". Proceedings of the IEE, 121(12), 1585-1588.</li> <li>Takagi, T., &amp; Sugeno, M. (1985): \"Fuzzy identification of systems and its applications to modeling and control\". IEEE Transactions on Systems, Man, and Cybernetics, (1), 116-132.</li> </ul>"},{"location":"user_guide/learning/","title":"User Guide: Learning Systems","text":"<p>This guide covers how to automatically generate fuzzy systems from data using various learning algorithms.</p>"},{"location":"user_guide/learning/#why-learn-fuzzy-systems-from-data","title":"Why Learn Fuzzy Systems from Data?","text":"<p>Manual approach: - Define membership functions by hand - Write rules based on expert knowledge - Time-consuming and subjective</p> <p>Learning approach: - Automatically extract rules from data - Optimize membership function parameters - Data-driven and objective</p> <p>When to use learning: - You have training data (input-output pairs) - Expert knowledge is incomplete or unavailable - You need to tune an existing system - The system needs to adapt over time</p>"},{"location":"user_guide/learning/#overview-of-learning-methods","title":"Overview of Learning Methods","text":"Method Type Speed Interpretability Best For Wang-Mendel Rule extraction \u26a1\u26a1\u26a1 Fast \u2b50\u2b50\u2b50 High Quick prototyping, simple datasets ANFIS Neuro-fuzzy \u26a1\u26a1 Moderate \u2b50\u2b50 Moderate Function approximation, regression Mamdani Learning Metaheuristics \u26a1 Slow \u2b50\u2b50\u2b50 High Complex optimization, interpretable rules <p>Quick decision guide: - Need interpretable rules fast? \u2192 Wang-Mendel - Need precise predictions? \u2192 ANFIS - Need custom optimization? \u2192 Mamdani Learning + PSO/DE/GA</p>"},{"location":"user_guide/learning/#wang-mendel-algorithm","title":"Wang-Mendel Algorithm","text":"<p>The Wang-Mendel algorithm generates fuzzy rules directly from data in one pass.</p>"},{"location":"user_guide/learning/#how-it-works","title":"How It Works","text":"<ol> <li>Partition input/output spaces into fuzzy sets</li> <li>Generate candidate rules from each data point</li> <li>Resolve conflicts by keeping rules with highest degree</li> <li>Create rule base from non-conflicting rules</li> </ol>"},{"location":"user_guide/learning/#basic-example-regression","title":"Basic Example: Regression","text":"<pre><code>from fuzzy_systems.learning import WangMendelLearning\nimport numpy as np\n\n# Generate training data\nX = np.linspace(0, 10, 50).reshape(-1, 1)\ny = np.sin(X).ravel() + np.random.normal(0, 0.1, 50)\n\n# Create learner\nlearner = WangMendelLearning(\n    n_inputs=1,\n    n_outputs=1,\n    n_terms=5,  # 5 fuzzy sets per variable\n    input_ranges=[(0, 10)],\n    output_ranges=[(-1.5, 1.5)]\n)\n\n# Learn from data\nsystem = learner.fit(X, y)\n\n# Predict\nX_test = np.linspace(0, 10, 100).reshape(-1, 1)\ny_pred = learner.predict(X_test)\n\n# Evaluate\nfrom sklearn.metrics import mean_squared_error\nmse = mean_squared_error(y, learner.predict(X))\nprint(f\"MSE: {mse:.4f}\")\n</code></pre> <p>What happened: 1. Algorithm partitioned [0, 10] into 5 fuzzy sets: very_low, low, medium, high, very_high 2. For each data point, it created a rule like: \"IF x is medium THEN y is medium\" 3. Conflicting rules were resolved by keeping the one with highest membership degree 4. Result: A Mamdani system with ~15-25 rules (fewer than 5\u00b9=5 maximum)</p>"},{"location":"user_guide/learning/#classification-example","title":"Classification Example","text":"<p>Wang-Mendel also works for classification:</p> <pre><code>from sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\n# Load data\niris = load_iris()\nX_train, X_test, y_train, y_test = train_test_split(\n    iris.data, iris.target, test_size=0.3, random_state=42\n)\n\n# Learn classifier\nlearner = WangMendelLearning(\n    n_inputs=4,\n    n_outputs=1,\n    n_terms=3,\n    input_ranges=[(X_train[:, i].min(), X_train[:, i].max()) for i in range(4)],\n    output_ranges=[(0, 2)]  # 3 classes: 0, 1, 2\n)\n\nsystem = learner.fit(X_train, y_train)\n\n# Predict\ny_pred = learner.predict(X_test).round().astype(int)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"Accuracy: {accuracy:.2%}\")\n</code></pre>"},{"location":"user_guide/learning/#wang-mendel-parameters","title":"Wang-Mendel Parameters","text":""},{"location":"user_guide/learning/#number-of-terms-n_terms","title":"Number of Terms (<code>n_terms</code>)","text":"<p>Controls granularity of fuzzy partitions:</p> <pre><code># Coarse (faster, fewer rules)\nlearner = WangMendelLearning(n_terms=3, ...)\n\n# Fine (slower, more rules, more precise)\nlearner = WangMendelLearning(n_terms=7, ...)\n</code></pre> <p>Guidelines: - 3 terms: Simple problems, fast prototyping - 5 terms: Good default for most problems - 7-9 terms: Complex, nonlinear relationships</p>"},{"location":"user_guide/learning/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple rules have the same antecedent:</p> <pre><code>learner = WangMendelLearning(\n    conflict_resolution='degree',  # Default: keep rule with highest degree\n    # conflict_resolution='first'  # Keep first rule encountered\n)\n</code></pre>"},{"location":"user_guide/learning/#strengths-and-limitations","title":"Strengths and Limitations","text":"<p>Strengths: - \u26a1 Very fast (single pass over data) - \ud83e\udde0 Generates interpretable rules - \ud83d\udcca Works with small datasets - \ud83c\udfaf Good for quick prototyping</p> <p>Limitations: - \ud83d\udd27 No parameter optimization (MF shapes are fixed) - \ud83d\udcc9 May not achieve best accuracy - \ud83c\udfb2 Sensitive to initial partitioning - \ud83d\uddd1\ufe0f May generate redundant rules</p> <p>When to use: - You need a baseline quickly - Interpretability is more important than accuracy - Data is limited or expensive - You want to understand the problem structure</p>"},{"location":"user_guide/learning/#anfis-adaptive-neuro-fuzzy-inference-system","title":"ANFIS (Adaptive Neuro-Fuzzy Inference System)","text":"<p>ANFIS combines neural networks with fuzzy logic to learn both rule structure and parameters.</p>"},{"location":"user_guide/learning/#architecture","title":"Architecture","text":"<p>ANFIS is a Sugeno system trained like a neural network:</p> <pre><code>Input \u2192 Fuzzification \u2192 Rules \u2192 Normalization \u2192 Defuzzification \u2192 Output\n          (Layer 1)    (Layer 2)   (Layer 3)       (Layer 4)\n</code></pre> <p>Learnable parameters: - Premise parameters: Membership function shapes (c, \u03c3 for gaussian) - Consequent parameters: Linear function coefficients (a, b, c in y = ax\u2081 + bx\u2082 + c)</p>"},{"location":"user_guide/learning/#basic-example","title":"Basic Example","text":"<pre><code>from fuzzy_systems.learning import ANFIS\nimport numpy as np\n\n# Generate training data\nX = np.random.rand(200, 2) * 10\ny = X[:, 0]**2 + 2*X[:, 1] + np.random.normal(0, 0.5, 200)\n\n# Create ANFIS\nanfis = ANFIS(\n    n_inputs=2,\n    n_terms=3,  # 3 MFs per input \u2192 3\u00b2 = 9 rules\n    mf_type='gaussian'\n)\n\n# Train\nhistory = anfis.fit(\n    X, y,\n    epochs=50,\n    learning_rate=0.01,\n    batch_size=32,\n    validation_split=0.2,\n    verbose=True\n)\n\n# Predict\nX_test = np.random.rand(50, 2) * 10\ny_pred = anfis.predict(X_test)\n\n# Check convergence\nimport matplotlib.pyplot as plt\nplt.plot(history['loss'], label='Train')\nplt.plot(history['val_loss'], label='Validation')\nplt.xlabel('Epoch')\nplt.ylabel('MSE')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"user_guide/learning/#training-parameters","title":"Training Parameters","text":""},{"location":"user_guide/learning/#learning-rate","title":"Learning Rate","text":"<p>Controls step size of gradient descent:</p> <pre><code># Too high: unstable, oscillates\nanfis = ANFIS(n_inputs=2, n_terms=3)\nanfis.fit(X, y, learning_rate=0.1)  # \u26a0\ufe0f May diverge\n\n# Too low: slow convergence\nanfis.fit(X, y, learning_rate=0.0001)  # \ud83d\udc0c Takes forever\n\n# Good range: 0.001 - 0.01\nanfis.fit(X, y, learning_rate=0.005)  # \u2713 Usually works well\n</code></pre>"},{"location":"user_guide/learning/#number-of-epochs","title":"Number of Epochs","text":"<pre><code># Monitor validation loss to avoid overfitting\nhistory = anfis.fit(\n    X, y,\n    epochs=100,\n    validation_split=0.2,\n    early_stopping=True,  # Stop if val_loss doesn't improve\n    patience=10\n)\n</code></pre>"},{"location":"user_guide/learning/#batch-size","title":"Batch Size","text":"<pre><code># Small batches: more updates, noisier gradients\nanfis.fit(X, y, batch_size=16)\n\n# Large batches: fewer updates, smoother gradients\nanfis.fit(X, y, batch_size=128)\n\n# Rule of thumb: 32 or 64 for most problems\n</code></pre>"},{"location":"user_guide/learning/#hybrid-learning-advanced","title":"Hybrid Learning (Advanced)","text":"<p>ANFIS supports hybrid learning: gradient descent for premise parameters + least squares for consequent parameters.</p> <pre><code>anfis = ANFIS(\n    n_inputs=2,\n    n_terms=3,\n    learning_method='hybrid'  # Faster convergence\n)\n\nanfis.fit(X, y, epochs=30)  # Needs fewer epochs\n</code></pre> <p>Comparison:</p> Method Speed Stability When to use <code>'gradient'</code> \u26a1\u26a1 Moderate \u2b50\u2b50 Can be unstable Small datasets, simple problems <code>'hybrid'</code> \u26a1\u26a1\u26a1 Fast \u2b50\u2b50\u2b50 Stable Large datasets, complex problems"},{"location":"user_guide/learning/#extracting-rules","title":"Extracting Rules","text":"<p>After training, inspect learned rules:</p> <pre><code># Get Sugeno system\nsystem = anfis.get_system()\n\n# Print rules\nfor i, rule in enumerate(system.rules):\n    print(f\"Rule {i+1}:\")\n    print(f\"  IF x1 is {rule['x1']} AND x2 is {rule['x2']}\")\n    print(f\"  THEN y = {rule['a']}*x1 + {rule['b']}*x2 + {rule['c']}\")\n    print()\n\n# Visualize membership functions\nsystem.plot_variables(['x1', 'x2'])\n</code></pre>"},{"location":"user_guide/learning/#strengths-and-limitations_1","title":"Strengths and Limitations","text":"<p>Strengths: - \ud83c\udfaf High accuracy on regression tasks - \ud83d\udd27 Optimizes both structure and parameters - \ud83d\udcca Handles nonlinear relationships well - \ud83e\uddee Efficient gradient-based learning</p> <p>Limitations: - \ud83e\udd14 Less interpretable than Wang-Mendel - \ud83d\udcc8 Can overfit on small datasets - \ud83d\udd22 Requires tuning hyperparameters - \ud83c\udfd7\ufe0f Sugeno output (functions, not linguistic terms)</p> <p>When to use: - Accuracy is the priority - You have enough training data (100+ samples) - Regression or function approximation task - You can accept Sugeno-style outputs</p>"},{"location":"user_guide/learning/#mamdani-learning-with-metaheuristics","title":"Mamdani Learning with Metaheuristics","text":"<p>For highly interpretable systems, learn Mamdani rules using metaheuristic optimization.</p>"},{"location":"user_guide/learning/#why-metaheuristics","title":"Why Metaheuristics?","text":"<p>Mamdani systems are hard to optimize with gradients because: - Defuzzification (centroid) is non-differentiable - Rule structure is discrete - MF parameters interact in complex ways</p> <p>Metaheuristics (PSO, DE, GA) are gradient-free and handle this naturally.</p>"},{"location":"user_guide/learning/#particle-swarm-optimization-pso","title":"Particle Swarm Optimization (PSO)","text":"<p>PSO simulates a swarm of particles searching for optimal parameters.</p> <pre><code>from fuzzy_systems.learning import MamdaniLearning\nimport numpy as np\n\n# Generate data\nX = np.linspace(0, 10, 100).reshape(-1, 1)\ny = np.sin(X).ravel()\n\n# Create learner\nlearner = MamdaniLearning(\n    n_inputs=1,\n    n_outputs=1,\n    n_terms=5,\n    input_ranges=[(0, 10)],\n    output_ranges=[(-1, 1)],\n    mf_type='triangular'\n)\n\n# Initialize random system\nsystem = learner.initialize_system()\n\n# Optimize with PSO\noptimized_system, history = learner.optimize(\n    X, y,\n    method='pso',\n    n_particles=30,\n    n_iterations=100,\n    inertia=0.7,\n    cognitive=1.5,\n    social=1.5,\n    verbose=True\n)\n\n# Predict\ny_pred = optimized_system.evaluate_batch(X)\n</code></pre> <p>PSO Parameters:</p> <pre><code>learner.optimize(\n    X, y,\n    method='pso',\n    n_particles=30,    # Population size (20-50 typical)\n    n_iterations=100,  # Generations (50-200 typical)\n    inertia=0.7,       # Velocity decay (0.4-0.9)\n    cognitive=1.5,     # Personal best influence\n    social=1.5         # Global best influence\n)\n</code></pre> <p>Tuning guide: - Exploration (diverse search): High inertia (0.8-0.9), low social (1.0-1.5) - Exploitation (refine best): Low inertia (0.4-0.6), high social (2.0-2.5)</p>"},{"location":"user_guide/learning/#differential-evolution-de","title":"Differential Evolution (DE)","text":"<p>DE uses difference vectors to mutate solutions.</p> <pre><code>optimized_system, history = learner.optimize(\n    X, y,\n    method='de',\n    population_size=40,\n    n_iterations=100,\n    mutation_factor=0.8,   # F: controls mutation strength\n    crossover_prob=0.7,    # CR: controls recombination\n    strategy='best1bin',   # Mutation strategy\n    verbose=True\n)\n</code></pre> <p>DE Parameters:</p> Parameter Range Effect <code>mutation_factor</code> (F) 0.4-1.0 Higher \u2192 more exploration <code>crossover_prob</code> (CR) 0.5-0.9 Higher \u2192 faster convergence <code>strategy</code> 'best1bin', 'rand1bin', 'best2bin' Mutation scheme <p>Strategies: - <code>'best1bin'</code>: Exploits best solution (fast convergence) - <code>'rand1bin'</code>: More exploration (avoid local optima) - <code>'best2bin'</code>: Balanced (good default)</p>"},{"location":"user_guide/learning/#genetic-algorithm-ga","title":"Genetic Algorithm (GA)","text":"<p>GA uses selection, crossover, and mutation.</p> <pre><code>optimized_system, history = learner.optimize(\n    X, y,\n    method='ga',\n    population_size=50,\n    n_iterations=100,\n    crossover_prob=0.8,\n    mutation_prob=0.1,\n    selection_method='tournament',\n    tournament_size=3,\n    elitism=True,  # Keep best individuals\n    verbose=True\n)\n</code></pre> <p>GA Parameters:</p> <pre><code>learner.optimize(\n    X, y,\n    method='ga',\n    crossover_prob=0.8,     # High crossover (0.7-0.9)\n    mutation_prob=0.1,      # Low mutation (0.01-0.1)\n    selection_method='tournament',  # or 'roulette', 'rank'\n    tournament_size=3,      # Tournament selection size\n    elitism=True           # Preserve best solutions\n)\n</code></pre>"},{"location":"user_guide/learning/#comparing-metaheuristics","title":"Comparing Metaheuristics","text":"<pre><code>methods = ['pso', 'de', 'ga']\nresults = {}\n\nfor method in methods:\n    system, history = learner.optimize(\n        X, y,\n        method=method,\n        n_iterations=100,\n        verbose=False\n    )\n\n    y_pred = system.evaluate_batch(X)\n    mse = np.mean((y - y_pred['output'])**2)\n    results[method] = mse\n\n    print(f\"{method.upper()}: MSE = {mse:.4f}\")\n\n# Plot convergence\nimport matplotlib.pyplot as plt\nfor method in methods:\n    _, history = learner.optimize(X, y, method=method, n_iterations=100, verbose=False)\n    plt.plot(history['fitness'], label=method.upper())\n\nplt.xlabel('Iteration')\nplt.ylabel('Fitness (MSE)')\nplt.legend()\nplt.yscale('log')\nplt.show()\n</code></pre> <p>Performance comparison:</p> Method Speed Exploration Stability Best for PSO \u26a1\u26a1\u26a1 Fast \u2b50\u2b50 Moderate \u2b50\u2b50\u2b50 Very stable Continuous optimization, fast results DE \u26a1\u26a1 Moderate \u2b50\u2b50\u2b50 High \u2b50\u2b50 Moderate Complex landscapes, avoiding local optima GA \u26a1 Slow \u2b50\u2b50\u2b50 High \u2b50\u2b50 Moderate Discrete+continuous, diverse solutions <p>Rule of thumb: - Start with PSO (fastest, stable) - Switch to DE if PSO gets stuck - Use GA for discrete optimization (e.g., rule selection)</p>"},{"location":"user_guide/learning/#what-gets-optimized","title":"What Gets Optimized?","text":"<p>You can control what parameters are optimized:</p> <pre><code>learner = MamdaniLearning(\n    n_inputs=1,\n    n_outputs=1,\n    n_terms=5,\n    optimize_mf=True,      # Optimize membership function parameters\n    optimize_rules=True,   # Optimize rule weights\n    optimize_defuzz=False  # Keep defuzzification method fixed\n)\n</code></pre> <p>Typical configurations:</p> <p>Configuration 1: MF parameters only <pre><code>optimize_mf=True, optimize_rules=False\n</code></pre> - Fastest - Good if rule structure is already known - Fine-tunes MF shapes</p> <p>Configuration 2: Full optimization <pre><code>optimize_mf=True, optimize_rules=True\n</code></pre> - Slowest but most flexible - Optimizes everything - Best accuracy potential</p> <p>Configuration 3: Rules only <pre><code>optimize_mf=False, optimize_rules=True\n</code></pre> - Medium speed - Good if MFs are well-designed - Tunes rule weights and operators</p>"},{"location":"user_guide/learning/#strengths-and-limitations_2","title":"Strengths and Limitations","text":"<p>Strengths: - \u2b50\u2b50\u2b50 Highly interpretable (Mamdani output) - \ud83d\udd27 No gradients needed - \ud83c\udfaf Can optimize discrete and continuous parameters - \ud83c\udf10 Global search (avoids local optima)</p> <p>Limitations: - \u23f1\ufe0f Very slow (minutes to hours) - \ud83c\udfb2 Stochastic (results vary between runs) - \ud83d\udd22 Many hyperparameters to tune - \ud83d\udcbe Memory-intensive for large populations</p> <p>When to use: - Interpretability is critical - You have time for optimization - Gradient-based methods don't work - You need linguistic outputs (Mamdani)</p>"},{"location":"user_guide/learning/#choosing-a-learning-method","title":"Choosing a Learning Method","text":""},{"location":"user_guide/learning/#decision-tree","title":"Decision Tree","text":"<pre><code>Do you have labeled data?\n\u251c\u2500 No \u2192 Use expert knowledge (manual design)\n\u2514\u2500 Yes \u2192 Continue\n\nHow important is interpretability?\n\u251c\u2500 Critical \u2192 Wang-Mendel or Mamdani Learning\n\u2514\u2500 Less important \u2192 ANFIS\n\nHow much data do you have?\n\u251c\u2500 Small (&lt;100 samples) \u2192 Wang-Mendel\n\u251c\u2500 Medium (100-1000) \u2192 ANFIS\n\u2514\u2500 Large (&gt;1000) \u2192 ANFIS or Mamdani + PSO\n\nHow much time can you spend?\n\u251c\u2500 Minutes \u2192 Wang-Mendel\n\u251c\u2500 Hours \u2192 ANFIS\n\u2514\u2500 Hours to days \u2192 Mamdani Learning\n</code></pre>"},{"location":"user_guide/learning/#practical-comparison","title":"Practical Comparison","text":"<pre><code>from fuzzy_systems.learning import WangMendelLearning, ANFIS, MamdaniLearning\nimport time\n\n# Prepare data\nX_train, y_train = ...  # Your data here\n\n# Method 1: Wang-Mendel\nstart = time.time()\nwm = WangMendelLearning(n_inputs=2, n_outputs=1, n_terms=5)\nwm_system = wm.fit(X_train, y_train)\nwm_time = time.time() - start\nwm_pred = wm.predict(X_test)\nwm_mse = np.mean((y_test - wm_pred)**2)\nprint(f\"Wang-Mendel: MSE={wm_mse:.4f}, Time={wm_time:.2f}s\")\n\n# Method 2: ANFIS\nstart = time.time()\nanfis = ANFIS(n_inputs=2, n_terms=3)\nanfis.fit(X_train, y_train, epochs=50, verbose=False)\nanfis_time = time.time() - start\nanfis_pred = anfis.predict(X_test)\nanfis_mse = np.mean((y_test - anfis_pred)**2)\nprint(f\"ANFIS: MSE={anfis_mse:.4f}, Time={anfis_time:.2f}s\")\n\n# Method 3: Mamdani + PSO\nstart = time.time()\nml = MamdaniLearning(n_inputs=2, n_outputs=1, n_terms=5)\nml_system, _ = ml.optimize(X_train, y_train, method='pso',\n                           n_iterations=50, verbose=False)\nml_time = time.time() - start\nml_pred = ml_system.evaluate_batch(X_test)['output']\nml_mse = np.mean((y_test - ml_pred)**2)\nprint(f\"Mamdani+PSO: MSE={ml_mse:.4f}, Time={ml_time:.2f}s\")\n</code></pre>"},{"location":"user_guide/learning/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user_guide/learning/#transfer-learning","title":"Transfer Learning","text":"<p>Start from a pre-trained system:</p> <pre><code># Load pre-trained system\nbase_system = MamdaniSystem.load('pretrained.pkl')\n\n# Fine-tune with new data\nlearner = MamdaniLearning.from_system(base_system)\noptimized_system, _ = learner.optimize(\n    X_new, y_new,\n    method='pso',\n    n_iterations=50  # Fewer iterations needed\n)\n</code></pre>"},{"location":"user_guide/learning/#ensemble-learning","title":"Ensemble Learning","text":"<p>Combine multiple fuzzy systems:</p> <pre><code>from fuzzy_systems.learning import FuzzyEnsemble\n\n# Train multiple systems\nsystems = []\nfor seed in range(5):\n    np.random.seed(seed)\n    learner = MamdaniLearning(n_inputs=2, n_outputs=1, n_terms=5)\n    system, _ = learner.optimize(X_train, y_train, method='pso',\n                                  n_iterations=50, verbose=False)\n    systems.append(system)\n\n# Create ensemble\nensemble = FuzzyEnsemble(systems, method='average')  # or 'weighted', 'voting'\n\n# Predict\ny_pred = ensemble.predict(X_test)\n</code></pre>"},{"location":"user_guide/learning/#cross-validation","title":"Cross-Validation","text":"<p>Evaluate generalization performance:</p> <pre><code>from sklearn.model_selection import KFold\nfrom sklearn.metrics import mean_squared_error\n\nkfold = KFold(n_splits=5, shuffle=True, random_state=42)\nscores = []\n\nfor train_idx, val_idx in kfold.split(X):\n    X_train, X_val = X[train_idx], X[val_idx]\n    y_train, y_val = y[train_idx], y[val_idx]\n\n    # Train ANFIS\n    anfis = ANFIS(n_inputs=2, n_terms=3)\n    anfis.fit(X_train, y_train, epochs=50, verbose=False)\n\n    # Evaluate\n    y_pred = anfis.predict(X_val)\n    mse = mean_squared_error(y_val, y_pred)\n    scores.append(mse)\n\nprint(f\"Cross-validation MSE: {np.mean(scores):.4f} \u00b1 {np.std(scores):.4f}\")\n</code></pre>"},{"location":"user_guide/learning/#regularization","title":"Regularization","text":"<p>Prevent overfitting in ANFIS:</p> <pre><code>anfis = ANFIS(n_inputs=2, n_terms=3)\nanfis.fit(\n    X, y,\n    epochs=100,\n    learning_rate=0.01,\n    l2_penalty=0.001,  # L2 regularization on consequent parameters\n    dropout=0.1,       # Dropout on rule activations\n    validation_split=0.2\n)\n</code></pre>"},{"location":"user_guide/learning/#design-guidelines","title":"Design Guidelines","text":""},{"location":"user_guide/learning/#1-data-preparation","title":"1. Data Preparation","text":"<p>Normalization: <pre><code>from sklearn.preprocessing import StandardScaler\n\nscaler_X = StandardScaler()\nscaler_y = StandardScaler()\n\nX_scaled = scaler_X.fit_transform(X)\ny_scaled = scaler_y.fit_transform(y.reshape(-1, 1)).ravel()\n\n# Train on scaled data\nanfis.fit(X_scaled, y_scaled, ...)\n\n# Predict and inverse transform\ny_pred_scaled = anfis.predict(X_test_scaled)\ny_pred = scaler_y.inverse_transform(y_pred_scaled.reshape(-1, 1)).ravel()\n</code></pre></p> <p>Why normalize: - Improves convergence speed - Balances influence of different features - Prevents numerical instability</p>"},{"location":"user_guide/learning/#2-number-of-terms-vs-dataset-size","title":"2. Number of Terms vs Dataset Size","text":"Dataset Size Recommended n_terms Total Rules (2 inputs) &lt; 50 samples 3 9 50-200 samples 3-5 9-25 200-1000 samples 5-7 25-49 &gt; 1000 samples 7-9 49-81 <p>Rule of thumb: Total rules should be \u2264 N/10 where N is dataset size.</p>"},{"location":"user_guide/learning/#3-avoiding-overfitting","title":"3. Avoiding Overfitting","text":"<p>Symptoms: - Training error very low, test error high - Validation loss starts increasing after some epochs - System output is jagged or oscillates</p> <p>Solutions:</p> <p>Reduce model complexity: <pre><code># Fewer terms\nanfis = ANFIS(n_inputs=2, n_terms=3)  # instead of 5 or 7\n\n# Simpler MF types\nlearner = MamdaniLearning(mf_type='triangular')  # instead of gaussian\n</code></pre></p> <p>Early stopping: <pre><code>anfis.fit(X, y, epochs=200, early_stopping=True, patience=15)\n</code></pre></p> <p>Regularization: <pre><code>anfis.fit(X, y, l2_penalty=0.01)\n</code></pre></p> <p>Get more data: - Collect more samples - Use data augmentation (carefully!) - Use cross-validation to detect overfitting</p>"},{"location":"user_guide/learning/#4-hyperparameter-tuning","title":"4. Hyperparameter Tuning","text":"<p>Use grid search or random search:</p> <pre><code>from sklearn.model_selection import ParameterGrid\nfrom sklearn.metrics import mean_squared_error\n\n# Define parameter grid\nparam_grid = {\n    'n_terms': [3, 5, 7],\n    'learning_rate': [0.001, 0.005, 0.01],\n    'l2_penalty': [0, 0.001, 0.01]\n}\n\nbest_score = float('inf')\nbest_params = None\n\nfor params in ParameterGrid(param_grid):\n    anfis = ANFIS(n_inputs=2, n_terms=params['n_terms'])\n    anfis.fit(X_train, y_train,\n              epochs=50,\n              learning_rate=params['learning_rate'],\n              l2_penalty=params['l2_penalty'],\n              verbose=False)\n\n    y_pred = anfis.predict(X_val)\n    score = mean_squared_error(y_val, y_pred)\n\n    if score &lt; best_score:\n        best_score = score\n        best_params = params\n\nprint(f\"Best params: {best_params}\")\nprint(f\"Best MSE: {best_score:.4f}\")\n</code></pre>"},{"location":"user_guide/learning/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/learning/#problem-anfis-loss-is-nan","title":"Problem: ANFIS loss is NaN","text":"<p>Causes: - Learning rate too high - Numerical overflow</p> <p>Solutions: <pre><code># Reduce learning rate\nanfis.fit(X, y, learning_rate=0.001)\n\n# Normalize data\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\n\n# Use gradient clipping\nanfis.fit(X, y, clip_gradients=True, max_grad_norm=1.0)\n</code></pre></p>"},{"location":"user_guide/learning/#problem-metaheuristic-optimization-is-stuck","title":"Problem: Metaheuristic optimization is stuck","text":"<p>Symptoms: - Fitness doesn't improve after many iterations - All particles/individuals converge to same solution</p> <p>Solutions:</p> <p>Increase diversity: <pre><code># PSO: increase inertia\nlearner.optimize(X, y, method='pso', inertia=0.9)\n\n# DE: increase mutation factor\nlearner.optimize(X, y, method='de', mutation_factor=0.9)\n\n# GA: increase mutation probability\nlearner.optimize(X, y, method='ga', mutation_prob=0.2)\n</code></pre></p> <p>Increase population: <pre><code>learner.optimize(X, y, method='pso', n_particles=50)  # instead of 30\n</code></pre></p> <p>Try different method: <pre><code># If PSO stuck, try DE\nlearner.optimize(X, y, method='de')\n</code></pre></p>"},{"location":"user_guide/learning/#problem-wang-mendel-generates-too-many-rules","title":"Problem: Wang-Mendel generates too many rules","text":"<p>Cause: Too many terms or sparse data distribution.</p> <p>Solutions:</p> <p>Reduce n_terms: <pre><code>learner = WangMendelLearning(n_terms=3)  # instead of 5 or 7\n</code></pre></p> <p>Prune rules after learning: <pre><code>system = learner.fit(X, y)\n\n# Remove rules with low activation\nlearner.prune_rules(min_activation=0.1)\n\n# Or keep only top K rules\nlearner.keep_top_rules(k=20)\n</code></pre></p>"},{"location":"user_guide/learning/#problem-learning-is-too-slow","title":"Problem: Learning is too slow","text":"<p>For ANFIS: <pre><code># Reduce epochs\nanfis.fit(X, y, epochs=30)  # instead of 100\n\n# Increase batch size\nanfis.fit(X, y, batch_size=128)  # instead of 32\n\n# Use hybrid learning\nanfis = ANFIS(learning_method='hybrid')\n</code></pre></p> <p>For metaheuristics: <pre><code># Reduce population and iterations\nlearner.optimize(X, y, method='pso',\n                 n_particles=20, n_iterations=50)\n\n# Parallelize (if available)\nlearner.optimize(X, y, method='pso', n_jobs=-1)\n</code></pre></p>"},{"location":"user_guide/learning/#next-steps","title":"Next Steps","text":"<ul> <li>Inference Systems: Build systems manually before learning</li> <li>API Reference: Learning: Complete method documentation</li> <li>Examples: Learning: Interactive notebooks</li> </ul>"},{"location":"user_guide/learning/#further-reading","title":"Further Reading","text":"<ul> <li>Wang, L. X., &amp; Mendel, J. M. (1992): \"Generating fuzzy rules by learning from examples\". IEEE Transactions on Systems, Man, and Cybernetics, 22(6), 1414-1427.</li> <li>Jang, J. S. (1993): \"ANFIS: adaptive-network-based fuzzy inference system\". IEEE Transactions on Systems, Man, and Cybernetics, 23(3), 665-685.</li> <li>Eberhart, R., &amp; Kennedy, J. (1995): \"Particle swarm optimization\". Proceedings of ICNN'95, Vol. 4, 1942-1948.</li> <li>Storn, R., &amp; Price, K. (1997): \"Differential evolution\u2013a simple and efficient heuristic for global optimization over continuous spaces\". Journal of Global Optimization, 11(4), 341-359.</li> </ul>"}]}